<html>
<head><meta charset="utf-8" /></head>
<body>
    <div>                        <script type="text/javascript">window.PlotlyConfig = {MathJaxConfig: 'local'};</script>
        <script charset="utf-8" src="https://cdn.plot.ly/plotly-3.1.0.min.js" integrity="sha256-Ei4740bWZhaUTQuD6q9yQlgVCMPBz6CZWhevDYPv93A=" crossorigin="anonymous"></script>                <div id="acffdd4b-fbb5-453d-a13f-13968588f17e" class="plotly-graph-div" style="height:800px; width:1600px;"></div>            <script type="text/javascript">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById("acffdd4b-fbb5-453d-a13f-13968588f17e")) {                    Plotly.newPlot(                        "acffdd4b-fbb5-453d-a13f-13968588f17e",                        [{"hoverinfo":"none","line":{"color":"#888","width":0.5},"mode":"lines","x":[0,-727.2727272727273,null,0,-545.4545454545455,null,0,-363.6363636363636,null,0,-181.8181818181818,null,0,0.0,null,0,181.8181818181818,null,0,545.4545454545455,null,0,727.2727272727273,null,-727.2727272727273,-727.2727272727273,null,-727.2727272727273,-630.3030303030303,null,-727.2727272727273,-533.3333333333334,null,-727.2727272727273,-436.3636363636363,null,-181.8181818181818,-339.3939393939394,null,-181.8181818181818,-242.42424242424244,null,-181.8181818181818,-145.4545454545454,null,-181.8181818181818,-48.48484848484847,null,-181.8181818181818,48.48484848484847,null,-181.8181818181818,145.4545454545454,null,-181.8181818181818,242.42424242424235,null,-181.8181818181818,339.3939393939393,null,363.6363636363636,436.36363636363643,null,363.6363636363636,533.3333333333334,null,363.6363636363636,727.2727272727273,null,-436.3636363636363,-727.2727272727273,null,-436.3636363636363,-684.4919786096257,null,-436.3636363636363,-641.711229946524,null,-436.3636363636363,-598.9304812834224,null,-436.3636363636363,-556.1497326203208,null,48.48484848484847,-513.3689839572191,null,48.48484848484847,-470.58823529411757,null,48.48484848484847,-427.80748663101605,null,48.48484848484847,-385.0267379679144,null,48.48484848484847,-342.24598930481284,null,48.48484848484847,-299.4652406417112,null,48.48484848484847,-256.68449197860957,null,48.48484848484847,-213.903743315508,null,48.48484848484847,-171.12299465240645,null,48.48484848484847,-128.34224598930484,null,48.48484848484847,-85.56149732620322,null,48.48484848484847,-42.78074866310161,null,48.48484848484847,0.0,null,48.48484848484847,42.78074866310161,null,48.48484848484847,85.56149732620322,null,48.48484848484847,128.34224598930484,null,48.48484848484847,171.12299465240645,null,48.48484848484847,213.90374331550805,null,48.48484848484847,256.6844919786097,null,48.48484848484847,299.46524064171126,null,48.48484848484847,342.2459893048129,null,339.3939393939393,385.02673796791436,null,339.3939393939393,427.807486631016,null,339.3939393939393,470.58823529411757,null,339.3939393939393,513.3689839572191,null,339.3939393939393,556.1497326203208,null,339.3939393939393,598.9304812834224,null,630.3030303030303,641.711229946524,null,630.3030303030303,727.2727272727273,null,-598.9304812834224,-727.2727272727273,null,-598.9304812834224,-484.8484848484849,null,-598.9304812834224,-242.42424242424244,null,-598.9304812834224,0.0,null,-556.1497326203208,242.42424242424235,null,684.4919786096257,727.2727272727273,null,-727.2727272727273,-727.2727272727273,null,-727.2727272727273,-704.1847041847042,null,-727.2727272727273,-681.0966810966811,null,-727.2727272727273,-658.008658008658,null,-727.2727272727273,-634.9206349206349,null,-727.2727272727273,-611.8326118326119,null,-727.2727272727273,-588.7445887445888,null,-727.2727272727273,-565.6565656565657,null,-727.2727272727273,-542.5685425685425,null,-727.2727272727273,-519.4805194805194,null,-727.2727272727273,-496.3924963924964,null,-727.2727272727273,-473.30447330447333,null,-727.2727272727273,-450.2164502164502,null,-727.2727272727273,-427.1284271284271,null,-727.2727272727273,-404.04040404040404,null,-727.2727272727273,-380.95238095238096,null,-484.8484848484849,-357.8643578643579,null,-484.8484848484849,-334.7763347763348,null,-484.8484848484849,-311.6883116883117,null,-484.8484848484849,-288.6002886002886,null,-484.8484848484849,-265.5122655122655,null,-484.8484848484849,-242.42424242424244,null,-484.8484848484849,-219.33621933621936,null,-484.8484848484849,-196.24819624819628,null,-484.8484848484849,-173.16017316017317,null,-484.8484848484849,-150.0721500721501,null,-484.8484848484849,-126.98412698412702,null,-484.8484848484849,-103.89610389610392,null,-484.8484848484849,-80.80808080808085,null,-484.8484848484849,-57.72005772005775,null,-484.8484848484849,-34.63203463203467,null,-484.8484848484849,-11.544011544011584,null,-242.42424242424244,11.544011544011502,null,-242.42424242424244,34.63203463203467,null,-242.42424242424244,57.720057720057675,null,-242.42424242424244,80.80808080808085,null,-242.42424242424244,103.89610389610385,null,-242.42424242424244,126.98412698412702,null,-242.42424242424244,150.07215007215,null,-242.42424242424244,173.16017316017317,null,-242.42424242424244,196.2481962481962,null,-242.42424242424244,219.33621933621936,null,-242.42424242424244,242.42424242424235,null,-242.42424242424244,265.5122655122655,null,-242.42424242424244,288.60028860028854,null,-242.42424242424244,311.6883116883117,null,-242.42424242424244,334.7763347763347,null,-242.42424242424244,357.8643578643579,null,484.8484848484849,380.9523809523809,null,484.8484848484849,404.04040404040404,null,484.8484848484849,427.12842712842706,null,484.8484848484849,450.2164502164502,null,484.8484848484849,473.3044733044732,null,484.8484848484849,496.3924963924964,null,484.8484848484849,519.4805194805194,null,484.8484848484849,565.6565656565656,null,484.8484848484849,588.7445887445888,null,484.8484848484849,611.8326118326117,null,484.8484848484849,658.0086580086579,null,484.8484848484849,681.0966810966811,null,484.8484848484849,704.1847041847041,null,484.8484848484849,727.2727272727273,null],"y":[0,-100,null,0,-100,null,0,-100,null,0,-100,null,0,-100,null,0,-100,null,0,-100,null,0,-100,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-100,-200,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-200,-300,null,-300,-400,null,-300,-400,null,-300,-400,null,-300,-400,null,-300,-400,null,-300,-400,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null,-400,-500,null],"type":"scatter"},{"hoverinfo":"none","line":{"color":"#FF0000","width":0.5},"mode":"lines","x":[],"y":[],"type":"scatter"},{"hoverinfo":"none","line":{"color":"#FFD700","width":2},"mode":"lines","x":[0,363.6363636363636,null,363.6363636363636,630.3030303030303,null,630.3030303030303,684.4919786096257,null,684.4919786096257,484.8484848484849,null,484.8484848484849,542.5685425685425,null,484.8484848484849,634.9206349206349,null],"y":[0,-100,null,-100,-200,null,-200,-300,null,-300,-400,null,-400,-500,null,-400,-500,null],"type":"scatter"},{"hoverinfo":"text","hovertext":["\u003cb\u003ePath:\u003c\u002fb\u003e ()\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 1.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 1.000\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 1.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 6: 0.95; 0: 0.9; 3: 0.75; 1: 0.6; 4: 0.55; 7: 0.4; 2: 0.1; 5: 0.05; 8: 0.05\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eROOT Node: empty description Children nodes: [0], [1], [2], [3], [4], [5], [6], [7], [8]\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is asking for assistance with implementing yaw rotation in a Python ROS program that uses `mavros` for drone\u003cbr\u003econtrol. They have provided code snippets demonstrating the use of `rospy`, `mavros\u002fsetpoint_velocity\u002fcmd_vel`,\u003cbr\u003e`mavros\u002fsetpoint_position\u002flocal`, and `quaternion_from_euler`. The core problem is understanding how to correctly\u003cbr\u003eachieve yaw rotation with this setup.\u003cbr\u003e\u003cbr\u003e1.  **[6] Advanced Software Engineering and Systems Programming:** This candidate is highly relevant because it\u003cbr\u003eexplicitly mentions `tf.transformations` under '3D data processing and computer vision with libraries such as Open3D,\u003cbr\u003eOpenCV (cv::KalmanFilter), and tf.transformations'. The `quaternion_from_euler` function the user is employing is\u003cbr\u003etypically found in or based on `tf.transformations` (or similar mathematical libraries used in ROS). Understanding this\u003cbr\u003elibrary and how to manipulate quaternions for orientation is critical for implementing yaw rotation. This directly\u003cbr\u003eaddresses the 'how to do yaw rotation' aspect by pointing to the relevant programming tools and concepts.\u003cbr\u003e2.  **[0] Mathematical Modeling of Robot Motion and State:** This candidate covers 'mathematical foundations of robot\u003cbr\u003ekinematics and dynamics, such as modeling 3D pose with quaternions and rotation matrices, and using Homogeneous\u003cbr\u003eTransformation'. Since the user is already using `quaternion_from_euler`, a deeper understanding of quaternion\u003cbr\u003emathematics, as described here, would be crucial for correctly interpreting and manipulating orientation for yaw. It\u003cbr\u003eprovides the theoretical underpinning for the practical implementation.\u003cbr\u003e3.  **[3] Gazebo Simulator Documentation and Development:** This candidate is relevant because it discusses 'simulating\u003cbr\u003especific platforms like PX4 Autopilot drones'. `Mavros` is commonly used as an interface to PX4 flight controllers.\u003cbr\u003eWhile the user's problem isn't explicitly simulation, practical examples or guides on how yaw control is implemented for\u003cbr\u003ePX4 drones within a simulated environment (which often mirrors real-world control logic) could provide valuable insights\u003cbr\u003eand code examples for the user's `mavros` setup.\u003cbr\u003e4.  **[1] Comprehensive ROS 2 Development Resources:** This candidate discusses `TF2` coordinate frames and 'ROS\u002fROS2\u003cbr\u003eDebugging, Kinematics, and Control'. Although primarily focused on ROS 2, the underlying principles of kinematic control\u003cbr\u003eand coordinate frame transformations (including orientation via quaternions) are similar to ROS 1. It provides a general\u003cbr\u003eROS context for control, which might offer transferable concepts or debugging strategies for motion control.\u003cbr\u003e5.  **[4] General ROS\u002fROS 2 System Development and Integration Guides:** This candidate offers a broad overview of\u003cbr\u003eROS\u002fROS 2 development, including 'ROS 1 Core Communication and Control Packages' and control systems like `ros_control`.\u003cbr\u003eWhile less specific to `mavros` or quaternions, it provides general context for ROS control architectures which might\u003cbr\u003eindirectly aid in understanding how to better structure the yaw control logic.\u003cbr\u003e6.  **[7] Aggregated ROS Technical Content and General Feeds:** This is an aggregated node that mentions 'tf library'\u003cbr\u003e(relevant to quaternions) and 'Robot Operating System - ROS'. However, its aggregated nature suggests less focused\u003cbr\u003econtent, and other parts, like 'aviation (Airplane Flying Handbook)', are too general for a specific programming\u003cbr\u003eproblem. It offers some relevance but might be harder to extract precise information from.\u003cbr\u003e7.  **[2] Linux System Troubleshooting and Python Development:** This candidate focuses on general Linux\u002fPython\u003cbr\u003etroubleshooting and CAN bus development. It is not directly related to `mavros`, drone control, or quaternion-based\u003cbr\u003eorientation for robotics.\u003cbr\u003e8.  **[5] ROS\u002fNav2 C++ Navigation Stack Implementation:** This candidate is highly specific to the ROS 2 Nav2 navigation\u003cbr\u003estack, which uses C++ and focuses on path planning rather than the fundamental implementation of a single drone's yaw\u003cbr\u003erotation in Python with `mavros`.\u003cbr\u003e9.  **[8] ROS\u002fROS2 Hardware Sensor Integration and Embedded Platforms:** This candidate focuses on integrating hardware\u003cbr\u003esensors (LIDAR, RealSense) and embedded platforms (Jetson). This is irrelevant to the user's specific problem of\u003cbr\u003eimplementing yaw rotation in software.\u003cbr\u003e\u003cbr\u003eBased on the directness of addressing the use of quaternions for yaw rotation, along with the context of drone control\u003cbr\u003ewithin ROS, the ranking is as follows.","\u003cb\u003ePath:\u003c\u002fb\u003e (0,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.847\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.694\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.900\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 3: 0.95; 1: 0.2; 0: 0.05; 2: 0.05\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eCovers the core principles, algorithms, and technologies for robotics and autonomous systems. This includes the\u003cbr\u003emathematical foundations of robot kinematics and dynamics, such as modeling 3D pose with quaternions and rotation\u003cbr\u003ematrices, and using Homogeneous Transformation. It also details advanced robotics algorithms for motion planning (RT-\u003cbr\u003eRRT*), collision avoidance (Velocity Obstacle), and perception. Practical topics include technical analysis of sensors\u003cbr\u003elike LiDAR, Camera, and Radar for autonomous driving (including SAE levels and sensor fusion), and guides on controlling\u003cbr\u003ehardware like DC motors with Arduino and Raspberry Pi using PWM and the I2C protocol. Children nodes: Microcontroller-\u003cbr\u003eBased Motor Control and I2C Communication, Advanced Robotics Algorithms Research, Perception Sensors for Autonomous\u003cbr\u003eSystems, Mathematical Modeling of Robot Motion and State\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is encountering an issue with implementing yaw rotation in a robotics project using `rospy` and `mavros` in\u003cbr\u003ePython. They have provided code snippets demonstrating their attempts to control position and orientation using\u003cbr\u003equaternions (specifically `quaternion_from_euler`). The core problem is understanding how to correctly achieve yaw\u003cbr\u003erotation.\u003cbr\u003e\u003cbr\u003e**[3] Mathematical Principles for Robotic System Modeling** is highly relevant because it directly covers the\u003cbr\u003emathematical principles for representing 3D pose, position, and orientation using quaternions, Euler angles, and\u003cbr\u003erotation matrices. This content is crucial for understanding *what* yaw is in the context of these representations and\u003cbr\u003e*how* to correctly manipulate it. Since the user is already using `quaternion_from_euler`, a deeper understanding of\u003cbr\u003ethese mathematical foundations, including concepts like gimbal lock, is essential for robust and correct implementation\u003cbr\u003eof yaw rotation.\u003cbr\u003e\u003cbr\u003e**[4] Advanced Software Engineering and Systems Programming** is also highly relevant due to its inclusion of 3D data\u003cbr\u003eprocessing and computer vision with libraries such as `tf.transformations`. The `quaternion_from_euler` function the\u003cbr\u003euser is employing is likely from `tf.transformations` or a similar library. This candidate offers practical insights and\u003cbr\u003edocumentation on how to use such libraries for orientation manipulation, providing the concrete 'how-to' from a\u003cbr\u003eprogramming perspective to implement yaw rotation. While other topics in this cluster are not directly relevant, the\u003cbr\u003epresence of `tf.transformations` makes it a strong candidate.\u003cbr\u003e\u003cbr\u003e**[1] Academic Research Papers on Robotics Algorithms** is less relevant. While it pertains to robotics, it focuses on\u003cbr\u003eadvanced research topics like path planning, motion planning, and collision avoidance algorithms. The user's problem is\u003cbr\u003ea fundamental control aspect (implementing yaw rotation) rather than a complex algorithmic challenge or research\u003cbr\u003equestion.\u003cbr\u003e\u003cbr\u003e**[0] DC Motor Control and I2C Communication** is largely irrelevant. This topic deals with low-level hardware control\u003cbr\u003e(DC motors, I2C protocol) using microcontrollers. The user is operating at a much higher level of abstraction,\u003cbr\u003einterfacing with `mavros` in ROS, where motor control is handled by the flight controller and `mavros` API.\u003cbr\u003e\u003cbr\u003e**[2] Perception Sensors for Autonomous Driving** is irrelevant. This candidate focuses on sensor comparisons (LiDAR,\u003cbr\u003eCamera, Radar) and perception systems for autonomous driving, which has no direct bearing on the user's problem of\u003cbr\u003ecommanding yaw rotation for a robot.","\u003cb\u003ePath:\u003c\u002fb\u003e (1,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.707\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.414\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.600\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 10: 0.95; 8: 0.9; 13: 0.8; 7: 0.5; 15: 0.4; 4: 0.2; 0: 0.1; 9: 0.1; 12: 0.1; 1: 0.05; 3: 0.05; 14: 0.05; 19: 0.05; 2:\u003cbr\u003e0.0; 5: 0.0; 6: 0.0; 11: 0.0; 16: 0.0; 17: 0.0; 18: 0.0; 20: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains a comprehensive set of technical resources for developing robotics applications using the Robot\u003cbr\u003eOperating System (ROS), with a primary focus on ROS 2. It covers the full spectrum of development, from foundational\u003cbr\u003econcepts like the ROS launch system, `TF2` coordinate frames, and core architecture, to advanced frameworks such as\u003cbr\u003e`Nav2` for navigation, `MoveIt2` for motion planning, and `ros2_control` for hardware abstraction. The content includes\u003cbr\u003ein-depth tutorials and API documentation for C++ programming with `rclcpp`, managing build systems with `colcon` and\u003cbr\u003e`CMake`, and working with data formats like `rosbag` and `MCAP`. It also provides extensive guides for simulation in\u003cbr\u003e`Gazebo`, computer vision processing (`cv_bridge`, `PointCloud2`), 3D mapping with `OctoMap`, and integration with\u003cbr\u003especific hardware like iRobot platforms, Crazyflie drones, and devices using EtherCAT. Troubleshooting common build and\u003cbr\u003eruntime errors is also a key component. Children nodes: ROS 2 Hardware Integration and Software Architecture, Advanced\u003cbr\u003eROS 2 Software Engineering and Architecture, MATLAB and ROS for Robotics Path Planning, ROS 2 C++ Client Library\u003cbr\u003e(rclcpp) Development, Key ROS Ecosystem GitHub Repositories, MoveIt Motion Planning Framework Guide, ROS\u002fROS 2 Build and\u003cbr\u003eConfiguration Troubleshooting, ROS\u002fROS 2 Robot Simulation and Navigation, Crazyflie Drone Programming and Swarm Control,\u003cbr\u003eROS2 Control Framework Development, ROS\u002fROS2 Debugging, Kinematics, and Control, ROS\u002fROS 2 Bag File Management, iRobot\u003cbr\u003eCreate 3 and TurtleBot4 Development with ROS 2, Core ROS and ROS 2 Documentation and Governance, Foxglove Tutorials for\u003cbr\u003eROS, MCAP, and C++, ROS Transform System (TF\u002fTF2), OctoMap Server for ROS 3D Mapping, Computer Vision and Sensor\u003cbr\u003eProcessing in ROS, ROS 1 and ROS 2 Launch Systems, ROS 2 Navigation Stack (Nav2), Colcon Build System for ROS 2\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user's query describes a common problem in drone control using `rospy` (ROS 1 Python) and MAVROS: performing yaw\u003cbr\u003erotation after takeoff. The provided code snippet shows an attempt to set orientation using `quaternion_from_euler`\u003cbr\u003ewithin a `PoseStamped` message, and also a `TwistStamped` message for velocity control. The core problem is\u003cbr\u003eunderstanding how to correctly command yaw, either through angular velocity or by precisely setting the orientation\u003cbr\u003equaternion.\u003cbr\u003e\u003cbr\u003eI will evaluate each candidate's relevance to this problem:\u003cbr\u003e\u003cbr\u003e*   **[10] Robotics (ROS\u002fROS2), Forward Kinematics, Mobile Robots, rospy Debugging**: This candidate is highly relevant.\u003cbr\u003eIt directly mentions `rospy` (which the user is using), 'passing arguments in `rospy`', and 'control of differential\u003cbr\u003ewheeled robots' and 'rotational dynamics'. Yaw rotation is a rotational control problem, and the principles discussed\u003cbr\u003efor mobile robots would apply. This cluster likely contains critical concepts for controlling angular motion and using\u003cbr\u003e`TwistStamped` (for angular velocity) or `PoseStamped` (for orientation) effectively in a `rospy` context.\u003cbr\u003e*   **[8] Bitcraze Crazyflie Drone Control (cflib, Crazyswarm, ROS\u002fROS2)**: This cluster is also highly relevant as it\u003cbr\u003efocuses on drone control using ROS and Python. Although for Crazyflie drones, the methodologies for commanding yaw\u003cbr\u003erotation via ROS topics (similar to MAVROS) would be highly transferable. Discussions on 'Setting Crazyflie Parameters\u003cbr\u003evia ROS' suggest a focus on control interfaces that would include orientation.\u003cbr\u003e*   **[21] Advanced Software Engineering (Protobuf, Qt, Open3D, Multithreading, tf.transformations)**: This cluster\u003cbr\u003eexplicitly mentions `tf.transformations`, which is the Python library (often used with ROS) that provides\u003cbr\u003e`quaternion_from_euler`. The user's code already uses this function, making this cluster critical for understanding the\u003cbr\u003emathematical basis of quaternions for orientation and how to correctly generate them for a desired yaw angle.\u003cbr\u003e*   **[13] ROS\u002fROS 2 Core Systems (Installation, Documentation, `geometry_msgs`, `ros2_control`, `micro-ROS`)**: This\u003cbr\u003ecandidate is relevant because it includes 'ROS `geometry_msgs` Package Documentation'. The `PoseStamped` and\u003cbr\u003e`TwistStamped` messages that the user is working with belong to `geometry_msgs`. Understanding the structure of these\u003cbr\u003emessages, especially the quaternion fields within `PoseStamped` for orientation, is foundational to solving the problem.\u003cbr\u003e*   **[7] ROS\u002fROS 2 Robot Simulation and Navigation (Gazebo, Webots, Nav2, URDF)**: This cluster has some relevance due\u003cbr\u003eto its focus on robot simulation and navigation, which inherently involves controlling robot orientation. The mention of\u003cbr\u003e'Drone Ecosystem Community Forum (PX4, ROS)' is particularly relevant, as PX4 is often used with MAVROS. While not\u003cbr\u003edirectly about the `rospy` code, it provides a broader context for drone control and related topics.\u003cbr\u003e*   **[15] ROS Transform System (TF\u002ftf2) Theory and Implementation**: This cluster discusses `TF\u002ftf2` for coordinate\u003cbr\u003etransformations and REP 105 (standardized coordinate frames). While the user is setting an orientation rather than\u003cbr\u003etransforming between frames, the underlying concepts of quaternions for orientation and coordinate systems are related.\u003cbr\u003eThe `tf.transformations` module itself is part of the `tf` ecosystem, making this indirectly relevant for theoretical\u003cbr\u003ebackground.\u003cbr\u003e*   **[4] ROS Ecosystem GitHub Repositories (Simulation, Control, Hardware Drivers)**: This cluster is too broad. While\u003cbr\u003eit covers various ROS tools and drivers, it doesn't offer specific guidance on drone yaw control using `rospy` or MAVROS\u003cbr\u003emessages. It's a collection of repositories, not a guide for the specific problem.\u003cbr\u003e*   **[0] Robotics with ROS 2, EtherCAT, MoveIt2, and rtabmap_ros**: This cluster focuses heavily on ROS 2, `MoveIt2`,\u003cbr\u003e`EtherCAT`, and `rtabmap_ros`. These topics are largely unrelated to the user's ROS 1 `rospy` drone control problem.\u003cbr\u003e*   **[12] iRobot Create 3 & TurtleBot4 ROS 2 Development (Humble, Python SDK, Nav2)**: This cluster focuses on specific\u003cbr\u003eiRobot platforms and ROS 2. While it mentions a Python SDK, the context is different from a MAVROS-controlled drone on\u003cbr\u003eROS 1.\u003cbr\u003e*   **[14] Foxglove ROS\u002fROS2 Tutorials (C++, MCAP, Launch Files)**: This cluster focuses on Foxglove, MCAP, ROS 2 C++\u003cbr\u003eservices, and launch files. These are not directly relevant to the user's `rospy` yaw control problem.\u003cbr\u003e*   **[9] ros2_control Framework (Hardware and Controller Interfaces, URDF, Gazebo)**: This cluster is about the\u003cbr\u003e`ros_control`\u002f`ros2_control` framework for robot hardware interfaces. The user's problem is at a higher level of MAVROS\u003cbr\u003ecommand, not implementing a custom hardware interface or controller with this framework.\u003cbr\u003e*   **[1] Advanced ROS 2 Software Engineering (Composition, Executors, Time, colcon-bundle)**: This cluster is entirely\u003cbr\u003eabout ROS 2 architectural concepts and build systems, which is irrelevant to a specific `rospy` drone yaw control\u003cbr\u003eproblem.\u003cbr\u003e*   **[3] ROS 2 C++ Client Library (rclcpp) Development**: This cluster focuses on ROS 2 C++ development, which is not\u003cbr\u003eapplicable to the user's ROS 1 Python (`rospy`) query.\u003cbr\u003e*   **[5] MoveIt Motion Planning Framework (ROS1\u002fROS2) Configuration and Debugging**: This cluster focuses on the MoveIt\u003cbr\u003emotion planning framework, which is for robotic manipulators and not directly relevant to simple drone takeoff and yaw\u003cbr\u003erotation.\u003cbr\u003e*   **[6] ROS\u002fROS2 Troubleshooting and Build System Errors**: The user's problem is a coding logic issue (how to command\u003cbr\u003eyaw), not a build error, compilation failure, or installation issue.\u003cbr\u003e*   **[11] ROS Bag File Management (rosbag\u002frosbag2)**: This cluster is about recording and playing back ROS data, which\u003cbr\u003eis unrelated to actively controlling a drone's yaw.\u003cbr\u003e*   **[16] OctoMap for 3D Probabilistic Mapping (ROS Package, PointCloud2)**: This cluster is about 3D mapping, which is\u003cbr\u003eirrelevant to the user's query about drone yaw rotation.\u003cbr\u003e*   **[17] ROS Computer Vision and Sensor Processing (Cameras, PointCloud2, cv_bridge)**: This cluster focuses on\u003cbr\u003ecomputer vision and sensor processing, which is not relevant to drone yaw control.\u003cbr\u003e*   **[18] ROS\u002fROS 2 Launch System (XML, Python, YAML)**: This cluster is about ROS launch files, which define how nodes\u003cbr\u003eare started. The user's problem is about the Python code within a node, not its launch configuration.\u003cbr\u003e*   **[19] ROS 2 Navigation Stack (Nav2) Configuration and Development**: This cluster focuses on the ROS 2 Navigation\u003cbr\u003eStack. While navigation involves orientation, the user's problem is a lower-level control implementation for a drone,\u003cbr\u003enot configuring a full navigation stack, and it's ROS 2 focused.\u003cbr\u003e*   **[20] ROS2 `colcon` Build Tool and Development Workflows**: This cluster is about the `colcon` build system, which\u003cbr\u003eis unrelated to the user's control problem.\u003cbr\u003e*   **[2] MATLAB Robotics and ROS Integration (Path Planning, rosbagreader)**: This cluster is specific to MATLAB, which\u003cbr\u003ethe user is not using.","\u003cb\u003ePath:\u003c\u002fb\u003e (2,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.052\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.100\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eCovers technical troubleshooting and software development on Linux systems, particularly Debian\u002fUbuntu. This includes\u003cbr\u003eresolving Python errors like `ImportError` and `ModuleNotFoundError` in Django applications, fixing `pip` and\u003cbr\u003e`distutils` issues using `apt` and virtual environments, and developing for specific hardware like CAN bus with PEAK-\u003cbr\u003eSystem APIs and libraries such as `python-can`. It also addresses lower-level topics like the `dpkg` package management\u003cbr\u003esystem, the package building process, and debugging C++ segmentation faults in hardware communication. Children nodes:\u003cbr\u003eDebian\u002fUbuntu Package Management and Building, Debugging Python Import Errors in Django, Resolving Python Pip and\u003cbr\u003ePackage Errors on Debian, CAN Bus Development with PEAK-System and Python\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.777\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.554\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.750\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 7: 0.95; 4: 0.85; 5: 0.6; 6: 0.4; 2: 0.15; 3: 0.05; 0: 0.0; 1: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains comprehensive technical documentation, C++ code examples, tutorials, and troubleshooting guides for developing\u003cbr\u003eand simulating robotic systems in the Gazebo simulator, including Ignition Gazebo. This cluster covers core aspects of\u003cbr\u003eGazebo development such as creating and configuring models with SDF and URDF, implementing custom C++ plugins like\u003cbr\u003e`DetachableJoint`, `ros_control`, and `MulticopterVelocityControl`, and integrating various sensors like IMUs, LIDAR,\u003cbr\u003eand cameras. It provides in-depth information on using Gazebo with ROS\u002fROS 2, addressing common GitHub issues, and\u003cbr\u003esimulating specific platforms like PX4 Autopilot drones. Key entities include Gazebo, SDF, URDF, ROS, C++ plugins,\u003cbr\u003esensor simulation, and controller integration. Children nodes: Gazebo DetachableJoint System Plugin, Gazebo Camera\u003cbr\u003eSensor Integration, Robotics Software GitHub Issues, Gazebo Sensor Implementation and Troubleshooting, Robot Simulation\u003cbr\u003ein Gazebo with ROS, Ignition Gazebo Examples and Plugins, Gazebo C++ Plugin Development, PX4 Drone Simulation and\u003cbr\u003eDevelopment\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is attempting to control a drone's yaw rotation using `mavros` in Python. They have successfully implemented\u003cbr\u003earming and takeoff, and their code snippet shows an attempt to set orientation using `quaternion_from_euler` and\u003cbr\u003epublishing to `\u002fmavros\u002fsetpoint_position\u002flocal`. The core problem is understanding how to correctly command yaw rotation\u003cbr\u003ein this setup.\u003cbr\u003e\u003cbr\u003eCandidate [7] (PX4 Autopilot drone ecosystem with Gazebo SITL and VSCode) is highly relevant because `mavros` is a\u003cbr\u003ecommon ROS interface for PX4 autopilots. The user's tasks (arming, takeoff, yaw rotation) are fundamental PX4\u003cbr\u003eoperations, and this cluster provides documentation and guides for PX4, Gazebo SITL, and ROS integration, which would\u003cbr\u003ealmost certainly cover how to command orientation.\u003cbr\u003e\u003cbr\u003eCandidate [4] (Simulating robots in Gazebo with ROS and ROS 2) is also highly relevant. The drone is a robot being\u003cbr\u003esimulated in Gazebo and controlled via ROS (`mavros`). This cluster covers robot modeling, controller integration\u003cbr\u003e(`ros_control`, `ros2_control`), and troubleshooting common simulation issues, which are all critical for understanding\u003cbr\u003ehow orientation commands are processed and executed in a simulated ROS\u002fGazebo environment.\u003cbr\u003e\u003cbr\u003eCandidate [5] (Examples, tutorials, and troubleshooting for Ignition Gazebo (Gazebo Sim)) is moderately relevant. While\u003cbr\u003ethe user's code implies classic Gazebo, the principles of ROS\u002fGazebo integration and handling advanced simulation\u003cbr\u003efeatures, including physics and plugins that influence robot movement and orientation, can be similar enough to offer\u003cbr\u003etransferable insights for troubleshooting or understanding the underlying simulation behavior.\u003cbr\u003e\u003cbr\u003eCandidate [6] (C++ source code for controlling entities in Gazebo) has low to moderate relevance. It provides C++ source\u003cbr\u003ecode for low-level Gazebo multicopter control systems (`MulticopterVelocityControl`). While it explains how yaw control\u003cbr\u003emight be implemented at the Gazebo level, it doesn't directly address the Python\u002f`mavros` interface, making it less\u003cbr\u003edirectly useful for the user's specific problem but potentially valuable for a deeper understanding.\u003cbr\u003e\u003cbr\u003eCandidate [8] (Advanced software engineering and systems programming) has low relevance. It mentions\u003cbr\u003e`tf.transformations` and quaternions, which the user is already employing. However, the cluster's broad focus on general\u003cbr\u003esoftware engineering topics, rather than specific drone control or `mavros` integration, means it's unlikely to provide\u003cbr\u003ethe direct solution to the user's yaw control problem.\u003cbr\u003e\u003cbr\u003eCandidate [2] (GitHub issues for robotics and simulation) has very low relevance. It contains bug reports and feature\u003cbr\u003erequests. While a specific bug might theoretically relate to `mavros` yaw control, it's not a primary resource for\u003cbr\u003elearning 'how-to' implement functionality.\u003cbr\u003e\u003cbr\u003eCandidates [0] (DetachableJoint system plugin for the Gazebo simulator), [1] (Various camera sensors in Gazebo), and [3]\u003cbr\u003e(Implementation, configuration, and troubleshooting of various sensors) are largely irrelevant. Candidate [0] is about a\u003cbr\u003every specific joint plugin. Candidate [1] is about camera sensors, which are unrelated to drone control. Candidate [3]\u003cbr\u003efocuses on sensor data, not on commanding robot movement or orientation, which is the user's core query.","\u003cb\u003ePath:\u003c\u002fb\u003e (4,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.684\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.367\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.550\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eConcerns technical documentation, API references, and tutorials for developing with the Robot Operating System (ROS and\u003cbr\u003eROS 2) and its associated ecosystem. This includes core programming with the ROS 2 Client Library (RCL) and Lifecycle\u003cbr\u003eNodes; motion planning with MoveIt's `MoveGroupInterface`; control systems like `ros_control` and `ros2_control`; and\u003cbr\u003evisualization with RViz plugins. It also covers simulation with Gazebo and Ignition, communication protocols like\u003cbr\u003e`rosbridge_suite` and `rosserial`, and fundamental configuration management topics such as ROS environment variables and\u003cbr\u003eparameters using YAML and `rosparam`. Children nodes: ROS 2 Client Library and Lifecycle Node Documentation, RViz C++\u003cbr\u003ePlugin and Library Development, MoveIt MoveGroupInterface C++ API, General ROS\u002fROS 2 System Development and Integration\u003cbr\u003eGuides, Ignition Gazebo C++ API Documentation, ROS Parameter Management with YAML, ROS 1 Core Communication and Control\u003cbr\u003ePackages, ROS 2 Controller Documentation (ros2_control, Nav2), ROS and Gazebo Simulation Integration, ROS Environment\u003cbr\u003eVariable Management\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (5,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.098\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eCovers the C++ implementation and architecture of robotics components for the ROS\u002fROS2 navigation stack (Nav2). This\u003cbr\u003eincludes details on the `BehaviorTree.CPP` library and its integration via `BehaviorTree.ROS2`, as well as specific Nav2\u003cbr\u003eBehavior Tree nodes like `opennav_coverage_bt` and `PlannerSelector`. It also delves into the source code of core Nav2\u003cbr\u003efunctionalities, particularly `costmap_2d` layers (`RangeSensorLayer`) and planners (`DWAPlannerROS`). Children nodes:\u003cbr\u003eROS\u002fNav2 C++ Navigation Stack Implementation, BehaviorTree.CPP Library and ROS Ecosystem, Nav2-Specific C++ Behavior\u003cbr\u003eTree Nodes\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.803\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.605\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 2: 1.0; 0: 0.0; 1: 0.0; 3: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains technical guides, API documentation, and implementation details for advanced software engineering\u003cbr\u003eand systems programming. It covers diverse topics including data serialization with Protocol Buffers (Protobuf) and\u003cbr\u003eNanopb, GUI layout management in the Qt framework using classes like QGridLayout and QLayout, 3D data processing and\u003cbr\u003ecomputer vision with libraries such as Open3D, OpenCV (cv::KalmanFilter), and tf.transformations, and\u003cbr\u003econcurrency\u002fmultithreading techniques like pthreads, spinlocks, and Node.js worker_threads. Children nodes: Protocol\u003cbr\u003eBuffers and Nanopb Serialization, Qt GUI Layout Management, 3D Data Processing and Computer Vision Libraries,\u003cbr\u003eConcurrency and Multithreading Techniques\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user's query is about implementing yaw rotation for a drone using a Python script with `rospy` and `mavros`. The\u003cbr\u003eprovided code snippet uses `quaternion_from_euler` for orientation. The core problem revolves around understanding and\u003cbr\u003ecorrectly applying 3D geometric transformations, specifically rotations using quaternions and Euler angles.\u003cbr\u003e\u003cbr\u003e- **Candidate [0] Protocol Buffers and Nanopb Serialization:** This candidate focuses on data serialization formats and\u003cbr\u003elibraries. This is entirely unrelated to the user's problem of drone control and yaw rotation, which deals with\u003cbr\u003egeometric transformations.\u003cbr\u003e\u003cbr\u003e- **Candidate [1] Qt GUI Layout Management:** This candidate is about graphical user interface layout management within\u003cbr\u003ethe Qt framework. This has no relevance to the user's query regarding drone control, ROS, or geometric transformations.\u003cbr\u003e\u003cbr\u003e- **Candidate [2] 3D Data Processing and Computer Vision Libraries:** This candidate is highly relevant. It explicitly\u003cbr\u003ecovers \"3D geometric transformations (rotation, scaling, translation)\" and \"conversion between representations like\u003cbr\u003equaternions and Euler angles,\" and mentions the `tf.transformations` library. The user's code directly uses\u003cbr\u003e`quaternion_from_euler`, which is a function commonly found in `tf.transformations` (or similar libraries). This\u003cbr\u003edocument provides the critical concepts and theories needed to solve the yaw rotation problem.\u003cbr\u003e\u003cbr\u003e- **Candidate [3] Concurrency and Multithreading Techniques:** This candidate discusses concurrency and multithreading\u003cbr\u003ein various programming environments. The user's query is a control problem involving geometric orientation, not a\u003cbr\u003emultithreading issue. Therefore, this is irrelevant.\u003cbr\u003e\u003cbr\u003e- **Candidate [4] Advanced Software Engineering and Systems Programming:** This is a parent cluster that aggregates\u003cbr\u003eseveral topics, including \"3D data processing and computer vision with libraries such as Open3D, OpenCV\u003cbr\u003e(cv::KalmanFilter), and tf.transformations.\" Since it encompasses the highly relevant content of Candidate [2], it is\u003cbr\u003ealso relevant to the query. While broader than Candidate [2], it does contain the necessary information to address the\u003cbr\u003euser's problem, making it a valuable source.","\u003cb\u003ePath:\u003c\u002fb\u003e (7,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.614\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.228\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.400\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains highly specialized and technical information across various professional and engineering domains. This includes\u003cbr\u003edocumentation for industrial automation (SICK AG LiDAR, ABB Ability\u2122), software repositories for Linux and Python\u003cbr\u003e(Fedora RPMs, PyPI, msgpack-numpy), technical support for robotics (Robot Operating System - ROS, catkin_make, tf\u003cbr\u003elibrary), and specific procedural documents for automotive engineering (GKN patent DE10008182), enterprise software (SAP\u003cbr\u003eCommerce Cloud), and aviation (Airplane Flying Handbook). It also covers business information for entities like Gazebo\u003cbr\u003eGardens Publishing. Children nodes: Industrial and IT Automation Technology Documentation, Linux and Python Software\u003cbr\u003eRepositories, Gazebo Gardens Publishing Business Information, Aggregated ROS Technical Content and General Feeds,\u003cbr\u003eSpecialized Technical and Procedural Documents\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (8,)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.098\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides technical documentation, guides, and troubleshooting for developing robotics applications using the Robot\u003cbr\u003eOperating System (ROS\u002fROS2). This topic covers the integration of various hardware sensors like Intel RealSense cameras\u003cbr\u003eand LiDAR (Ouster, LD-series) with embedded platforms such as NVIDIA Jetson. It includes details on specific software\u003cbr\u003estacks and platforms like NVIDIA Isaac, Intel Edge Insights for AMR, and build systems including Docker and\u003cbr\u003eOpenEmbedded\u002fYocto, addressing common issues with SDKs, drivers (`realsense-ros`), and dependencies (`rosdep`). Children\u003cbr\u003enodes: NVIDIA Jetson Development and Troubleshooting, OpenEmbedded ROS Recipes Documentation, Intel RealSense ROS\u002fROS2\u003cbr\u003eIntegration, LiDAR Sensor Integration with ROS\u002fSDKs, NVIDIA Isaac Robotics Platform for AMRs, Intel Edge Insights AMR\u003cbr\u003eBuild Failure\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.120\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic contains technical guides, tutorials, and theoretical explanations for controlling hardware, particularly DC\u003cbr\u003emotors, and implementing the I2C communication protocol. It covers practical applications using microcontrollers like\u003cbr\u003eArduino and Raspberry Pi with motor drivers (L298N, L293D, TB6612) and control methods like Pulse Width Modulation\u003cbr\u003e(PWM). The cluster also includes fundamental principles of DC motor operation (torque, speed, back EMF), power\u003cbr\u003econversion in motor controllers, and detailed information on using the I2C protocol and Arduino Wire library to\u003cbr\u003einterface with sensors (ADXL345, MPU6050) and peripherals. Resources are provided from various educational platforms\u003cbr\u003eincluding 'How To Mechatronics', 'Tech Explorations', and 'Learn Robotics'. Children nodes: I2C Communication with\u003cbr\u003eArduino and Sensors, Power Conversion in Motor Controllers, SparkFun DC\u002fDC Buck Converter Breakout, DC Motor Operating\u003cbr\u003ePrinciples and Equations, Motor Control with Node-RED, Arduino DC Motor Control with L298 H-Bridge, Tech Explorations\u003cbr\u003eArduino DC Motor Control, Learn Robotics Motor Controller Interfacing, Arduino I2C Protocol and Wire Library\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.020\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.020\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.200\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains academic research papers on algorithms and systems in robotics. This cluster covers key topics such as path\u003cbr\u003eplanning, motion planning, and collision avoidance, featuring detailed descriptions of algorithms like Velocity\u003cbr\u003ePotential Field (VPF), RT-RRT*, SIPP-IP, and the Velocity Obstacle (VO) method. It also includes research on robot\u003cbr\u003eperception and interaction, such as systems for dynamic gesture recognition using deep learning (MCCNN) and robotic\u003cbr\u003egrasping using Sim-to-Real transfer with generative models (ALDM-Grasping). Other topics include robot localization (KVO\u003cbr\u003ewith Kalman Filters) and architectures for multi-robot navigation. These papers typically present novel methods, their\u003cbr\u003etheoretical underpinnings, and validation through both simulation and experiments on physical robots. Children nodes:\u003cbr\u003eKVO: Kalman-filtering Vision and Odometry for Robot Localization, Enhanced VPF Algorithm for Robotic Manipulator\u003cbr\u003eCollision Avoidance, Safe Interval Path Planning with Interval Projection (SIPP-IP) Algorithm, Improved VPF Algorithm\u003cbr\u003ewith Virtual Target Point for Robot Manipulators, Velocity Obstacle (VO) Method for Robot Motion Planning, RT-RRT*: A\u003cbr\u003eReal-Time Path Planning Algorithm, Deep Learning for Real-Time Dynamic Gesture Recognition in HRI, Architectures for\u003cbr\u003eMulti-Robot Collision-Free Navigation, ALDM-Grasping: Sim-to-Real Transfer for Robotic Grasping\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.120\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains detailed technical comparisons and analyses of perception sensors, primarily LiDAR, Camera, and Radar, for\u003cbr\u003eautonomous driving and ADAS. This includes discussions on their operational principles, advantages, disadvantages, and\u003cbr\u003ethe role of multi-sensor fusion. Key related concepts covered are the SAE J3016 levels of driving automation,\u003cbr\u003ecybersecurity regulations like WP.29, Software-Defined Vehicles (SDV), and specific companies in the space such as\u003cbr\u003eAUTOCRYPT and Outsight. The content also touches on deep learning applications with Keras and avionics standards like\u003cbr\u003eARINC from author Madhavan Vivekanandan. Children nodes: AUTOCRYPT Corporate & Technical Content, Madhavan\u003cbr\u003eVivekanandan's LinkedIn Technical Articles, Perception Sensor Comparison and Privacy Implications (Outsight), LiDAR vs.\u003cbr\u003eCamera Research Paper Analysis\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.834\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.718\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 3: 0.95; 4: 0.85; 1: 0.65; 2: 0.55; 0: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eCovers the mathematical principles for modeling the state and motion of robotic systems, including the representation of\u003cbr\u003e3D pose, position, and orientation using quaternions, Euler angles, and rotation matrices. This topic delves into the\u003cbr\u003ecore concepts of robot kinematics and dynamics, detailing the use of Homogeneous Transformation matrices, the\u003cbr\u003eGeneralized Jacobian Matrix, and the recursive Newton-Euler formulation to analyze manipulator movement and forces. It\u003cbr\u003ealso addresses practical issues like gimbal lock and specific applications such as impedance control for free-floating\u003cbr\u003espace manipulators. Children nodes: Impedance Control for Space Manipulator, Mathematical Foundations of Robot\u003cbr\u003eKinematics, Kinematic and Dynamic Modeling of Robotic Systems, Euler Angles and 3D Orientation, Pose Representation\u003cbr\u003eusing Quaternions\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is attempting to perform yaw rotation on a drone using `mavros` and `rospy`. Their provided code snippet uses\u003cbr\u003e`quaternion_from_euler` to set the orientation in a `PoseStamped` message. The core problem is understanding how to\u003cbr\u003ecorrectly implement and control yaw using this approach. I need to find documents that explain Euler angles,\u003cbr\u003equaternions, their conversion, and their application in robotics for orientation control.\u003cbr\u003e\u003cbr\u003e- **[5] API documentation and guides for computer vision and 3D data processing libraries:** This is highly relevant\u003cbr\u003ebecause it specifically mentions the `tf.transformations` library, which contains `quaternion_from_euler` (the exact\u003cbr\u003efunction the user is struggling with). It also covers 'conversion between representations like quaternions and Euler\u003cbr\u003eangles,' which is central to the user's problem. This document provides practical guidance on the tools the user is\u003cbr\u003eemploying.\u003cbr\u003e\u003cbr\u003e- **[3] Euler angles for describing 3D orientation:** This document directly addresses Euler angles, including Tait-\u003cbr\u003eBryan angles (yaw, pitch, roll), their mathematical representation, and their connection to quaternions. Understanding\u003cbr\u003ethese concepts is crucial for the user to properly interpret and manipulate the yaw component when using\u003cbr\u003e`quaternion_from_euler`. It provides the theoretical foundation for the `q = quaternion_from_euler(0.0,0.0,3.0)` line.\u003cbr\u003e\u003cbr\u003e- **[4] Representation of pose in free space:** This topic describes pose as a combination of a point for position and a\u003cbr\u003equaternion for orientation. This is directly relevant to the user's `position` method, which populates a `PoseStamped`\u003cbr\u003emessage with position and a quaternion-based orientation. It helps the user understand the data structure they are\u003cbr\u003eworking with.\u003cbr\u003e\u003cbr\u003e- **[1] Mathematical treatment of robot kinematics:** This document covers the mathematical derivation of robot\u003cbr\u003eposition, orientation, and velocity, including rotation matrices and rigid-body motion. While foundational to\u003cbr\u003eunderstanding orientation, it is more general and theoretical than the specific problem of implementing yaw control\u003cbr\u003eusing Euler angles and quaternions in a `mavros` context. It provides background but not direct solutions for the user's\u003cbr\u003especific code.\u003cbr\u003e\u003cbr\u003e- **[2] Kinematic and dynamic modeling of robotic systems:** This topic also covers mathematical formalisms for\u003cbr\u003ekinematics and dynamics using transformation matrices. Like [1], it offers foundational knowledge but is too broad and\u003cbr\u003etheoretical to directly help with the specific `yaw rotation` problem using `quaternion_from_euler` in the user's code.\u003cbr\u003e\u003cbr\u003e- **[0] Impedance Control Using Selected Compliant Prismatic Joint in a Free-Floating Space Manipulator:** This document\u003cbr\u003eis completely irrelevant. It concerns advanced control theory for space manipulators and has no relation to basic drone\u003cbr\u003eyaw control, `mavros`, `rospy`, or Euler\u002fquaternion orientation.","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.500\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.126\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eLearn about the `DetachableJoint` system plugin for the Gazebo simulator, covering its C++ source code, implementation\u003cbr\u003eusing the Entity-Component-System (ECS) architecture, and user guides. This topic details how to configure the system\u003cbr\u003evia SDF parameters like `\u003cparent_link\u003e` and `\u003cchild_model\u003e`, and how to dynamically attach and detach models during\u003cbr\u003esimulation by publishing to Gazebo Transport topics. It also explains critical constraints, such as maintaining a\u003cbr\u003ekinematic tree structure and setting the `\u003cself_collide\u003e` property. While the primary focus is on `DetachableJoint`,\u003cbr\u003erelated information on general joint control in Gazebo (e.g., using `JointController` or `JointTrajectoryController`) is\u003cbr\u003ealso available. Children nodes: DetachableJoint Gazebo Plugin Source Code, DetachableJoint System User Guide,\u003cbr\u003eDetachableJoint System C++ Implementation Details, DetachableJoint System Technical Guide and API, General Guide to\u003cbr\u003eGazebo Joint Control\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.500\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.125\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides technical documentation, guides, and code examples for using various camera sensors like the Depth Camera,\u003cbr\u003eSegmentation Camera, and the `GazeboRosCamera` plugin within the Gazebo simulation environment. This includes API\u003cbr\u003ereferences for programmatic control in C++ via Gazebo Rendering, configuration using XML\u002fSDF, integration with ROS for\u003cbr\u003epublishing `sensor_msgs::Image`, and processing specialized data topics like `labels_map` for computer vision tasks with\u003cbr\u003esystems like `gz-sim-label-system`. Children nodes: Programmatic Depth Camera Usage with Gazebo Rendering,\u003cbr\u003eGazeboRosCamera Plugin Documentation, Gazebo Segmentation Camera Workflow\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.570\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.264\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.150\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains information about software development issues, primarily bug reports and feature requests, hosted\u003cbr\u003eon the GitHub platform for projects within the robotics and simulation domain. It covers the complete lifecycle of\u003cbr\u003especific issues from repositories like `gazebosim`, `ros-controls`, `OctoMap`, and `vscode-ros`. Topics include\u003cbr\u003edebugging rendering problems in Gazebo with URDF\u002fCOLLADA files, `sdformat` conversion errors, `ros2_control`\u003cbr\u003ecompatibility with ROS 2 Galactic, Doxygen-related build failures in `gz-sim` (Ignition Gazebo), GUI plugin crashes, and\u003cbr\u003eenvironment sourcing failures in the VSCode ROS extension for ROS 2 Humble. Each entry details the technical discussion,\u003cbr\u003etroubleshooting process, and resolution documented within a specific GitHub Issue (e.g., #21, #513, #1409, #550, #1272).\u003cbr\u003eChildren nodes: GitHub Feature Request: Auto-listing Doxygen Tutorials, GitHub Bug Report: sdformat URDF to SDF\u003cbr\u003eConversion Failure, Gazebo Rendering Bug with URDF\u002fCOLLADA Material Colors, GitHub Issue: OctoMap Pointcloud Parameter\u003cbr\u003eTroubleshooting, GitHub Bug: Ignition Gazebo Doxygen Build Failure and Segfault, GitHub Bug: Gazebo 'Nav Sat Map' GUI\u003cbr\u003ePlugin Crash, GitHub Bug: Invisible URDF Model in Gazebo with ROS2, GitHub Bug: ros2_control and Gazebo Compatibility in\u003cbr\u003eROS 2 Galactic, GitHub Bug: ros2_control ResourceManager Hang, GitHub Bug: VSCode ROS Extension Fails to Source ROS 2\u003cbr\u003eHumble\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.523\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.172\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster provides comprehensive technical information about the implementation, configuration, and troubleshooting\u003cbr\u003eof various sensors used in robotics, with a strong focus on the Gazebo simulation environment and ROS. It covers\u003cbr\u003especific sensor types such as IMU (e.g., MPU6050, `gazebo::sensors::ImuSensor`), Force\u002fTorque sensors, and LIDAR\u003cbr\u003e(`LaserScan` message). Key topics include detailed C++ API documentation, sensor modeling using SDF (Simulation\u003cbr\u003eDescription Format), configuration of noise models, tutorials on usage, and practical troubleshooting guides for common\u003cbr\u003eproblems. It also extends to advanced applications like sensor fusion using an Extended Kalman Filter (EKF) for mobile\u003cbr\u003erobot localization. Children nodes: ROS LaserScan Message Definition, SDFormat Sensor Configuration and Noise Modeling,\u003cbr\u003eMPU6050 IMU C++ Driver and API, Gazebo ImuSensor Class C++ API, Troubleshooting IMU Detachment in Gazebo,\u003cbr\u003eTroubleshooting Gazebo Force\u002fTorque Sensors, Gazebo Force\u002fTorque Sensor Modeling and Usage, Mobile Robot Localization\u003cbr\u003eResearch Paper (arXiv:2403.13452v1), Gazebo Sensor and ImuSensor C++ API Documentation\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.892\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.909\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.850\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 5: 0.9; 10: 0.3; 0: 0.05; 1: 0.05; 2: 0.05; 3: 0.05; 4: 0.05; 6: 0.05; 7: 0.05; 8: 0.05; 9: 0.05; 11: 0.05; 12: 0.05;\u003cbr\u003e13: 0.05; 14: 0.05; 15: 0.05; 16: 0.05; 17: 0.05; 18: 0.05; 19: 0.05; 20: 0.05\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains comprehensive technical guides, tutorials, and troubleshooting discussions about simulating robots in Gazebo\u003cbr\u003ewith ROS and ROS 2. This cluster focuses on robot modeling (URDF, SDF, XACRO), controller integration (`ros_control`,\u003cbr\u003e`ros2_control`, `gazebo_ros_control`), and package configuration (`package.xml`). Key topics include defining hardware\u003cbr\u003einterfaces with `\u003ctransmission\u003e` and `\u003chardwareInterface\u003e` tags, using the `\u003cgazebo\u003e` tag for simulation-specific\u003cbr\u003eproperties, and debugging common issues such as model spawning failures (`spawn_model`, `SpawnEntity`), plugin loading\u003cbr\u003eerrors, and unstable physics. It also covers the configuration of specific components like quadcopters and depth\u003cbr\u003ecameras, and addresses advanced topics like PID tuning and velocity control. Children nodes: ROS catkin package.xml\u003cbr\u003eManifest Guide, Black Coffee Robotics Guides and Projects, Fix for ROS Indigo hardware interface error, Advanced\u003cbr\u003eros2_control Configuration in Gazebo, ROS ros_control Framework Discussion (2014), Gazebo Quadcopter Simulation Guide,\u003cbr\u003eURDF \u003ctransmission\u003e Element Documentation, Gazebo Robot Manipulator Configuration Tutorial, Gazebo Tricycle Drive Plugin\u003cbr\u003eTroubleshooting, Troubleshooting Gazebo Plugin Loading, Controlling Model Velocity in Gazebo, Using Gazebo Extension Tag\u003cbr\u003ein URDF, Troubleshooting 3D Models in ROS\u002fGazebo, Gazebo Tag for SDFormat Conversion, Troubleshooting Prismatic Joint in\u003cbr\u003eGazebo, Spawning Models in Gazebo with ROS2, Fix for spawn_model Initial Joint Position Failure, Aggregated Gazebo\u002fROS\u003cbr\u003eQ&A from rssing.com, ROS2 Developer Q&A, ROS 2 Package Management Q&A, Gazebo Depth Camera Simulation Tutorial\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user's query is focused on achieving yaw rotation for what appears to be a drone or quadcopter, as indicated by\u003cbr\u003e'Simple takeoff then do yaw rotation'. The provided code snippet shows an attempt to set orientation using\u003cbr\u003e`quaternion_from_euler` and publishing to `\u002fmavros\u002fsetpoint_position\u002flocal` via a `PoseStamped` message. The core\u003cbr\u003eproblem is understanding and correctly implementing yaw rotation using these tools.\u003cbr\u003e\u003cbr\u003e- **[21] API documentation for computer vision and 3D data processing (Open3D, `tf.transformations`, OpenCV):** This\u003cbr\u003ecandidate is highly relevant because the user explicitly uses `quaternion_from_euler`, which is part of the\u003cbr\u003e`tf.transformations` library mentioned in this cluster. Understanding the documentation and guides for this library is\u003cbr\u003ecrucial for correctly applying yaw rotation and resolving any issues with the current implementation. It directly\u003cbr\u003eaddresses the mathematical and programmatic aspects of orientation control.\u003cbr\u003e\u003cbr\u003e- **[5] Quadcopter simulations in Gazebo:** This candidate is also highly relevant due to the context of 'takeoff' and\u003cbr\u003e'yaw rotation', strongly suggesting drone\u002fquadcopter control. `Mavros`, which the user's code interacts with, is\u003cbr\u003ecommonly used for drone control, often with firmwares like `PX4` (referenced in this candidate). This cluster is likely\u003cbr\u003eto contain practical examples, configurations, or discussions on how to implement yaw control for quadcopters,\u003cbr\u003epotentially using `PoseStamped` messages or similar mechanisms that align with the user's setup.\u003cbr\u003e\u003cbr\u003e- **[10] Controlling model velocity in the Gazebo physics simulator:** While the user uses `setpoint_velocity`, the\u003cbr\u003eprimary challenge is yaw *rotation* (orientation), which is handled by `PoseStamped` in their `position` function. This\u003cbr\u003ecandidate focuses on general linear and angular velocity control of joints\u002flinks, which is less specific to the user's\u003cbr\u003eorientation control problem and drone context than candidate [5]. It's tangentially relevant but not critical.\u003cbr\u003e\u003cbr\u003e- All other candidates ([0], [1], [2], [3], [4], [6], [7], [8], [9], [11], [12], [13], [14], [15], [16], [17], [18],\u003cbr\u003e[19], [20]) are largely irrelevant. They focus on ROS 2 (while the user is on ROS 1), `ros_control` (which is not\u003cbr\u003edirectly implied by the `mavros` and `setpoint_position` usage for a drone), URDF configuration, Gazebo spawning\u002fplugin\u003cbr\u003eissues, `catkin` `package.xml`, or sensor integration, none of which directly address the problem of implementing yaw\u003cbr\u003erotation in the user's provided code context.","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 5)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.777\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.679\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.600\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 4: 0.1; 0: 0.05; 1: 0.05; 2: 0.05; 3: 0.05; 5: 0.05; 6: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic provides comprehensive examples, tutorials, and troubleshooting guides for using and extending the Ignition\u003cbr\u003eGazebo (Gazebo Sim) simulator. It includes complete SDF\u002fURDF configurations and C++ source code for various plugins and\u003cbr\u003emodels, such as the `ApplyJointForce` system, a `SuctionGripperPlugin` using a `DetachableJoint`, physics plugins for\u003cbr\u003eAUVs (Hydrodynamics, Buoyancy), and a `double_pendulum_with_base` model. Additionally, it covers ROS\u002fROS2 integration,\u003cbr\u003eaddressing common plugin loading errors (e.g., for `DiffDrive`), and demonstrates advanced features like GPS simulation\u003cbr\u003eusing spherical coordinates and `navsat` sensors. Children nodes: Applying Force to Joints in Ignition Gazebo, AUV\u003cbr\u003eSimulation with Physics Plugins, Double Pendulum SDF Model Example, Fixing Gazebo Plugin Loading Errors in ROS2,\u003cbr\u003eIgnition Gazebo and ROS Integration Support, GPS Simulation with Spherical Coordinates, Suction Gripper Plugin C++\u003cbr\u003eSource Code\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user's query describes a problem with implementing yaw rotation for a drone using a ROS\u002fMavros controller. The\u003cbr\u003eprovided Python code snippets show that the user is attempting to set the drone's position and orientation using\u003cbr\u003e`PoseStamped` and converting Euler angles to quaternions with `quaternion_from_euler`. The core issue is understanding\u003cbr\u003ehow to correctly manipulate the yaw component via this conversion.\u003cbr\u003e\u003cbr\u003e- **[0] gz::sim::systems::ApplyJointForce tutorial:** This document focuses on applying joint forces in Ignition Gazebo.\u003cbr\u003eWhile it involves control in a simulation environment, it is highly specific to joint mechanisms and does not address\u003cbr\u003edrone flight control, quaternion transformations, or yaw rotation for a vehicle.\u003cbr\u003e\u003cbr\u003e- **[1] Simulating AUV dynamics in Ignition Gazebo:** This candidate is about simulating Autonomous Underwater Vehicles\u003cbr\u003e(AUVs) and their specific physics. It is unrelated to aerial drone yaw rotation or the general principles of orientation\u003cbr\u003econtrol using quaternions.\u003cbr\u003e\u003cbr\u003e- **[2] double_pendulum_with_base SDF source code:** This document provides SDF code for a double pendulum model in\u003cbr\u003eIgnition Gazebo, demonstrating robot modeling and pose publishing. It is about robot structure and simulation setup, not\u003cbr\u003eabout implementing control logic for yaw rotation using quaternions.\u003cbr\u003e\u003cbr\u003e- **[3] Troubleshooting Gazebo Sim plugin loading errors in ROS2:** This candidate addresses common plugin loading\u003cbr\u003eerrors in Gazebo Sim for ROS2. This is a troubleshooting guide for simulator configuration, not relevant to the user's\u003cbr\u003eprogramming problem of implementing yaw control.\u003cbr\u003e\u003cbr\u003e- **[4] Integrating Ignition Gazebo with ROS (ROS 1\u002fROS 2):** This discusses the general integration of Ignition Gazebo\u003cbr\u003ewith ROS. While the user might be using ROS and Gazebo, this topic is too broad and does not provide specific guidance\u003cbr\u003eon yaw control or quaternion manipulation, which is the user's direct problem.\u003cbr\u003e\u003cbr\u003e- **[5] Spherical coordinates in Ignition Gazebo for GPS simulations:** This document focuses on GPS-based simulations\u003cbr\u003eand spherical coordinates in Ignition Gazebo. It is related to navigation but not to the low-level attitude\u002fyaw control\u003cbr\u003eusing quaternions that the user is trying to implement.\u003cbr\u003e\u003cbr\u003e- **[6] C++ source code for an Ignition Gazebo SuctionGripperPlugin:** This candidate provides source code for a suction\u003cbr\u003egripper plugin. It is completely unrelated to drone flight control, yaw, or quaternion mathematics.\u003cbr\u003e\u003cbr\u003e- **[7] Computer vision and 3D data processing libraries (Open3D, tf.transformations, OpenCV KalmanFilter):** This is\u003cbr\u003ethe most relevant candidate. It explicitly mentions the `tf.transformations` library, which is highly likely the source\u003cbr\u003eof `quaternion_from_euler` used in the user's code. More importantly, it covers \"3D geometric transformations (rotation,\u003cbr\u003escaling, translation)\" and \"conversion between representations like quaternions and Euler angles.\" Understanding these\u003cbr\u003econcepts is fundamental to solving the user's problem of achieving yaw rotation by manipulating the Euler angle input to\u003cbr\u003ethe `quaternion_from_euler` function. This document directly addresses the critical theoretical and practical aspects of\u003cbr\u003eorientation control that the user needs.","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 6)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.685\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.495\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.400\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains C++ source code, headers, and configuration files for developing and controlling entities within\u003cbr\u003ethe Gazebo simulator. It provides in-depth information on specific Gazebo systems and plugins, including the\u003cbr\u003eimplementation and API for `gz::sim::systems::MulticopterVelocityControl` and `gz::sim::systems::PosePublisher`, as well\u003cbr\u003eas the foundational `gz::sensors::Sensor` base class. Key topics include configuring these components using SDF files,\u003cbr\u003eutilizing `gz-transport` and `gz topic` for communication and control, and practical examples like a `multicopter.sdf`\u003cbr\u003eworld file for simulating quadcopters and hexacopters. Children nodes: MulticopterVelocityControl Plugin C++\u003cbr\u003eImplementation, PosePublisher Gazebo System Header, MulticopterVelocityControl System Header, Gazebo Sensor Base Class\u003cbr\u003eImplementation, Gazebo Multicopter Simulation Resources\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 7)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.938\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 1.000\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 3: 0.95; 1: 0.9; 2: 0.85; 4: 0.3; 0: 0.0; 5: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic contains technical documentation, tutorials, and troubleshooting guides for developing and simulating\u003cbr\u003esoftware for the PX4 Autopilot drone ecosystem. It focuses heavily on using the Gazebo simulator for Software-in-the-\u003cbr\u003eLoop (SITL) simulation and Visual Studio Code (VSCode) as the primary development environment. Content includes\u003cbr\u003ecomprehensive guides for setting up a C++ environment in VSCode, running PX4 simulations with `make` commands,\u003cbr\u003eintegrating with ROS and MAVSDK, and debugging specific issues like the Gazebo visualizer failing to launch. The cluster\u003cbr\u003ealso covers advanced topics like computer vision applications using AprilTags. Children nodes: C++ Development Setup in\u003cbr\u003eVSCode, PX4 Gazebo SITL Simulation Guide, PX4 Autopilot Project Portal and Gazebo Guide, Complete PX4 Autopilot\u003cbr\u003eDocumentation, PX4 Computer Vision Applications, Troubleshooting Gazebo Launch from VSCode for PX4 SITL\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is attempting to perform a yaw rotation on a drone using a Python script with `rospy` and `mavros`. The script\u003cbr\u003euses `setpoint_velocity\u002fcmd_vel` and `setpoint_position\u002flocal` topics, and explicitly converts Euler angles to\u003cbr\u003equaternions using `quaternion_from_euler` for orientation. The core problem is understanding how to correctly implement\u003cbr\u003eyaw rotation within this PX4\u002fROS context.\u003cbr\u003e\u003cbr\u003e- **[3] Complete documentation for the PX4 Autopilot flight control system**: This document is highly relevant because\u003cbr\u003eit covers the entire PX4 Autopilot system, including in-depth developer resources, software architecture, and crucially,\u003cbr\u003eintegration with ROS. It would provide the most comprehensive information on how to command drone movements, including\u003cbr\u003eyaw, through ROS\u002fMAVROS, and explain the proper usage of position and velocity setpoints for orientation control. This\u003cbr\u003eis the primary source for understanding PX4's expected behavior and API with ROS.\u003cbr\u003e\u003cbr\u003e- **[1] Gazebo simulator with PX4 Autopilot for SITL simulation**: This is highly relevant as it focuses on PX4\u003cbr\u003eSoftware-in-the-Loop (SITL) simulation with Gazebo and explicitly mentions ROS integration and developer-focused\u003cbr\u003efeatures. The user's script implies a simulation or development environment, making this a practical resource for\u003cbr\u003eunderstanding how to control the drone, including yaw, within this setup. It's likely to contain code examples or guides\u003cbr\u003epertinent to drone control via ROS.\u003cbr\u003e\u003cbr\u003e- **[2] PX4 Autopilot project, top-level navigation and complete guide to Gazebo simulation**: Similar to [1], this\u003cbr\u003edocument provides a detailed guide on using Gazebo for PX4 SITL, covering ROS integration and vehicle poses. It would be\u003cbr\u003every useful for understanding how to set the drone's orientation (including yaw) within a simulated environment using\u003cbr\u003eROS, potentially offering specific examples or configurations related to `PoseStamped` messages.\u003cbr\u003e\u003cbr\u003e- **[6] API documentation and guides for computer vision and 3D data processing**: This candidate is directly relevant\u003cbr\u003eto a specific part of the user's code: the `quaternion_from_euler` function. The user is explicitly using this for\u003cbr\u003eorientation. This document would provide critical information on how to correctly perform 3D geometric transformations,\u003cbr\u003especifically converting Euler angles to quaternions for yaw, which is fundamental for setting the drone's orientation\u003cbr\u003eaccurately. While not covering the entire PX4\u002fROS context, it addresses a key mathematical component of the user's\u003cbr\u003eproblem.\u003cbr\u003e\u003cbr\u003e- **[4] PX4 open-source drone ecosystem, computer vision applications**: This candidate mentions PX4, Gazebo, and\u003cbr\u003e`mavros`, which are relevant keywords. However, its primary focus is on advanced computer vision applications like\u003cbr\u003eprecision landing, rather than basic flight control or yaw rotation. While it might contain examples of `mavros` usage,\u003cbr\u003eit's less likely to directly address the user's specific problem of implementing yaw compared to the other top-ranked\u003cbr\u003ecandidates.\u003cbr\u003e\u003cbr\u003e- **[0] C++ development environment in Visual Studio Code**: This is irrelevant. The query is about Python programming\u003cbr\u003efor drone control, not C++ development environment setup.\u003cbr\u003e\u003cbr\u003e- **[5] Troubleshooting Gazebo visualization window in VSCode**: This is irrelevant. The query is about implementing yaw\u003cbr\u003erotation for a drone, not troubleshooting a Gazebo visualization bug.","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.156\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical guides, API references, and support discussions related to data serialization and message\u003cbr\u003econstruction, with a strong focus on Protocol Buffers (Protobuf) and the Nanopb C library. It covers implementation\u003cbr\u003edetails for various programming languages, including C, C++, and Ruby, and addresses common challenges such as encoding\u003cbr\u003erepeated fields, handling submessages, and using callbacks. Key entities include Nanopb, Protocol Buffers, TIBCO\u003cbr\u003eRendezvous, `protoc`, and serialization APIs in C and Ruby. Children nodes: Nanopb GitHub Issue: Encoding Repeated\u003cbr\u003eSubmessages, TIBCO Rendezvous Message Field Guide, Nanopb Google Group: Encoding Repeated Fields, Protocol Buffers Ruby\u003cbr\u003eLanguage Guide\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.158\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster offers comprehensive technical guides and documentation on GUI layout management in the Qt framework. It\u003cbr\u003edetails the use of fundamental classes like `QHBoxLayout`, `QVBoxLayout`, and `QGridLayout`, and explains the underlying\u003cbr\u003emechanics of space allocation through concepts like `stretch factors`, `QWidget::sizePolicy`, and `sizeHint`. For\u003cbr\u003eadvanced use cases, it provides instructions and C++ examples, such as a `CardLayout` example, on how to create custom\u003cbr\u003elayout managers by subclassing the `QLayout` class. Children nodes: Comprehensive Guide to Qt GUI Layout Management, Qt\u003cbr\u003eLayout Management System Documentation\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.870\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.764\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 1.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 1: 0.95; 0: 0.2; 2: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains API documentation and guides for libraries used in computer vision and 3D data processing,\u003cbr\u003eincluding Open3D's `open3d.geometry` module, the `tf.transformations` library, and OpenCV's `cv::KalmanFilter`. It\u003cbr\u003ecovers topics such as 3D geometric transformations (rotation, scaling, translation), conversion between representations\u003cbr\u003elike quaternions and Euler angles, state estimation, and object tracking. Key entities include `PointCloud`,\u003cbr\u003e`TriangleMesh`, `transformation matrix`, `predict()`, and `correct()`. Children nodes: Open3D Geometry API\u003cbr\u003eDocumentation, tf.transformations Library Guide, OpenCV KalmanFilter API Documentation\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is attempting to perform yaw rotation for a drone using `rospy` and `mavros`, and the provided code snippet\u003cbr\u003eincludes the function `quaternion_from_euler` to set the drone's orientation. The core problem is understanding how to\u003cbr\u003ecorrectly apply yaw rotation using this approach.\u003cbr\u003e\u003cbr\u003e- **Candidate [1] tf.transformations Library Guide:** This document is highly relevant. The `tf.transformations` library\u003cbr\u003eis specifically designed for 3D spatial transformations, including the conversion between Euler angles and quaternions,\u003cbr\u003ewhich is exactly what `quaternion_from_euler` does. This library is critical for understanding and correctly\u003cbr\u003eimplementing the yaw rotation as attempted in the user's code. It directly addresses the concepts and tools the user is\u003cbr\u003estruggling with.\u003cbr\u003e\u003cbr\u003e- **Candidate [3] Computer Vision and 3D Data Processing Libraries (Cluster):** This cluster is also highly relevant as\u003cbr\u003eit explicitly mentions the `tf.transformations` library and covers \"conversion between representations like quaternions\u003cbr\u003eand Euler angles\" and \"3D geometric transformations (rotation, scaling, translation)\". While it's a broader category and\u003cbr\u003eincludes other less relevant topics, its direct mention of `tf.transformations` and related concepts makes it a strong\u003cbr\u003ecandidate for providing context and guiding the user to the specific solution.\u003cbr\u003e\u003cbr\u003e- **Candidate [0] Open3D Geometry API Documentation:** This document is less relevant. While it deals with `rotate` and\u003cbr\u003e`geometric transformations`, it pertains to the `open3d.geometry` module, which is a 3D data processing library for\u003cbr\u003egeometry objects. The context of the user's problem is drone control using ROS\u002fMavros and `tf.transformations`, not\u003cbr\u003eOpen3D geometry manipulation. The specific `quaternion_from_euler` function is not part of Open3D.\u003cbr\u003e\u003cbr\u003e- **Candidate [2] OpenCV KalmanFilter API Documentation:** This document is irrelevant. It describes the\u003cbr\u003e`cv::KalmanFilter` class for object tracking and state estimation, which has no direct bearing on the user's problem of\u003cbr\u003eperforming yaw rotation or using quaternions and Euler angles for drone orientation control.","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.158\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains technical information and discussions about implementing concurrency and multithreading across\u003cbr\u003edifferent programming environments. Topics include preventing race conditions in Windows drivers using spinlocks for\u003cbr\u003ecallbacks like `PsSetLoadImageNotifyRoutine`, utilizing `worker_threads` in Node.js, managing GUI updates like\u003cbr\u003e`WM_PAINT` with worker threads in Windows programming, and the use of POSIX (pthreads) functions such as\u003cbr\u003e`pthread_mutex_init` and `pthread_mutex_destroy` for synchronization. Children nodes: Windows Driver Concurrency and\u003cbr\u003eSpinlocks, Node.js Multithreading with worker_threads, Multithreaded Handling of WM_PAINT in Windows, POSIX Threads\u003cbr\u003eMutex Documentation\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.105\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eConcerns the academic paper 'Impedance Control Using Selected Compliant Prismatic Joint in a Free-Floating Space\u003cbr\u003eManipulator' by Palma et al. This topic covers the paper's full text, mathematical modeling (Generalized Jacobian\u003cbr\u003eMatrix, dynamics), control theory, and detailed simulation performance data, including joint torques and contact forces\u003cbr\u003efor space debris removal. Children nodes: 0, 16\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.725\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.499\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.650\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 1: 0.9; 0: 0.7; 2: 0.5; 3: 0.3\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides a comprehensive mathematical treatment of robot kinematics, focusing on the derivation and calculation of a\u003cbr\u003erobot's position, orientation, and velocity. Key topics include the fundamentals of rigid-body motion, the use of\u003cbr\u003eHomogeneous Transformation and Rotation Matrices, and advanced analysis of end-point linear and angular velocity using\u003cbr\u003ethe exponential map (Rodrigues' formula), matrix logarithms, and skew-symmetric matrices. Children nodes: 0, 16, 32, 48\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is attempting to perform yaw rotation using `rospy` and `mavros`, and has provided code snippet that utilizes\u003cbr\u003e`quaternion_from_euler` to set orientation. The core problem is how to effectively control or achieve yaw rotation using\u003cbr\u003ethese tools and concepts.\u003cbr\u003e\u003cbr\u003eCandidate [4] is highly relevant because it directly addresses the `tf.transformations` Python library, which includes\u003cbr\u003efunctions like `quaternion_from_euler` that the user is already using. This document covers converting between rotation\u003cbr\u003erepresentations (matrices, quaternions, Euler angles) and manipulating them, which is crucial for understanding how to\u003cbr\u003eproperly implement and control yaw rotation.\u003cbr\u003e\u003cbr\u003eCandidate [1] is also highly relevant as it provides a detailed mathematical treatment of robot kinematics, explicitly\u003cbr\u003edefining \"Roll, Pitch, and Yaw\" and their corresponding rotation matrices. Understanding these foundational concepts is\u003cbr\u003eessential for the user to grasp what yaw is and how it's mathematically represented and controlled, even when using\u003cbr\u003equaternions.\u003cbr\u003e\u003cbr\u003eCandidate [0] provides a general tutorial on classical rigid-body robot kinematics, covering coordinate systems,\u003cbr\u003erotation matrices, and homogeneous transformations. While fundamental to robotics, it is less specific to the user's\u003cbr\u003eimmediate problem of implementing \"yaw rotation\" using quaternions and the `quaternion_from_euler` function, making it\u003cbr\u003eless directly helpful than [4] or [1].\u003cbr\u003e\u003cbr\u003eCandidate [2] focuses on the mathematical treatment of calculating linear and angular velocity of a robot's end point.\u003cbr\u003eWhile angular velocity is related to rotation, the user's code snippet implies setting a target orientation (pose)\u003cbr\u003erather than continuous angular velocity control. This document is more about the theoretical derivation of velocities\u003cbr\u003efor dynamic motion, which is a step removed from understanding how to specify or achieve a particular yaw angle.\u003cbr\u003e\u003cbr\u003eCandidate [3] is similar to [2] but focuses on calculating angular and linear velocities specifically for multi-link\u003cbr\u003erobot arms. This is less relevant to the user's context, which appears to be a drone (implied by `mavros`) needing\u003cbr\u003esimple yaw rotation, not a complex robot arm.","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.678\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.406\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.550\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic covers the mathematical formalisms for the kinematic and dynamic modeling of robotic systems. It details the\u003cbr\u003euse of the recursive Newton-Euler formulation for analyzing robot dynamics and explains the underlying kinematic\u003cbr\u003edescriptions using transformation matrices derived from geometric parameters. The content distinguishes between various\u003cbr\u003erobot architectures such as serial, tree, and closed-loop structures, and defines fundamental components like revolute\u003cbr\u003eand prismatic joints.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.864\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.778\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 1: 0.9; 2: 0.88; 0: 0.85; 3: 0.3\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides a comprehensive resource on Euler angles for describing 3D orientation. This includes the technical definitions\u003cbr\u003eof Proper Euler angles and Tait-Bryan angles (yaw, pitch, roll), their mathematical representation using explicit\u003cbr\u003erotation matrices for various conventions (e.g., ZXZ, ZYX), and theoretical connections to group theory (SO(3)) and\u003cbr\u003equaternions. The information covers the critical singularity issue of gimbal lock and details diverse applications in\u003cbr\u003efields such as rigid body dynamics, aerospace, robotics, and materials science, supplemented by academic references and\u003cbr\u003eexternal links. Children nodes: 0, 16, 32, 48\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is trying to implement yaw rotation for a drone using `rospy` and `mavros`. Their code snippet includes `q =\u003cbr\u003equaternion_from_euler(0.0,0.0,3.0)`, indicating they are working with Euler angles converted to quaternions, likely\u003cbr\u003eusing the `tf.transformations` library. The core problem is understanding how to correctly apply yaw rotation using this\u003cbr\u003emethod.\u003cbr\u003e\u003cbr\u003e*   **[4] Provides comprehensive guides and API reference documentation for the `tf.transformations` Python library:**\u003cbr\u003eThis document is highly relevant because the user's code `quaternion_from_euler` strongly suggests they are using this\u003cbr\u003especific Python library. Understanding the function's arguments (order, units, convention) is crucial for correctly\u003cbr\u003eimplementing yaw. This directly addresses the 'how-to' aspect of their coding problem.\u003cbr\u003e\u003cbr\u003e*   **[1] This cluster provides a comprehensive guide to Tait\u2013Bryan angles:** This candidate is extremely relevant as\u003cbr\u003eTait-Bryan angles are commonly used for yaw, pitch, and roll in aerospace applications like drones. It explains their\u003cbr\u003edefinition, application, various conventions, and comparison to quaternions, which directly addresses the conceptual\u003cbr\u003eunderstanding of 'yaw rotation' in the user's context.\u003cbr\u003e\u003cbr\u003e*   **[2] This section provides a comprehensive overview of Euler angles:** This document offers a robust theoretical\u003cbr\u003eand practical foundation for Euler angles, including their relationship to quaternions and applications in rigid body\u003cbr\u003edynamics (vehicles, gimbal lock) and robotics (Tait-Bryan convention). This provides critical concepts necessary for\u003cbr\u003eunderstanding the underlying mechanics of drone orientation.\u003cbr\u003e\u003cbr\u003e*   **[0] Provides a comprehensive technical explanation of Euler angles:** This candidate offers a fundamental\u003cbr\u003eunderstanding of Euler angles, including the distinction between intrinsic\u002fextrinsic rotations and the classification\u003cbr\u003einto Proper Euler angles and Tait-Bryan angles (yaw, pitch, roll). While slightly broader than [1] or [2] regarding\u003cbr\u003edirect application to robotics\u002fdrones, it provides essential background theory.\u003cbr\u003e\u003cbr\u003e*   **[3] This cluster contains supplementary materials and concluding sections for a resource on Euler angles:** This\u003cbr\u003edocument primarily contains references, bibliographies, and related mathematical concepts. While tangentially related to\u003cbr\u003ethe topic of Euler angles and quaternions, it does not provide direct explanations or practical guidance to help the\u003cbr\u003euser solve their specific problem of implementing yaw rotation in code. Therefore, it is less relevant than the other\u003cbr\u003ecandidates.","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 4)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.818\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.685\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.850\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 0: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic covers the representation of pose in free space, detailing a structure composed of a point for position and a\u003cbr\u003equaternion for orientation, relevant to fields like robotics and computer graphics.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is having trouble performing yaw rotation using the `quaternion_from_euler` function in their `mavros` and\u003cbr\u003e`rospy` drone control script. They know how to arm and take off, and their code snippet shows an attempt to set\u003cbr\u003eorientation using `quaternion_from_euler(0.0,0.0,3.0)`. The core problem is understanding which parameter in this\u003cbr\u003efunction controls yaw and potentially understanding the axis conventions.\u003cbr\u003e\u003cbr\u003eHere's a step-by-step analysis of each document:\u003cbr\u003e\u003cbr\u003e*   **[0]**: This passage provides a very general definition of pose, position, and quaternion. It offers no specific\u003cbr\u003edetails on `quaternion_from_euler` or how to implement yaw rotation, making it irrelevant to the user's specific\u003cbr\u003eproblem.\u003cbr\u003e*   **[1]**: This document describes the `transformations` library, which is where `quaternion_from_euler` originates.\u003cbr\u003eIt states its purpose (converting between rotation matrices, Euler angles, and quaternions) and notes conventions like\u003cbr\u003eangles being in radians and the quaternion representation. It provides crucial context for the function the user is\u003cbr\u003etrying to use and alludes to the `axes` parameter, which is important for Euler angle conventions.\u003cbr\u003e*   **[2]**: This passage discusses conventions for Euler angles, specifically the right-hand rule for signs and ranges.\u003cbr\u003eWhile related to Euler angles in general, it does not explain how to apply yaw rotation using the\u003cbr\u003e`quaternion_from_euler` function or clarify its parameters.\u003cbr\u003e*   **[3]**: This document explains","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides a comprehensive technical guide to the ROS `catkin` `package.xml` manifest file. This topic cluster covers the\u003cbr\u003efile's fundamental structure, syntax, required metadata tags (e.g., `\u003cname\u003e`, `\u003clicense\u003e`), and file formats. It places\u003cbr\u003ea significant focus on the declaration of various dependency types, such as `\u003cbuild_depend\u003e`, `\u003cexec_depend\u003e`, and\u003cbr\u003e`\u003ctest_depend\u003e`. Furthermore, it offers in-depth information on creating and configuring metapackages, detailing the use\u003cbr\u003eof the `\u003cmetapackage\u002f\u003e` export tag and the required `catkin_metapackage()` command in the `CMakeLists.txt` file.\u003cbr\u003eChildren nodes: 0, 16, 32, 48, 64, 80, 96\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical guides, open-source projects, and articles from Black Coffee Robotics focused on robotics software\u003cbr\u003eengineering. Core topics include practical implementation and migration guides for using Gazebo Ignition\u002fSim with ROS 2,\u003cbr\u003edetails on the `bcr_bot` open-source AMR simulator, and general software engineering for robotics. This cluster also\u003cbr\u003eincludes the company's official contact information, location, and career opportunities. Children nodes: 0, 16, 32, 48\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides a comprehensive solution for the ROS error, 'No valid hardware interface element found in joint,' specific to\u003cbr\u003eROS Indigo and the `ros_control` package. This cluster contains the problem description, debugging info from a user\u003cbr\u003eupgrading from ROS Hydro, and the definitive fix: adding a `\u003chardwareInterface\u003e` tag (e.g., `EffortJointInterface`)\u003cbr\u003einside the `\u003ctransmission\u003e` block of a URDF\u002fXACRO file. It includes code examples, metadata from the original Q&A forum,\u003cbr\u003eand links to the relevant bug report. Children nodes: 0, 16, 32, 48, 64\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eCovers advanced configuration and troubleshooting for integrating `ros2_control` into a ROS 2 mobile robot simulation\u003cbr\u003ewith Gazebo. Key topics include using `xacro` arguments and `Command` substitution in launch files to conditionally\u003cbr\u003eswitch between control plugins (e.g., `ros2_control` vs. Gazebo's diff drive). This cluster also provides solutions for\u003cbr\u003ecommon simulation problems like slow clock rates, wheel drift, and sensor synchronization issues, with practical code\u003cbr\u003eexamples for URDF\u002fxacro, launch files, and RViz configurations. Children nodes: 0, 16, 32, 48, 64, 80\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 4)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical discussions from July 2014 about the ROS `ros_control` framework, focusing on the implementation,\u003cbr\u003ecomparison, and troubleshooting of various controllers. Topics include debugging effort and velocity controllers\u003cbr\u003e(`JointVelocityController`) in Gazebo, PID tuning, URDF configuration, and the practical implementation of custom\u003cbr\u003econtrol logic through classes like `HardwareInterfaceAdapter`. Children nodes: 0, 16\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 5)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.799\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.736\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.900\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 0: 0.7; 1: 0.6\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical guides, troubleshooting, and discussions on setting up and controlling quadcopter simulations in the\u003cbr\u003eGazebo environment. Key topics include configuring custom models, controlling individual motor\u002frotor speeds, logging\u003cbr\u003evehicle pose, resolving physical instability, and integrating sensors like cameras. This cluster references specific\u003cbr\u003esoftware packages like `hector_quadrotor` and `PX4`, as well as the development of custom Gazebo plugins for advanced\u003cbr\u003eaerodynamics. Children nodes: 0, 16\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is encountering an issue with implementing yaw rotation in a quadcopter control script using `rospy` and\u003cbr\u003e`mavros`, specifically when employing `quaternion_from_euler` to set the orientation. The core problem lies in correctly\u003cbr\u003eapplying yaw rotation programmatically.\u003cbr\u003e\u003cbr\u003eCandidate [2] is highly relevant because it provides comprehensive guides and API reference documentation for the\u003cbr\u003e`tf.transformations` Python library. The user's code snippet explicitly uses `quaternion_from_euler`, a function from\u003cbr\u003ethis library. This candidate directly addresses the creation, manipulation, and conversion of rotation representations\u003cbr\u003e(quaternions, Euler angles), which is critical for understanding and fixing the user's yaw rotation problem. It offers\u003cbr\u003ethe specific theoretical and practical knowledge needed to resolve the coding issue.\u003cbr\u003e\u003cbr\u003eCandidate [0] is moderately relevant. It discusses quadcopter simulation in Gazebo, including the control and logging of\u003cbr\u003evehicle pose (x, y, z, roll, pitch, yaw). While the user's problem is about quadcopter control and involves `mavros`\u003cbr\u003e(often related to PX4\u002fGazebo), this candidate focuses more on the overall simulation setup and model validation. It\u003cbr\u003eprovides contextual relevance by mentioning yaw and quadcopter control, but it does not delve into the specific coding\u003cbr\u003eimplementation details or the `tf.transformations` library that the user is struggling with.\u003cbr\u003e\u003cbr\u003eCandidate [1] is also moderately relevant but slightly less specific than [0]. It broadly covers technical information,\u003cbr\u003etroubleshooting, and configuration for quadcopter simulation in Gazebo. Topics include setting up control for custom\u003cbr\u003emodels and resolving simulation issues. While related to quadcopter control, it focuses on the simulation environment\u003cbr\u003eand general configuration rather than the precise ROS\u002fPython coding aspect of achieving yaw rotation using quaternions\u003cbr\u003eand `mavros` setpoint topics. It lacks the direct link to the `tf.transformations` library or the specific problem of\u003cbr\u003eorienting the quadcopter that the user is facing.","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 6)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides comprehensive technical specifications and documentation for the `\u003ctransmission\u003e` element in ROS Unified Robot\u003cbr\u003eDescription Format (URDF). This cluster details the XML syntax, purpose in modeling actuator-joint relationships, and\u003cbr\u003eintegration with the `ros_control` framework, including implementation guidance for components like\u003cbr\u003e`\u003chardwareInterface\u003e` for Gazebo and RobotHW. Children nodes: 0, 16\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 7)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides a comprehensive, step-by-step technical guide for configuring a robot manipulator for simulation and control in\u003cbr\u003eGazebo using ROS. Key topics include creating and modifying URDF\u002fXACRO files, adding `\u003ctransmission\u003e` tags, integrating\u003cbr\u003ethe `gazebo_ros_control` plugin, configuring controllers via YAML files (`joints.yaml`), and using ROS tools like\u003cbr\u003e`rosparam`, `controller_spawner`, and `rostopic` for launching and testing. This content is part of the e-learning\u003cbr\u003eplatform 'The Construct', and the cluster also includes information about the company, its other courses, and website\u003cbr\u003ecomponents. Children nodes: 0, 16, 32, 48, 64, 80, 96, 112, 128\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 8)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical Q&A forum discussions about troubleshooting issues in the Gazebo robotics simulator, particularly\u003cbr\u003efocusing on a bug with the `gazebo_ros_tricycle_drive` plugin where linear and angular control is problematic. Includes\u003cbr\u003eproposed solutions using `ros2_control` for ROS Humble\u002fGalactic and general discussions on Gazebo topics such as model\u003cbr\u003espawning errors, SDF\u002fURDF configuration, and physics. Children nodes: 0, 16, 32, 48\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 9)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical information and Q&A discussions about troubleshooting custom Gazebo plugins within the Robot\u003cbr\u003eOperating System (ROS) framework, specifically when they fail to load from a URDF file. Key topics include debugging\u003cbr\u003esteps like using the `--verbose` flag, checking the `package.xml` and `GAZEBO_PLUGIN_PATH` environment variable, and\u003cbr\u003eunderstanding the implementation differences between URDF and SDF models. Children nodes: 0, 16, 32, 48, 64, 80\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 10)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.520\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.178\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.300\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides technical guides and C++ code examples for controlling model velocity in the Gazebo physics simulator. This\u003cbr\u003ecluster focuses on setting the velocity of joints and links by detailing and comparing various methods, including direct\u003cbr\u003einstantaneous setting via API calls (`SetVelocity`, `SetLinearVel`), using joint motors, and implementing stable, force-\u003cbr\u003ebased dynamic control with PID controllers. Children nodes: 0, 16, 32, 48, 64, 80\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 11)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical guides and Q&A forum discussions on integrating advanced Gazebo SDF features into URDF robot models.\u003cbr\u003eThe core topic is the use of the `\u003cgazebo\u003e` extension tag to embed SDF-native elements, particularly for defining\u003cbr\u003ecomplex physics properties (for ODE, Bullet engines) and collision settings. This cluster includes practical XML code\u003cbr\u003eexamples, troubleshooting advice, and verification methods using command-line tools like `gz sdf`. Children nodes: 0,\u003cbr\u003e16, 32, 48, 64, 80\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 12)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic covers technical discussions and troubleshooting for creating and simulating 3D models in the ROS and Gazebo\u003cbr\u003eecosystem. It addresses challenges with URDF, including modeling complex or curved geometry using mesh files (.dae,\u003cbr\u003e.stl), resolving Gazebo spawning errors like 'GazeboROSNode SpawnModel Failure', and fixing unstable simulation physics\u003cbr\u003eby correctly defining inertial properties. The content also includes recommendations for external modeling and mesh-\u003cbr\u003eediting tools such as Blender and MeshLab. Children nodes: 0, 16, 32, 48, 64, 80, 96\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 13)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic provides comprehensive documentation and examples for using the `\u003cgazebo\u003e` extension tag in URDF files to\u003cbr\u003econtrol their conversion to SDFormat for Gazebo simulation. It details how to add simulation-specific properties to both\u003cbr\u003elinks and joints, covering attributes such as friction (`mu1`, `mu2`), contact parameters (`kp`, `kd`), visual\u003cbr\u003ematerials, and joint physics (`springStiffness`). A key focus is on managing fixed joint behavior during conversion,\u003cbr\u003ewith examples using `preserveFixedJoint` and `disableFixedJointLumping` to prevent lumping optimizations. The content\u003cbr\u003eincludes detailed URDF\u002fSDFormat code snippets and references to inspection tools like `gz sdf -p`. Children nodes: 0,\u003cbr\u003e16, 32\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 14)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eConcerns a specific Q&A forum page from answers.gazebosim.org about troubleshooting a prismatic joint in the Gazebo\u003cbr\u003esimulator. The central issue is a robot's failure to move along the z-axis, despite configurations in its XACRO\u002fURDF\u003cbr\u003efile using `gazebo_ros_control`. The page also includes a list of related questions on similar Gazebo, ROS, and robot\u003cbr\u003emodeling issues. Children nodes: 0, 16, 32, 48\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 15)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical guides, tutorials, and Q&A for spawning models and robots into the Gazebo simulator using ROS2. This\u003cbr\u003ecluster provides detailed instructions, Python code examples using `rclpy`, and complete launch files for spawning\u003cbr\u003eentities from URDF, SDF, and XACRO files by calling the `gazebo_msgs\u002fSpawnEntity` service. It also includes\u003cbr\u003etroubleshooting advice for common issues. Children nodes: 0, 16, 32, 48, 64, 80, 96\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 16)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eCovers debugging, workarounds, and resolutions for the `spawn_model -J` command failing to set initial robot joint\u003cbr\u003epositions in ROS\u002fGazebo. The central issue is a startup race condition in `gazebo_ros_pkgs`. Key topics include\u003cbr\u003ediscussions from GitHub issue #93 and the common workaround of launching Gazebo paused (`paused=true`) and then\u003cbr\u003eunpausing with the spawner. Children nodes: 0, 16\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 17)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides technical support, Q&A, and development discussions for the Gazebo robotics simulator and its use with the\u003cbr\u003eRobot Operating System (ROS). Key topics include debugging, C++ plugin development, SDF\u002fURDF modeling, physics, and\u003cbr\u003eresolving specific errors like `spawn_entity` failures. All content originates from the web aggregator service\u003cbr\u003erssing.com and may be mixed with unrelated articles from other RSS feeds. Children nodes: 0, 16\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 18)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains technical questions, answers, and discussions from a developer Q&A forum focused on the Robot\u003cbr\u003eOperating System 2 (ROS2). It covers practical troubleshooting and programming topics, including the correct syntax for\u003cbr\u003ecomplex parameters in YAML files, lifecycle node management with rclcpp, Python import errors in launch files, and\u003cbr\u003eissues with native DDS and rosdep dependencies. Children nodes: 0, 16, 32, 48\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 19)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains technical questions, answers, and discussions from the 'ROS Answers' Q&A forum, with a primary focus on Robot\u003cbr\u003eOperating System 2 (ROS 2). The content specifically centers on package management, including `package.xml`\u003cbr\u003econfigurations, the use of `build_depend` versus `exec_depend`, differences between package formats, and corrections to\u003cbr\u003eofficial tutorials. This cluster also includes lists of related ROS 2 questions and the website's structural boilerplate\u003cbr\u003eand metadata. Children nodes: 0, 16, 32, 48, 64\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 4, 20)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.054\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003ePertains to a tutorial from the 'Automatic Addison' robotics blog on simulating a depth camera in Gazebo. This guide\u003cbr\u003eprovides detailed instructions and SDF code for adding the sensor to a robot model, integrating it with ROS\u002fROS 2, and\u003cbr\u003evisualizing the output. This cluster includes both the core technical article and the surrounding website's navigational\u003cbr\u003eboilerplate and links. Children nodes: 0, 16\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 7, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.047\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains comprehensive documentation, guides, and tutorials for setting up a C++ development environment in Visual\u003cbr\u003eStudio Code. Topics cover installing the Microsoft C\u002fC++ extension, and installing and configuring prerequisite C++\u003cbr\u003ecompilers and toolchains (MinGW-w64, GCC, Clang, MSVC) for Windows, macOS, and Linux. Includes step-by-step walkthroughs\u003cbr\u003efor building and debugging a 'Hello World' application, as well as information on advanced features like remote\u003cbr\u003edevelopment (SSH, WSL, Docker) and GitHub Copilot integration. Children nodes: 0, 16, 32, 48, 64, 80, 96\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 7, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.850\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.787\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.900\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 11: 0.2; 1: 0.15; 0: 0.1; 3: 0.1; 10: 0.1; 2: 0.05; 4: 0.05; 5: 0.05; 6: 0.05; 7: 0.05; 8: 0.05; 9: 0.05\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic contains comprehensive documentation for using the Gazebo simulator with the PX4 Autopilot for Software-in-\u003cbr\u003ethe-Loop (SITL) simulation. It covers the entire workflow from installation, running a first flight with `make`\u003cbr\u003ecommands, to advanced configuration of worlds, vehicle models, and environmental factors like wind and GPS noise. The\u003cbr\u003eguides detail how to simulate peripherals like cameras and parachutes, set up video streaming to QGroundControl, and use\u003cbr\u003edeveloper-focused features including IDE debugging, ROS integration, verbose logging, and simulation customization.\u003cbr\u003eChildren nodes: 0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user's query describes a problem with performing yaw rotation in a Python script that controls a drone, specifically\u003cbr\u003eusing `quaternion_from_euler`. The code snippet provided directly shows the use of this function to set the orientation.\u003cbr\u003eThe problem is not about arming or takeoff, which the user states work fine, but rather about the yaw rotation itself. I\u003cbr\u003eneed to find information that can help debug or correctly implement yaw rotation using the specified method or related\u003cbr\u003econcepts.\u003cbr\u003e\u003cbr\u003e*   **[0] PX4 Autopilot Project Top-Level Navigation:** This document provides a high-level overview and links to PX4\u003cbr\u003eresources. It does not contain specific technical guidance on controlling yaw or using Python libraries for orientation,\u003cbr\u003emaking it irrelevant to the specific problem.\u003cbr\u003e*   **[1] Gazebo SITL Documentation Overview:** This is a general overview of Gazebo simulation with PX4. While the\u003cbr\u003econtext implies a simulation environment, this document does not provide details on specific control commands or the\u003cbr\u003emathematical aspects of yaw rotation, making it irrelevant.\u003cbr\u003e*   **[2] Installing Gazebo for PX4 SITL:** This document focuses on the installation and launching of Gazebo\u003cbr\u003esimulations. It contains no information relevant to programming yaw control or interpreting Euler angles\u002fquaternions,\u003cbr\u003emaking it irrelevant.\u003cbr\u003e*   **[3] First Flight with PX4 SITL Gazebo:** This guide covers basic takeoff procedures in Gazebo SITL. The user\u003cbr\u003estates that takeoff works, so this document does not address the core issue of yaw rotation, making it irrelevant.\u003cbr\u003e*   **[4] Advanced Configuration PX4 SITL Gazebo (Headless, Home, Speed, Wind, Failsafes):** This document details\u003cbr\u003econfiguration options for the simulation environment, such as headless mode, home location, speed, wind, and failsafes.\u003cbr\u003eNone of these topics relate to the implementation of yaw control in a Python script, making it irrelevant.\u003cbr\u003e*   **[5] Advanced Configuration PX4 Gazebo (Wind, GPS Noise, Ground Model, Joystick):** This document covers\u003cbr\u003eenvironmental simulation parameters and joystick control. It does not provide guidance on programmatic yaw control,\u003cbr\u003emaking it irrelevant.\u003cbr\u003e*   **[6] PX4 Gazebo Simulation Environment Configuration (Worlds, GPS Noise, Spawn Location):** This document discusses\u003cbr\u003eloading different worlds, GPS noise, and vehicle spawn locations. These topics are unrelated to the user's specific\u003cbr\u003eproblem with yaw rotation, making it irrelevant.\u003cbr\u003e*   **[7] Advanced PX4-Gazebo SITL Configuration (Real-world GPS, Debugging):** This document covers setting real-world\u003cbr\u003eGPS coordinates and debugging PX4 and Gazebo separately. While debugging is mentioned, the specific content does not\u003cbr\u003ehelp with the yaw control problem, making it irrelevant.\u003cbr\u003e*   **[8] Simulating Advanced Peripherals (Camera, Parachute, Failsafes):** This document focuses on simulating specific\u003cbr\u003ehardware and safety features. It has no content related to basic flight control or yaw rotation, making it irrelevant.\u003cbr\u003e*   **[9] UDP Video Streaming from PX4 SITL Gazebo:** This document is about video streaming from the simulator, which\u003cbr\u003eis entirely unrelated to controlling yaw, making it irrelevant.\u003cbr\u003e*   **[10] Advanced PX4 SITL Gazebo (Video, Troubleshooting, Extending Simulation):** This document covers video\u003cbr\u003estreaming, general troubleshooting, and extending the simulation. While troubleshooting is mentioned, the content\u003cbr\u003edescribed does not specifically address control issues or the use of `quaternion_from_euler` for yaw, making it\u003cbr\u003eirrelevant.\u003cbr\u003e*   **[11] Gazebo ROS Interface and Octomap:** This document mentions a ROS interface with Gazebo and Octomap\u003cbr\u003efunctionality. While the user's code uses ROS (`rospy`), this document is too general and does not offer specific\u003cbr\u003eguidance on implementing yaw control or using transformation libraries for this purpose, making it largely irrelevant\u003cbr\u003efor the *specific* problem.\u003cbr\u003e*   **[12] `tf.transformations` Python Library Documentation:** This document is highly relevant because the user's code\u003cbr\u003eexplicitly uses `quaternion_from_euler(0.0,0.0,3.0)`. This library provides functions for 3D spatial transformations,\u003cbr\u003eincluding conversions between rotation representations like Euler angles and quaternions. Understanding this library and\u003cbr\u003eits functions is crucial for correctly implementing yaw rotation as attempted by the user. It directly addresses the\u003cbr\u003emathematical component of the user's problem.","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 7, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.827\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.741\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.850\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 3: 0.5; 4: 0.5; 1: 0.2; 2: 0.2; 5: 0.2; 0: 0.05\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides comprehensive resources for the PX4 Autopilot project, including top-level navigation and a complete guide to\u003cbr\u003eGazebo simulation. This cluster contains the main portal to the PX4 User Guide, support channels, and ecosystem tools\u003cbr\u003elike QGroundControl. It also offers a detailed, multi-part guide on using the Gazebo simulator for PX4 Software-in-the-\u003cbr\u003eLoop (SITL), covering installation, running simulations with `make` commands, and advanced configuration for vehicle\u003cbr\u003emodels, worlds, and poses using environment variables (e.g., `PX4_GZ_MODEL`, `PX4_GZ_WORLD`). Children nodes: 0, 16, 32,\u003cbr\u003e48, 64, 80\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is asking for assistance with implementing yaw rotation in a PX4 drone control script using MAVROS and Python.\u003cbr\u003eTheir provided code snippet already attempts to use `quaternion_from_euler` from a transformation library to set\u003cbr\u003eorientation, indicating they are grappling with how to correctly represent and apply rotational changes, specifically\u003cbr\u003eyaw. The core problem is understanding and correctly using mathematical representations of rotation (like Euler angles\u003cbr\u003eand quaternions) in their MAVROS setpoint message.\u003cbr\u003e\u003cbr\u003e- **[6] `tf.transformations` Python Library Documentation:** This document is highly relevant because the user's code\u003cbr\u003eexplicitly uses `quaternion_from_euler`. This library is critical for handling 3D spatial transformations, including\u003cbr\u003econverting between rotation representations like Euler angles and quaternions. Understanding this documentation would\u003cbr\u003edirectly help the user correctly implement yaw rotation. It is the most promising candidate for solving the immediate\u003cbr\u003ecoding problem.\u003cbr\u003e\u003cbr\u003e- **[3] PX4 Gazebo SITL: Configuration and Syntax:** This document discusses configuring PX4 SITL with Gazebo,\u003cbr\u003especifically mentioning `PX4_GZ_MODEL_POSE` for setting the initial position and *orientation* of a vehicle. While this\u003cbr\u003eis about initial simulation setup rather than dynamic in-flight control via MAVROS, it introduces the concept of setting\u003cbr\u003evehicle orientation within the PX4\u002fGazebo ecosystem, which is conceptually related to the user's goal. Therefore, it has\u003cbr\u003emoderate relevance.\u003cbr\u003e\u003cbr\u003e- **[4] PX4 Gazebo Simulation: Running and Customizing:** Similar to [3], this document provides details on customizing\u003cbr\u003ethe PX4 Gazebo simulation, including the use of `PX4_GZ_MODEL_POSE` to specify the initial orientation. It offers\u003cbr\u003econceptual links to vehicle orientation within the simulation environment, making it moderately relevant for background\u003cbr\u003econtext, but not a direct solution to the MAVROS programming challenge.\u003cbr\u003e\u003cbr\u003e- **[1] Gazebo Simulator: Introduction:** This document introduces the Gazebo simulator for PX4, providing definitions\u003cbr\u003eand naming conventions. While the user is likely operating in a simulation environment, this document is too general and\u003cbr\u003edoes not offer any specific guidance on MAVROS, yaw control, or the Python libraries involved in rotations. Thus, it has\u003cbr\u003elow relevance.\u003cbr\u003e\u003cbr\u003e- **[2] Gazebo SITL Setup Guide:** This guide focuses on the installation and setup of Gazebo for PX4 SITL, including\u003cbr\u003ecommands to run simulations. It addresses the environment but does not provide details on programmatic control of yaw or\u003cbr\u003ethe use of rotation libraries via MAVROS, making it of low relevance to the specific query.\u003cbr\u003e\u003cbr\u003e- **[5] PX4 Gazebo Configuration with Default Parameters:** This document covers configuring default parameters for PX4\u003cbr\u003esimulations with Gazebo and multi-vehicle setups. Like other Gazebo-related documents, it pertains to the simulation\u003cbr\u003eenvironment but does not offer critical concepts or solutions for the user's specific problem of implementing yaw\u003cbr\u003erotation in their MAVROS Python script. It has low relevance.\u003cbr\u003e\u003cbr\u003e- **[0] PX4 Autopilot Project: Top-level navigation and resources:** This is a very high-level document providing\u003cbr\u003egeneral navigation and resource links for the PX4 project. It contains no specific technical information related to\u003cbr\u003eMAVROS, yaw control, or Python transformation libraries, making it irrelevant to the user's specific coding problem.","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 7, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.873\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.833\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 5: 0.95; 4: 0.75; 3: 0.4; 0: 0.05; 1: 0.05; 2: 0.05; 6: 0.05\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains the complete documentation for the PX4 Autopilot flight control system, covering all aspects from user\u003cbr\u003eoperation to advanced software development. This includes user guides for vehicle assembly and flight, hardware\u003cbr\u003eselection guides for flight controllers (Pixhawk, Holybro) and peripherals (GPS, RTK), and in-depth developer resources\u003cbr\u003eon software architecture, simulation, and core communication protocols like the MAVLink and uORB message APIs. It also\u003cbr\u003edetails high-level application development and integration with ROS, MAVSDK, and companion computers. Children nodes: 0,\u003cbr\u003e16, 32, 48, 64, 80, 96\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is trying to implement yaw rotation in a Python script using MAVROS, publishing to\u003cbr\u003e`\u002fmavros\u002fsetpoint_position\u002flocal`, and utilizing `quaternion_from_euler` for orientation. The core problem is\u003cbr\u003eunderstanding how to correctly perform yaw rotation within this context.\u003cbr\u003e\u003cbr\u003e- **Candidate [5]** is highly relevant because it explicitly covers 'ROS\u002fROS 2, MAVROS, and the MAVSDK for offboard\u003cbr\u003econtrol and application development'. The user's code directly involves MAVROS for offboard control, so this\u003cbr\u003edocumentation would provide crucial guidance on how to properly set position and attitude (including yaw) via MAVROS\u003cbr\u003etopics.\u003cbr\u003e- **Candidate [7]** is also highly relevant as the user's code snippet directly uses `quaternion_from_euler` from the\u003cbr\u003e`tf.transformations` Python library. This candidate provides comprehensive guides and API references for this library,\u003cbr\u003ewhich is essential for understanding how to correctly create and manipulate quaternions for desired yaw rotations.\u003cbr\u003e- **Candidate [4]** is relevant as it provides documentation for PX4 uORB and MAVLink message definitions, including\u003cbr\u003e`PositionSetpoint` and `VehicleAttitude`. The user is publishing ROS `PoseStamped` messages, which MAVROS translates\u003cbr\u003einto MAVLink messages for the PX4 autopilot. Understanding the structure and fields of these underlying messages,\u003cbr\u003eespecially how orientation (quaternions) is represented, is beneficial for debugging and correctly formulating the yaw\u003cbr\u003ecommand.\u003cbr\u003e- **Candidate [3]** is somewhat relevant as it covers general PX4 developer documentation, including setting up\u003cbr\u003edevelopment environments and understanding uORB. While MAVROS acts as a bridge to uORB, this document is less specific\u003cbr\u003eto the ROS\u002fMAVROS interface or the `tf.transformations` library than candidates [5] or [7]. It provides a broader\u003cbr\u003econtext but not direct solutions to the user's specific problem.\u003cbr\u003e- **Candidates [0], [1], [2], and [6]** are irrelevant. Candidate [0] is a general user guide, [1] focuses on hardware,\u003cbr\u003e[2] on external peripherals, and [6] on project details and specific fixed-wing takeoff modes. None of these directly\u003cbr\u003eaddress the software implementation of yaw rotation using MAVROS and `tf.transformations` as described in the query.","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 7, 4)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.572\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.231\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.300\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eConcerns technical discussions and software for the PX4 open-source drone ecosystem, focusing on advanced computer\u003cbr\u003evision applications like precision landing and vehicle tracking. Key technologies and tools discussed include Gazebo\u003cbr\u003esimulation, MAVSDK, mavros, and AprilTag\u002fAruco markers, with content often originating from community forums like\u003cbr\u003eDronecode and pointing to specific GitHub repositories. Children nodes: 0, 16, 32\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (3, 7, 5)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.047\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides technical support and solutions for troubleshooting a bug where the Gazebo simulator's visualization window\u003cbr\u003efails to appear when launching a PX4 Software-in-the-Loop (SITL) simulation from Visual Studio Code (VSCode). This\u003cbr\u003ecluster contains bug reports, forum discussions, and how-to guides that identify the problem and offer a workaround:\u003cbr\u003emanually executing the `gazebo client` or `gzclient` task, often defined in the `.vscode\u002ftasks.json` file. Children\u003cbr\u003enodes: 0, 16, 32, 48\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.557\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.126\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.200\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides API documentation for the Open3D library's `open3d.geometry` module, detailing the core `Geometry` and\u003cbr\u003e`Geometry3D` classes and their methods. This cluster covers querying object properties (`get_center`, `get_min_bound`,\u003cbr\u003e`is_empty`), calculating boundaries (`get_axis_aligned_bounding_box`, `get_oriented_bounding_box`), and applying\u003cbr\u003egeometric transformations (`rotate`, `scale`, `translate`, `transform`). It also includes information on specific\u003cbr\u003egeometry types like `PointCloud` and `TriangleMesh` and their properties such as `color` and `volume`. Children nodes:\u003cbr\u003e0, 16, 32, 48, 64, 80, 96, 112\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.891\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.794\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 0: 0.95; 1: 0.5\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides comprehensive guides and API reference documentation for the `tf.transformations` Python library, which\u003cbr\u003efacilitates 3D spatial transformations using `Numpy`. This cluster covers the creation, manipulation, and decomposition\u003cbr\u003eof 4x4 homogeneous transformation matrices for operations like rotation, translation, and scaling. It details functions\u003cbr\u003efor converting between rotation representations such as matrices, quaternions, and Euler angles, and includes reference\u003cbr\u003efor key functions like `quaternion_from_matrix`, `scale_matrix`, `superimposition_matrix`, and `compose_matrix`.\u003cbr\u003eChildren nodes: 0, 16\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is attempting to perform yaw rotation using `quaternion_from_euler` from the `tf.transformations` library in a\u003cbr\u003edrone control script and is seeking guidance on how to do so correctly. The essential problem is understanding how to\u003cbr\u003ecorrectly apply yaw rotation through Euler to quaternion conversion.\u003cbr\u003e\u003cbr\u003e- **Candidate 0**: This document is highly relevant because it directly describes the `tf.transformations` library's\u003cbr\u003e\"robust support for converting between different 3D rotation representations, including matrices, quaternions, and Euler\u003cbr\u003eangles, with functions like `euler_from_matrix`, `quaternion_from_matrix`, and `quaternion_matrix`.\" The user's code\u003cbr\u003eexplicitly uses `quaternion_from_euler`, which is precisely a function for converting Euler angles to quaternions for\u003cbr\u003erotation. This document provides critical concepts and theories on the exact mechanism the user is struggling with.\u003cbr\u003e\u003cbr\u003e- **Candidate 1**: This document is less relevant. While it pertains to the `tf.transformations` library, its\u003cbr\u003edescription focuses on general 3D geometric transformations and vector math, mentioning functions like `scale_matrix`\u003cbr\u003eand `translation_matrix`. It does not specifically highlight the conversion between Euler angles and quaternions for\u003cbr\u003erotation, which is the core of the user's query.\u003cbr\u003e\u003cbr\u003e- **Candidate 2**: This document is also highly relevant. It serves as a comprehensive guide and API reference for the\u003cbr\u003e`tf.transformations` library and explicitly states that it \"details functions for converting between rotation\u003cbr\u003erepresentations such as matrices, quaternions, and Euler angles, and includes reference for key functions like\u003cbr\u003e`quaternion_from_matrix`.\" This directly addresses the user's use of `quaternion_from_euler` for yaw rotation. As a\u003cbr\u003eparent node that encompasses the content of node 0, it offers a broader context and foundational understanding.","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.060\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eContains comprehensive API documentation for the `cv::KalmanFilter` class in the OpenCV library, a tool for object\u003cbr\u003etracking and state estimation. This includes detailed explanations of its core methods like `predict()` and `correct()`,\u003cbr\u003eits constructors, and definitions for its essential matrix fields such as `statePost`, `transitionMatrix`,\u003cbr\u003e`measurementMatrix`, and `errorCovPost`.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.825\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.700\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.850\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 7: 0.8; 10: 0.75; 14: 0.7; 5: 0.5; 6: 0.4; 11: 0.35; 12: 0.3; 13: 0.3; 9: 0.25; 2: 0.05; 0: 0.0; 1: 0.0; 3: 0.0; 4: 0.0;\u003cbr\u003e8: 0.0; 15: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eProvides a comprehensive technical explanation of Euler angles, detailing their use in describing the orientation of a\u003cbr\u003erigid body. Key topics covered include the distinction between intrinsic and extrinsic rotations, the classification of\u003cbr\u003erotation sequences into Proper Euler angles and Tait-Bryan angles (yaw, pitch, roll), the geometrical definition using\u003cbr\u003ethe line of nodes, mathematical properties such as angle ranges and singularities like gimbal lock, and their physical\u003cbr\u003eapplications in defining precession, nutation, and spin.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is struggling with implementing yaw rotation using `quaternion_from_euler` in a `mavros` controller. The core\u003cbr\u003eof the problem lies in understanding how 'yaw' maps to Euler angles and the correct conventions for the\u003cbr\u003e`quaternion_from_euler` function.\u003cbr\u003e\u003cbr\u003eHere's a step-by-step reasoning for each document:\u003cbr\u003e\u003cbr\u003e*   **[21]** This document is highly relevant as it provides explicit code examples for `euler_from_quaternion` from the\u003cbr\u003e`tf.transformations` library, which is very likely the library or a similar one the user is employing. It directly shows\u003cbr\u003ehow to use the function, which is critical for solving the user's problem.\u003cbr\u003e*   **[18]** This document is also highly relevant because it explains how Euler angles are interpreted in the\u003cbr\u003e`tf.transformations` library, specifically highlighting the 'axes' argument using a 4-character string (e.g., 'sxyz' or\u003cbr\u003e'ryxy'). This is crucial for the user to correctly specify the yaw rotation order for `quaternion_from_euler`.\u003cbr\u003e*   **[19]** This passage directly addresses the query by stating that 'yaw, pitch, and roll' are alternative names for\u003cbr\u003eTait-Bryan angles and explicitly mentions that 'A yaw will obtain the bearing'. It also links these to the _z_\u003cbr\u003e- _y_ \u2032\u003cbr\u003e- _x_ \u2033 intrinsic rotation convention, providing the essential conceptual mapping for the user's implementation.\u003cbr\u003e*   **[23]** This document reinforces the information in [19] by explicitly listing the _z_\u003cbr\u003e- _y_ \u2032\u003cbr\u003e- _x_ \u2033 (intrinsic rotations) sequence as corresponding to 'yaw, pitch and roll'. This is key for determining the\u003cbr\u003ecorrect axis sequence argument in `quaternion_from_euler`.\u003cbr\u003e*   **[7]** This passage is relevant because it makes the direct connection that Tait\u2013Bryan angles are also called 'yaw,\u003cbr\u003epitch, and roll', which is a fundamental piece of information for the user to understand the terminology in their\u003cbr\u003econtext.\u003cbr\u003e*   **[10]** This document explains intrinsic rotations and how Euler angles (\u03b1, \u03b2, \u03b3) represent rotations around the\u003cbr\u003e_z_ , _x_ \u2032, and _z_ \u2033 axes, respectively. This helps the user understand the underlying mechanics of how individual\u003cbr\u003eangles contribute to overall rotation, which is important when specifying yaw.\u003cbr\u003e*   **[14]** This passage further clarifies the meaning of the three Euler angles by associating them with physical\u003cbr\u003emotions like precession (rotation around _z_ ), nutation (rotation around _N_ or _x_ \u2032), and intrinsic rotation (around\u003cbr\u003e_Z_ or _z_ \u2033). This helps contextualize the angles and how one might correspond to yaw.\u003cbr\u003e*   **[24]** This document defines Tait\u2013Bryan angles, highlights their use in aerospace (relevant to the user's drone\u003cbr\u003econtext), and reiterates that they represent yaw, pitch, and roll. It also mentions the _z_\u003cbr\u003e- _y_ \u2032\u003cbr\u003e- _x_ \u2033 sequence, providing reinforcing information.\u003cbr\u003e*   **[5]** This passage defines Euler angles generally and mentions Tait-Bryan angles specifically for aeronautics,\u003cbr\u003eproviding a useful foundational understanding for the user.\u003cbr\u003e*   **[6]** This document explains the concept of chained rotations and the distinction between extrinsic and intrinsic\u003cbr\u003erotations for defining Euler angles. This is relevant for a deeper understanding but less direct for the immediate\u003cbr\u003eimplementation problem.\u003cbr\u003e*   **[11]** This passage explains extrinsic rotations and provides an example sequence (z-x-z). While related to Euler\u003cbr\u003eangles, it's less direct than intrinsic rotations for the yaw\u002fpitch\u002froll context.\u003cbr\u003e*   **[12], [13]** These passages discuss the signs, ranges, and potential ambiguities (like gimbal lock) of Euler\u003cbr\u003eangles. While crucial for robust implementation, they don't directly answer how to perform a yaw rotation but rather how\u003cbr\u003eto handle its properties.\u003cbr\u003e*   **[9]** This document provides the geometrical definition of Euler angles, which is foundational but more abstract\u003cbr\u003ethan what the user needs for code implementation.\u003cbr\u003e*   **[20]** This document discusses various orientation representations (rotation matrices, axis-angle, quaternions)\u003cbr\u003eand their advantages\u002fdisadvantages. While relevant to the broader topic, it doesn't specifically address how to\u003cbr\u003eimplement yaw using Euler angles or `quaternion_from_euler`.\u003cbr\u003e*   **[16], [17]** These passages discuss rotation matrices. While quaternions can be converted from\u002fto rotation\u003cbr\u003ematrices, this information is not as direct for the user's specific `quaternion_from_euler` problem.\u003cbr\u003e*   **[25]** This passage provides functions for `rotation_matrix` and `scale_from_matrix`. While related to\u003cbr\u003etransformations, it's not specific to Euler angles or quaternions for the purpose of yaw rotation.\u003cbr\u003e*   **[2]** This is a table of contents for a Wikipedia article on Euler angles. It indicates relevant content exists\u003cbr\u003ebut does not provide the content itself.\u003cbr\u003e*   **[0], [1], [3], [4], [8], [15], [22]** These passages are entirely irrelevant, consisting of navigation links,\u003cbr\u003elanguage options, or section headers without substantive information.","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.848\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.746\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.900\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 5: 0.95; 3: 0.9; 1: 0.85; 9: 0.8; 11: 0.75; 12: 0.7; 2: 0.65; 13: 0.6; 14: 0.6; 15: 0.6; 4: 0.5; 10: 0.4; 6: 0.35; 7:\u003cbr\u003e0.2; 8: 0.2; 0: 0.1\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster provides a comprehensive guide to Tait\u2013Bryan angles, a formalism for describing 3D orientation. It details\u003cbr\u003etheir definition as rotations about three distinct axes, contrasting them with proper Euler angles. Key topics include\u003cbr\u003etheir application in aerospace (as yaw, pitch, and roll), various conventions (intrinsic\u002fextrinsic rotations, rotation\u003cbr\u003esequences, signs), alternative names (Cardan\u002fnautical angles), and their mathematical representation using rotation\u003cbr\u003ematrices. The content also covers formulas for calculating the angles from vectors and compares them to other\u003cbr\u003eorientation methods like quaternions, noting issues such as gimbal lock.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is trying to implement yaw rotation for a drone using `quaternion_from_euler` in Python and `rospy`. They\u003cbr\u003eunderstand arming and takeoff but are stuck on yaw. This indicates a need to understand what yaw means in the context of\u003cbr\u003eEuler angles (specifically Tait-Bryan angles, which are common for aircraft), how it relates to the inputs of a\u003cbr\u003equaternion conversion function, and any relevant conventions or mathematical background. The passages discuss Euler\u003cbr\u003eangles, Tait-Bryan angles, and their relation to yaw, pitch, and roll, as well as conversions to other orientation\u003cbr\u003erepresentations like quaternions. A good answer would clarify these concepts.\u003cbr\u003e\u003cbr\u003eHere's a step-by-step analysis of each document:\u003cbr\u003e\u003cbr\u003e*   **[5] Alternative names**: This document is highly relevant because it explicitly states that 'yaw, pitch, and roll'\u003cbr\u003eare alternative names for Tait-Bryan angles, particularly following the `z-y\u2032-x\u2033` (intrinsic rotations) convention. This\u003cbr\u003edirectly addresses the user's need to understand 'yaw rotation' in an aerospace context and links it to the type of\u003cbr\u003eEuler angles typically used. It also mentions quaternions but the core value is the clear definition of yaw\u002fpitch\u002froll.\u003cbr\u003e*   **[3] Conventions**: This document is very relevant as it lists the six possible sequences for Tait-Bryan angles and\u003cbr\u003eexplicitly identifies the `z-y\u2032-x\u2033` intrinsic rotations as 'yaw, pitch and roll'. This provides a direct answer\u003cbr\u003eregarding the specific sequence and naming convention for the angles the user is interested in.\u003cbr\u003e*   **[1] Tait\u2013Bryan angles**: This document introduces Tait-Bryan angles as the convention normally used for aerospace\u003cbr\u003eapplications to represent aircraft orientation. This provides crucial context for the user's problem, indicating that\u003cbr\u003eTait-Bryan angles are likely the correct conceptual framework for their drone's yaw rotation.\u003cbr\u003e*   **[9] Tait\u2013Bryan angles (mathematical derivation)**: This passage offers the mathematical formulas for calculating\u003cbr\u003eTait-Bryan angles (\u03c8, \u03b8, \u03c6). While the user uses `quaternion_from_euler` (which handles this conversion internally),\u003cbr\u003eunderstanding the underlying mathematics can be critical for debugging, correctly interpreting the angles, and ensuring\u003cbr\u003eproper rotation inputs.\u003cbr\u003e*   **[11] Conversion to other orientation representations**: This document is directly relevant because it highlights\u003cbr\u003ethat Euler angles are one way to represent orientations and that conversions to and from other conventions (like\u003cbr\u003equaternions, which the user is using with `quaternion_from_euler`) are possible. It sets the stage for understanding the\u003cbr\u003efunction the user is employing.\u003cbr\u003e*   **[12] Conversion to other orientation representations (continuation)**: This document further explains the\u003cbr\u003eadvantages of using quaternions (e.g., computationally faster, no gimbal lock) over Euler angles. This provides valuable\u003cbr\u003econtext for why the user's code might be using `quaternion_from_euler` and helps reinforce the conceptual understanding\u003cbr\u003eof different rotation representations.\u003cbr\u003e*   **[2] Definitions**: This document differentiates Tait-Bryan angles from proper Euler angles, explaining that Tait-\u003cbr\u003eBryan angles involve rotations about three distinct axes (e.g., x-y-z). This distinction is important for the user to\u003cbr\u003ecorrectly apply 'yaw, pitch, and roll', which are typically Tait-Bryan, not proper Euler angles.\u003cbr\u003e*   **[13] Rotation matrix**: This passage explains that any orientation can be achieved by composing three elemental\u003cbr\u003erotations, and how rotation matrices can be decomposed. It mentions intrinsic and extrinsic rotations, which are\u003cbr\u003efundamental to the concept of Euler angles and their conversion to quaternions (often via rotation matrices).\u003cbr\u003e*   **[14] Rotation matrix (conventions)**: This document details the conventions used for defining rotation matrices.\u003cbr\u003eUnderstanding these conventions is crucial for correctly interpreting and applying Euler angles to represent rotations,\u003cbr\u003eespecially when dealing with specific axes and directions for yaw.\u003cbr\u003e*   **[15] Rotation matrix (table)**: This document provides a table of matrix products for both Proper Euler angles and\u003cbr\u003eTait-Bryan angles. This is the underlying mathematical representation of the rotations, which can be invaluable for\u003cbr\u003eadvanced understanding or debugging the inputs to `quaternion_from_euler`.\u003cbr\u003e*   **[4] Signs and ranges**: This document discusses the signs and ranges for Tait-Bryan angles. While not directly\u003cbr\u003eexplaining 'how to do yaw', it provides important practical considerations for correctly implementing yaw rotation, as\u003cbr\u003eincorrect signs or out-of-range values can lead to unexpected behavior.\u003cbr\u003e*   **[10] Last remarks**: This passage mentions using `atan2` for computational purposes in Euler angle calculations.\u003cbr\u003eThis is a useful practical tip for robust implementation, addressing potential ambiguities in `arcsin`\u002f`arccos`\u003cbr\u003efunctions, which could be relevant for precise yaw control.\u003cbr\u003e*   **[6] Angles of a given frame**: This document discusses finding Euler angles of a given frame and mentions `ZYX`\u003cbr\u003efor Tait-Bryan angles. It offers some contextual information but is less direct in explaining how to apply a specific\u003cbr\u003eyaw rotation using `quaternion_from_euler`.\u003cbr\u003e*   **[7] Proper Euler angles**: This document focuses on the mathematical derivation of 'proper Euler angles'. While\u003cbr\u003erelated to Euler angles, proper Euler angles are generally distinct from the 'yaw, pitch, roll' (Tait-Bryan) convention\u003cbr\u003ecommon in aerospace, making this less directly applicable to the user's specific problem.\u003cbr\u003e*   **[8] Proper Euler angles (continuation)**: This document continues the mathematical derivation for proper Euler\u003cbr\u003eangles, which is less directly relevant for the same reasons as [7].\u003cbr\u003e*   **[0] Unsupported_attributions**: This document discusses general concepts of frames and gimbals. It is too general\u003cbr\u003eand does not provide specific details on how to perform yaw rotation or any information relevant to the user's Python\u003cbr\u003ecode or drone context.","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.839\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.728\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.880\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 12: 0.4; 6: 0.1; 0: 0.05; 1: 0.05; 2: 0.05; 3: 0.05; 4: 0.05; 5: 0; 7: 0.0; 8: 0.0; 9: 0.0; 10: 0.0; 11: 0.0; 13: 0.0;\u003cbr\u003e14: 0.0; 15: 0.0\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis section provides a comprehensive overview of Euler angles, covering their mathematical definitions, theoretical\u003cbr\u003eproperties, and practical applications. It includes tables of explicit 3x3 rotation matrices for various conventions\u003cbr\u003e(e.g., ZXZ, ZYX, YXY, YXZ) and the corresponding inverse formulas to calculate the angles (\u03b1, \u03b2, \u03b3) from matrix\u003cbr\u003eelements. The theoretical discussion explores Euler angles in the context of group theory (SO(3), SU(2), Spin(3)), their\u003cbr\u003egeneralization to higher dimensions (SO(n)), and their relationship to quaternions and geometric algebra. Key\u003cbr\u003eapplications detailed include rigid body dynamics (vehicles, gyroscopes, gimbal lock), materials science\u003cbr\u003e(crystallographic texture, Bunge convention), robotics (Tait-Bryan convention), gun fire control systems, and quantum\u003cbr\u003emechanics.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is trying to implement a yaw rotation for a drone using `mavros` and Python. They have provided code that uses\u003cbr\u003e`quaternion_from_euler(0.0,0.0,3.0)` to set a position and orientation, and their core problem is to understand how to\u003cbr\u003eperform yaw rotation. This implies they need to know which parameter in their `quaternion_from_euler` call corresponds\u003cbr\u003eto yaw, and the general conventions for Euler angles in an aerospace context.\u003cbr\u003e\u003cbr\u003e**Passage [21]** is highly relevant because it provides a direct example from the `tf.transformations` library (which is\u003cbr\u003ecommonly used in ROS) for `euler_matrix`. It explicitly states that the parameters `ai, aj, ak` correspond to 'Euler\u2019s\u003cbr\u003eroll, pitch and yaw angles'. This directly answers how to map input angles to roll, pitch, and yaw, which is crucial for\u003cbr\u003ethe user's `quaternion_from_euler` function.\u003cbr\u003e\u003cbr\u003e**Passage [19]** is also very relevant as it defines Tait-Bryan angles, which are typically used in aerospace, as 'yaw,\u003cbr\u003epitch, and roll'. It specifically links 'yaw' to 'bearing' and mentions the `z-y'-x''` intrinsic rotation sequence,\u003cbr\u003eproviding the conceptual framework for understanding the angles in the user's drone application.\u003cbr\u003e\u003cbr\u003e**Passage [23]** reinforces the information in [19] by listing different Euler angle conventions and explicitly stating\u003cbr\u003ethat the `z-y'-x''` intrinsic rotation sequence is known as 'yaw, pitch and roll'. This is key for understanding the\u003cbr\u003eorder of angles.\u003cbr\u003e\u003cbr\u003e**Passage [18]** introduces the `transformations` Python library, which handles conversions between Euler angles and\u003cbr\u003equaternions. Crucially, it explains that Euler angles can be interpreted in 24 ways, depending on the 'axes' sequence\u003cbr\u003e('sxyz', 'ryxy', etc.). This is important context for the user to correctly interpret their `quaternion_from_euler` call\u003cbr\u003eand ensure they are manipulating the correct angle for yaw.\u003cbr\u003e\u003cbr\u003e**Passage [24]** further supports the relevance of Tait-Bryan angles by stating they are 'normally used for aerospace\u003cbr\u003eapplications' for 'yaw, pitch, and roll', solidifying the contextual understanding for the user.\u003cbr\u003e\u003cbr\u003e**Passage [20]** provides useful background information by discussing the advantages of quaternions over Euler angles\u003cbr\u003e(e.g., avoiding gimbal lock). While not a direct solution to 'how to do yaw', it explains why the user might be using\u003cbr\u003equaternions.\u003cbr\u003e\u003cbr\u003e**Passage [12]** gives general context about Euler angles in 'vehicles and moving frames' and mentions 'gimbal lock'.\u003cbr\u003eIt's less specific than others but offers some related information.\u003cbr\u003e\u003cbr\u003e**Passages [16]** and **[17]** discuss rotation matrices and their decomposition. While related to rotations, the user\u003cbr\u003eis already working with `quaternion_from_euler`, implying they are past the stage of manually constructing rotation\u003cbr\u003ematrices. These passages are too foundational and don't directly address how to *do* yaw rotation with their existing\u003cbr\u003esetup.\u003cbr\u003e\u003cbr\u003e**Passage [6]** discusses theoretical properties of Euler angles, such as their chart on SO(3). This is too abstract for\u003cbr\u003ethe user's practical coding problem.\u003cbr\u003e\u003cbr\u003e**Passages [0], [1], [2], [3], [4]** present complex mathematical formulas for rotation matrices and various Euler angle\u003cbr\u003esequences. These are overly technical and do not provide specific guidance on how to manipulate a yaw angle within the\u003cbr\u003euser's `quaternion_from_euler` function.\u003cbr\u003e\u003cbr\u003e**Passages [7], [8], [9], [10], [11], [13], [14], [15], [25]** are irrelevant. They discuss topics like Haar measure,\u003cbr\u003egeometric algebra, higher dimensions, or specific applications (crystallographic texture) that do not directly help the\u003cbr\u003euser implement yaw rotation.\u003cbr\u003e\u003cbr\u003e**Passage [22]** is merely a section heading and provides no content.","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.570\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.189\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.300\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains supplementary materials and concluding sections for a resource on Euler angles. It includes\u003cbr\u003eacademic references, a bibliography of textbooks, and external links to tools, tutorials, and encyclopedias.\u003cbr\u003eAdditionally, it lists related mathematical concepts such as quaternions, gimbal lock, and 3D rotation formalisms, and\u003cbr\u003eprovides Wikipedia-specific metadata like article categories (e.g., 'Rotation in three dimensions') and standard footer\u003cbr\u003enavigation.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 4, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.013\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e# A representation of pose in free space, composed of position and orientation.\u003cbr\u003ePoint position\u003cbr\u003eQuaternion orientation\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.900\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.831\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e 11: 0.95; 0: 0.9; 7: 0.8; 1: 0.75; 12: 0.7; 10: 0.65; 6: 0.55; 15: 0.5; 5: 0.45; 2: 0.3; 14: 0.25; 13: 0.2; 8: 0.1; 3:\u003cbr\u003e0.05; 4: 0.05; 9: 0.05\u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis topic provides a comprehensive guide to the `tf.transformations` Python library, which focuses on 3D spatial\u003cbr\u003etransformations using `Numpy`. It covers the creation and analysis of 4x4 homogeneous transformation matrices for\u003cbr\u003eoperations such as rotation, translation, scaling, shearing, reflection, and projection. A core feature is the robust\u003cbr\u003esupport for converting between different 3D rotation representations, including matrices, quaternions, and Euler angles,\u003cbr\u003ewith functions like `euler_from_matrix`, `quaternion_from_matrix`, and `quaternion_matrix`. The library also includes\u003cbr\u003efunctions for high-level matrix manipulation (`compose_matrix`, `decompose_matrix`, `concatenate_matrices`) and provides\u003cbr\u003ean `Arcball` class for implementing interactive virtual trackball controls.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003eThe user is trying to perform a yaw rotation using `quaternion_from_euler` in a `mavros` setup and is looking for\u003cbr\u003eguidance. The key aspects are understanding Euler angles, quaternions, their conversions, and how to apply yaw.\u003cbr\u003e\u003cbr\u003e- **[11]** This document is highly relevant as it directly defines and provides an example for\u003cbr\u003e`tf.transformations.quaternion_from_euler`, which is the exact function the user is struggling with. It shows how to use\u003cbr\u003eEuler angles (roll, pitch, yaw) to generate a quaternion.\u003cbr\u003e\u003cbr\u003e- **[0]** This passage provides the essential context for the `tf.transformations` library, which is the source of\u003cbr\u003e`quaternion_from_euler`. It explains that the library handles conversions between rotation matrices, Euler angles, and\u003cbr\u003equaternions, clarifies the quaternion representation `[x, y, z, w]`, and discusses how Euler angles can be applied\u003cbr\u003e('sxyz', 'rxyz', etc.), which is critical for correctly interpreting roll, pitch, and yaw.\u003cbr\u003e\u003cbr\u003e- **[7]** This passage is relevant because it covers `tf.transformations.euler_from_quaternion` (the inverse operation)\u003cbr\u003eand `tf.transformations.euler_matrix`. Understanding `euler_matrix` helps in comprehending how Euler angles translate\u003cbr\u003einto a rotation, directly aiding the user's goal of implementing yaw.\u003cbr\u003e\u003cbr\u003e- **[1]** This document offers practical examples of using various rotation and transformation functions from the\u003cbr\u003e`tf.transformations` library. It demonstrates `euler_from_matrix`, `quaternion_about_axis`, `quaternion_multiply`, and\u003cbr\u003e`quaternion_matrix`, which are all integral to working with Euler angles and quaternions for rotation.\u003cbr\u003e\u003cbr\u003e- **[12]** This passage defines `tf.transformations.quaternion_matrix` and `tf.transformations.quaternion_multiply`.\u003cbr\u003e`quaternion_matrix` is crucial as the resulting quaternion from `quaternion_from_euler` would often be converted to a\u003cbr\u003erotation matrix for application, especially in `PoseStamped` messages. `quaternion_multiply` is fundamental for\u003cbr\u003ecombining successive rotations.\u003cbr\u003e\u003cbr\u003e- **[10]** This document defines `tf.transformations.quaternion_about_axis`. This function provides an alternative,\u003cbr\u003efundamental way to create a quaternion for rotation about a specific axis (e.g., the Z-axis for yaw), offering another\u003cbr\u003eperspective or method for the user to achieve their goal.\u003cbr\u003e\u003cbr\u003e- **[6]** This passage defines `tf.transformations.euler_from_matrix`. While not directly about creating a quaternion,\u003cbr\u003eunderstanding how to extract Euler angles from a rotation matrix can be useful for debugging or verifying the applied\u003cbr\u003eyaw.\u003cbr\u003e\u003cbr\u003e- **[15]** This passage defines `tf.transformations.rotation_matrix`. This is a general function for creating a rotation\u003cbr\u003ematrix from an angle and a direction. Although the user is specifically using quaternions, the underlying concept of\u003cbr\u003erotation matrices is fundamental and related to their task.\u003cbr\u003e\u003cbr\u003e- **[5]** This passage defines `tf.transformations.compose_matrix`, `concatenate_matrices`, and `decompose_matrix`.\u003cbr\u003eThese functions are useful for combining and breaking down complex transformations, which might become necessary if the\u003cbr\u003euser needs to apply multiple rotations or transformations.\u003cbr\u003e\u003cbr\u003e- **[2]** This passage continues the examples from [1], providing more demonstrations of transformation functions.\u003cbr\u003eHowever, a significant portion introduces the `Arcball` class, which is less directly relevant to the user's specific\u003cbr\u003eproblem of programmatic yaw rotation.\u003cbr\u003e\u003cbr\u003e- **[14]** This passage defines `tf.transformations.rotation_from_matrix`. Similar to `euler_from_matrix`, it shows how\u003cbr\u003eto extract rotation parameters (angle and direction) from a matrix, but it's less direct to the user's problem of\u003cbr\u003esetting yaw using Euler angles and quaternions.\u003cbr\u003e\u003cbr\u003e- **[13]** This passage defines `tf.transformations.quaternion_slerp`, `random_quaternion`, and\u003cbr\u003e`random_rotation_matrix`. `quaternion_slerp` could be relevant for smooth rotational transitions, but the random\u003cbr\u003efunctions are not directly related to achieving a specific yaw rotation.\u003cbr\u003e\u003cbr\u003e- **[8]** This passage describes general matrix utility functions like `identity_matrix`, `inverse_matrix`,\u003cbr\u003e`is_same_transform`, and `orthogonalization_matrix`. These are not directly related to the user's problem of yaw\u003cbr\u003erotation using Euler angles and quaternions.\u003cbr\u003e\u003cbr\u003e- **[3]**, **[4]**, **[9]** These passages describe `Arcball` methods, `arcball` helper functions, `clip_matrix`, and\u003cbr\u003e`projection_matrix`. These topics are entirely unrelated to yaw rotation, Euler angles, or quaternions, and thus are\u003cbr\u003eirrelevant to the user's query.","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.688\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.408\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.500\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eThis cluster contains reference documentation for the `tf.transformations` Python library, detailing functions for 3D\u003cbr\u003egeometric transformations and vector math. It provides function definitions and code examples for creating\u003cbr\u003etransformation matrices like `scale_matrix`, `shear_matrix`, and `translation_matrix`, as well as advanced functions\u003cbr\u003elike `superimposition_matrix` for aligning vector sets. It also covers utility functions for vector operations such as\u003cbr\u003e`unit_vector` and `vector_norm`.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.014\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eJump to content\u003cbr\u003e\u003cbr\u003eMain menu\u003cbr\u003e\u003cbr\u003eMain menu\u003cbr\u003e\u003cbr\u003emove to sidebar  hide\u003cbr\u003e\u003cbr\u003eNavigation\u003cbr\u003e\u003cbr\u003e  * [ Main page  ](\u002fwiki\u002fMain_Page \"Visit the main page \\[z\\]\")\u003cbr\u003e  * [ Contents  ](\u002fwiki\u002fWikipedia:Contents \"Guides to browsing Wikipedia\")\u003cbr\u003e  * [ Current events  ](\u002fwiki\u002fPortal:Current_events \"Articles related to current events\")\u003cbr\u003e  * [ Random article  ](\u002fwiki\u002fSpecial:Random \"Visit a randomly selected article \\[x\\]\")\u003cbr\u003e  * [ About Wikipedia  ](\u002fwiki\u002fWikipedia:About \"Learn about Wikipedia and how it works\")\u003cbr\u003e  * [ Contact us  ](\u002f\u002fen.wikipedia.org\u002fwiki\u002fWikipedia:Contact_us \"How to contact Wikipedia\")\u003cbr\u003e  * [ Donate  ](https:\u002f\u002fdonate.wikimedia.org\u002fwiki\u002fSpecial:FundraiserRedirector?utm_source=donate&utm_medium=sidebar&utm_\u003cbr\u003ecampaign=C13_en.wikipedia.org&uselang=en \"Support us by donating to the Wikimedia Foundation\")\u003cbr\u003e\u003cbr\u003eContribute\u003cbr\u003e\u003cbr\u003e  * [ Help  ](\u002fwiki\u002fHelp:Contents \"Guidance on how to use and edit Wikipedia\")\u003cbr\u003e  * [ Learn to edit  ](\u002fwiki\u002fHelp:Introduction \"Learn how to edit Wikipedia\")\u003cbr\u003e  * [ Community portal  ](\u002fwiki\u002fWikipedia:Community_portal \"The hub for editors\")\u003cbr\u003e  * [ Recent changes  ](\u002fwiki\u002fSpecial:RecentChanges \"A list of recent changes to Wikipedia \\[r\\]\")\u003cbr\u003e  * [ Upload file  ](\u002fwiki\u002fWikipedia:File_upload_wizard \"Add images or other media for use on Wikipedia\")\u003cbr\u003e\u003cbr\u003e[ ![](\u002fstatic\u002fimages\u002ficons\u002fwikipedia.png)\u003cbr\u003e![Wikipedia](\u002fstatic\u002fimages\u002fmobile\u002fcopyright\u002fwikipedia-wordmark-en.svg) ![The\u003cbr\u003eFree Encyclopedia](\u002fstatic\u002fimages\u002fmobile\u002fcopyright\u002fwikipedia-tagline-en.svg)\u003cbr\u003e](\u002fwiki\u002fMain_Page)\u003cbr\u003e\u003cbr\u003e[ Search  ](\u002fwiki\u002fSpecial:Search \"Search Wikipedia \\[f\\]\")\u003cbr\u003e\u003cbr\u003eSearch\u003cbr\u003e\u003cbr\u003e  * [ Create account  ](\u002fw\u002findex.php?title=Special:CreateAccount&returnto=Euler+angles \"You are encouraged to create an\u003cbr\u003eaccount and log in; however, it is not mandatory\")\u003cbr\u003e  * [ Log in  ](\u002fw\u002findex.php?title=Special:UserLogin&returnto=Euler+angles \"You're encouraged to log in; however, it's\u003cbr\u003enot mandatory. \\[o\\]\")\u003cbr\u003e\u003cbr\u003ePersonal tools\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.014\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  * [ Create account  ](\u002fw\u002findex.php?title=Special:CreateAccount&returnto=Euler+angles \"You are encouraged to create an\u003cbr\u003eaccount and log in; however, it is not mandatory\")\u003cbr\u003e  * [ Log in  ](\u002fw\u002findex.php?title=Special:UserLogin&returnto=Euler+angles \"You're encouraged to log in; however, it's\u003cbr\u003enot mandatory. \\[o\\]\")\u003cbr\u003e\u003cbr\u003ePages for logged out editors [ learn more  ](\u002fwiki\u002fHelp:Introduction)\u003cbr\u003e\u003cbr\u003e  * [ Contributions  ](\u002fwiki\u002fSpecial:MyContributions \"A list of edits made from this IP address \\[y\\]\")\u003cbr\u003e  * [ Talk  ](\u002fwiki\u002fSpecial:MyTalk \"Discussion about edits from this IP address \\[n\\]\")\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.033\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.033\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Contents\u003cbr\u003e\u003cbr\u003emove to sidebar  hide\u003cbr\u003e\u003cbr\u003e  * (Top)\u003cbr\u003e  * 1  Chained rotations equivalence\u003cbr\u003e  * 2  Classic Euler angles  Toggle Classic Euler angles subsection\u003cbr\u003e    * 2.1  Geometrical definition\u003cbr\u003e    * 2.2  Conventions by intrinsic rotations\u003cbr\u003e    * 2.3  Conventions by extrinsic rotations\u003cbr\u003e    * 2.4  Signs, ranges and conventions\u003cbr\u003e    * 2.5  Precession, nutation and intrinsic rotation\u003cbr\u003e  * 3  Tait\u2013Bryan angles  Toggle Tait\u2013Bryan angles subsection\u003cbr\u003e    * 3.1  Definitions\u003cbr\u003e    * 3.2  Conventions\u003cbr\u003e    * 3.3  Signs and ranges\u003cbr\u003e    * 3.4  Alternative names\u003cbr\u003e  * 4  Angles of a given frame  Toggle Angles of a given frame subsection\u003cbr\u003e    * 4.1  Proper Euler angles\u003cbr\u003e    * 4.2  Tait\u2013Bryan angles\u003cbr\u003e    * 4.3  Last remarks\u003cbr\u003e  * 5  Conversion to other orientation representations  Toggle Conversion to other orientation representations\u003cbr\u003esubsection\u003cbr\u003e    * 5.1  Rotation matrix\u003cbr\u003e  * 6  Properties  Toggle Properties subsection\u003cbr\u003e    * 6.1  Geometric algebra\u003cbr\u003e    * 6.2  Higher dimensions\u003cbr\u003e  * 7  Applications  Toggle Applications subsection\u003cbr\u003e    * 7.1  Vehicles and moving frames\u003cbr\u003e    * 7.2  Crystallographic texture\u003cbr\u003e    * 7.3  Others\u003cbr\u003e  * 8  See also\u003cbr\u003e  * 9  References\u003cbr\u003e  * 10  Bibliography\u003cbr\u003e  * 11  External links\u003cbr\u003e\u003cbr\u003eToggle the table of contents\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.014\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Euler angles\u003cbr\u003e\u003cbr\u003e29 languages\u003cbr\u003e\u003cbr\u003e  * [ \u0627\u0644\u0639\u0631\u0628\u064a\u0629  ](https:\u002f\u002far.wikipedia.org\u002fwiki\u002f%D8%B2%D9%88%D8%A7%D9%8A%D8%A7_%D8%A3%D9%88%D9%8A%D9%84%D8%B1 \"\u0632\u0648\u0627\u064a\u0627\u003cbr\u003e\u0623\u0648\u064a\u0644\u0631 \u2013 Arabic\")\u003cbr\u003e  * [ Catal\u00e0  ](https:\u002f\u002fca.wikipedia.org\u002fwiki\u002fAngles_d%27Euler \"Angles d'Euler \u2013 Catalan\")\u003cbr\u003e  * [ Deutsch  ](https:\u002f\u002fde.wikipedia.org\u002fwiki\u002fEulersche_Winkel \"Eulersche Winkel \u2013 German\")\u003cbr\u003e  * [ \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac  ](https:\u002f\u002fel.wikipedia.org\u002fwiki\u002f%CE%93%CF%89%CE%BD%CE%AF%CE%B5%CF%82_%CE%8C%CE%B9%CE%BB%CE%B5%CF%81\u003cbr\u003e\"\u0393\u03c9\u03bd\u03af\u03b5\u03c2 \u038c\u03b9\u03bb\u03b5\u03c1 \u2013 Greek\")\u003cbr\u003e  * [ Espa\u00f1ol  ](https:\u002f\u002fes.wikipedia.org\u002fwiki\u002f%C3%81ngulos_de_Euler \"\u00c1ngulos de Euler \u2013 Spanish\")\u003cbr\u003e  * [ Euskara  ](https:\u002f\u002feu.wikipedia.org\u002fwiki\u002fEulerren_angeluak \"Eulerren angeluak \u2013 Basque\")\u003cbr\u003e  * [ \u0641\u0627\u0631\u0633\u06cc\u003cbr\u003e](https:\u002f\u002ffa.wikipedia.org\u002fwiki\u002f%D8%B2%D8%A7%D9%88%DB%8C%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%A7%D9%88%DB%8C%D9%84%D8%B1\u003cbr\u003e\"\u0632\u0627\u0648\u06cc\u0647\u200c\u0647\u0627\u06cc \u0627\u0648\u06cc\u0644\u0631 \u2013 Persian\")\u003cbr\u003e  * [ Fran\u00e7ais  ](https:\u002f\u002ffr.wikipedia.org\u002fwiki\u002fAngles_d%27Euler \"Angles d'Euler \u2013 French\")\u003cbr\u003e  * [ Gaeilge  ](https:\u002f\u002fga.wikipedia.org\u002fwiki\u002fNa_huillinneacha_Euler \"Na huillinneacha Euler \u2013 Irish\")\u003cbr\u003e  * [ \ud55c\uad6d\uc5b4  ](https:\u002f\u002fko.wikipedia.org\u002fwiki\u002f%EC%98%A4%EC%9D%BC%EB%9F%AC_%EA%B0%81 \"\uc624\uc77c\ub7ec \uac01 \u2013 Korean\")\u003cbr\u003e  * [ Bahasa Indonesia  ](https:\u002f\u002fid.wikipedia.org\u002fwiki\u002fSudut_Euler \"Sudut Euler \u2013 Indonesian\")\u003cbr\u003e  * [ Italiano  ](https:\u002f\u002fit.wikipedia.org\u002fwiki\u002fAngoli_di_Eulero \"Angoli di Eulero \u2013 Italian\")\u003cbr\u003e  * [ \u05e2\u05d1\u05e8\u05d9\u05ea  ](https:\u002f\u002fhe.wikipedia.org\u002fwiki\u002f%D7%96%D7%95%D7%95%D7%99%D7%95%D7%AA_%D7%90%D7%95%D7%99%D7%9C%D7%A8 \"\u05d6\u05d5\u05d5\u05d9\u05d5\u05ea\u003cbr\u003e\u05d0\u05d5\u05d9\u05dc\u05e8 \u2013 Hebrew\")\u003cbr\u003e  * [ \u049a\u0430\u0437\u0430\u049b\u0448\u0430\u003cbr\u003e](https:\u002f\u002fkk.wikipedia.org\u002fwiki\u002f%D0%AD%D0%B9%D0%BB%D0%B5%D1%80_%D0%B1%D2%B1%D1%80%D1%8B%D1%88%D1%82%D0%B0%D1%80%D1%8B\u003cbr\u003e\"\u042d\u0439\u043b\u0435\u0440 \u0431\u04b1\u0440\u044b\u0448\u0442\u0430\u0440\u044b \u2013 Kazakh\")\u003cbr\u003e  * [ Magyar  ](https:\u002f\u002fhu.wikipedia.org\u002fwiki\u002fEuler-sz%C3%B6gek \"Euler-sz\u00f6gek \u2013 Hungarian\")\u003cbr\u003e  * [ Nederlands  ](https:\u002f\u002fnl.wikipedia.org\u002fwiki\u002fHoeken_van_Euler \"Hoeken van Euler \u2013 Dutch\")\u003cbr\u003e  * [ \u65e5\u672c\u8a9e  ](https:\u002f\u002fja.wikipedia.org\u002fwiki\u002f%E3%82%AA%E3%82%A4%E3%83%A9%E3%83%BC%E8%A7%92 \"\u30aa\u30a4\u30e9\u30fc\u89d2 \u2013 Japanese\")\u003cbr\u003e  * [ Norsk bokm\u00e5l  ](https:\u002f\u002fno.wikipedia.org\u002fwiki\u002fEulervinkler \"Eulervinkler \u2013 Norwegian Bokm\u00e5l\")\u003cbr\u003e  * [ Polski  ](https:\u002f\u002fpl.wikipedia.org\u002fwiki\u002fK%C4%85ty_Eulera \"K\u0105ty Eulera \u2013 Polish\")\u003cbr\u003e  * [ Portugu\u00eas  ](https:\u002f\u002fpt.wikipedia.org\u002fwiki\u002f%C3%82ngulos_de_Euler \"\u00c2ngulos de Euler \u2013 Portuguese\")\u003cbr\u003e  * [ Rom\u00e2n\u0103  ](https:\u002f\u002fro.wikipedia.org\u002fwiki\u002fUnghiurile_lui_Euler \"Unghiurile lui Euler \u2013 Romanian\")\u003cbr\u003e  * [ \u0420\u0443\u0441\u0441\u043a\u0438\u0439  ](https:\u002f\u002fru.wikipedia.org\u002fwiki\u002f%D0%A3%D0%B3%D0%BB%D1%8B_%D0%AD%D0%B9%D0%BB%D0%B5%D1%80%D0%B0 \"\u0423\u0433\u043b\u044b\u003cbr\u003e\u042d\u0439\u043b\u0435\u0440\u0430 \u2013 Russian\")\u003cbr\u003e  * [ Sloven\u0161\u010dina  ](https:\u002f\u002fsl.wikipedia.org\u002fwiki\u002fEulerjevi_koti \"Eulerjevi koti \u2013 Slovenian\")\u003cbr\u003e  * [ \u0421\u0440\u043f\u0441\u043a\u0438 \u002f srpski  ](https:\u002f\u002fsr.wikipedia.org\u002fwiki\u002f%D0%9E%D1%98%D0%BB%D0%B5%D1%80%D0%BE%D0%B2%D0%B8_%D0%B8_%D0%A2%D0\u003cbr\u003e%B5%D1%98%D1%82-%D0%91%D1%80%D0%B0%D1%98%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8_%D1%83%D0%B3%D0%BB%D0%BE%D0%B2%D0%B8 \"\u041e\u0458\u043b\u0435\u0440\u043e\u0432\u0438 \u0438\u003cbr\u003e\u0422\u0435\u0458\u0442-\u0411\u0440\u0430\u0458\u0430\u043d\u043e\u0432\u0438 \u0443\u0433\u043b\u043e\u0432\u0438 \u2013 Serbian\")\u003cbr\u003e  * [ Svenska  ](https:\u002f\u002fsv.wikipedia.org\u002fwiki\u002fEulervinklar \"Eulervinklar \u2013 Swedish\")\u003cbr\u003e  * [ \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430\u003cbr\u003e](https:\u002f\u002fuk.wikipedia.org\u002fwiki\u002f%D0%95%D0%B9%D0%BB%D0%B5%D1%80%D0%BE%D0%B2%D1%96_%D0%BA%D1%83%D1%82%D0%B8 \"\u0415\u0439\u043b\u0435\u0440\u043e\u0432\u0456 \u043a\u0443\u0442\u0438\u003cbr\u003e\u2013 Ukrainian\")\u003cbr\u003e  * [ Ti\u1ebfng Vi\u1ec7t  ](https:\u002f\u002fvi.wikipedia.org\u002fwiki\u002fG%C3%B3c_Euler \"G\u00f3c Euler \u2013 Vietnamese\")\u003cbr\u003e  * [ \u7cb5\u8a9e  ](https:\u002f\u002fzh-yue.wikipedia.org\u002fwiki\u002f%E6%AD%90%E6%8B%89%E8%A7%92 \"\u6b50\u62c9\u89d2 \u2013 Cantonese\")\u003cbr\u003e  * [ \u4e2d\u6587  ](https:\u002f\u002fzh.wikipedia.org\u002fwiki\u002f%E6%AC%A7%E6%8B%89%E8%A7%92 \"\u6b27\u62c9\u89d2 \u2013 Chinese\")\u003cbr\u003e\u003cbr\u003e[ Edit links\u003cbr\u003e](https:\u002f\u002fwww.wikidata.org\u002fwiki\u002fSpecial:EntityPage\u002fQ751290\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 4)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.014\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003esitelinks-wikipedia\u003cbr\u003e\"Edit interlanguage links\")\u003cbr\u003e\u003cbr\u003e  * [ Article  ](\u002fwiki\u002fEuler_angles \"View the content page \\[c\\]\")\u003cbr\u003e  * [ Talk  ](\u002fwiki\u002fTalk:Euler_angles \"Discuss improvements to the content page \\[t\\]\")\u003cbr\u003e\u003cbr\u003eEnglish\u003cbr\u003e\u003cbr\u003e  * [ Read  ](\u002fwiki\u002fEuler_angles)\u003cbr\u003e  * [ Edit  ](\u002fw\u002findex.php?title=Euler_angles&action=edit \"Edit this page \\[e\\]\")\u003cbr\u003e  * [ View history  ](\u002fw\u002findex.php?title=Euler_angles&action=history \"Past revisions of this page \\[h\\]\")\u003cbr\u003e\u003cbr\u003eTools\u003cbr\u003e\u003cbr\u003eTools\u003cbr\u003e\u003cbr\u003emove to sidebar  hide\u003cbr\u003e\u003cbr\u003eActions\u003cbr\u003e\u003cbr\u003e  * [ Read  ](\u002fwiki\u002fEuler_angles)\u003cbr\u003e  * [ Edit  ](\u002fw\u002findex.php?title=Euler_angles&action=edit \"Edit this page \\[e\\]\")\u003cbr\u003e  * [ View history  ](\u002fw\u002findex.php?title=Euler_angles&action=history)\u003cbr\u003e\u003cbr\u003eGeneral\u003cbr\u003e\u003cbr\u003e  * [ What links here  ](\u002fwiki\u002fSpecial:WhatLinksHere\u002fEuler_angles \"List of all English Wikipedia pages containing links\u003cbr\u003eto this page \\[j\\]\")\u003cbr\u003e  * [ Related changes  ](\u002fwiki\u002fSpecial:RecentChangesLinked\u002fEuler_angles \"Recent changes in pages linked from this page\u003cbr\u003e\\[k\\]\")\u003cbr\u003e  * [ Upload file  ](\u002fwiki\u002fWikipedia:File_Upload_Wizard \"Upload files \\[u\\]\")\u003cbr\u003e  * [ Special pages  ](\u002fwiki\u002fSpecial:SpecialPages \"A list of all special pages \\[q\\]\")\u003cbr\u003e  * [ Permanent link  ](\u002fw\u002findex.php?title=Euler_angles&oldid=1218886199 \"Permanent link to this revision of this page\")\u003cbr\u003e  * [ Page information  ](\u002fw\u002findex.php?title=Euler_angles&action=info \"More information about this page\")\u003cbr\u003e  * [ Cite this page\u003cbr\u003e](\u002fw\u002findex.php?title=Special:CiteThisPage&page=Euler_angles&id=1218886199&wpFormIdentifier=titleform \"Information on how\u003cbr\u003eto cite this page\")\u003cbr\u003e  * [ Get shortened URL\u003cbr\u003e](\u002fw\u002findex.php?title=Special:UrlShortener&url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FEuler_angles)\u003cbr\u003e  * [ Download QR code  ](\u002fw\u002findex.php?title=Special:QrCode&url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FEuler_angles)\u003cbr\u003e  * [ Wikidata item  ](https:\u002f\u002fwww.wikidata.org\u002fwiki\u002fSpecial:EntityPage\u002fQ751290 \"Structured data on this page hosted by\u003cbr\u003eWikidata \\[g\\]\")\u003cbr\u003e\u003cbr\u003ePrint\u002fexport\u003cbr\u003e\u003cbr\u003e  * [ Download as PDF  ](\u002fw\u002findex.php?title=Special:DownloadAsPdf&page=Euler_angles&action=show-download-screen\u003cbr\u003e\"Download this page as a PDF file\")\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 5)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.640\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.380\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.500\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  * [ Printable version  ](\u002fw\u002findex.php?title=Euler_angles&printable=yes \"Printable version of this page \\[p\\]\")\u003cbr\u003e\u003cbr\u003eIn other projects\u003cbr\u003e\u003cbr\u003e  * [ Wikimedia Commons  ](https:\u002f\u002fcommons.wikimedia.org\u002fwiki\u002fEuler_angles)\u003cbr\u003e\u003cbr\u003eFrom Wikipedia, the free encyclopedia\u003cbr\u003e\u003cbr\u003eDescription of the orientation of a rigid body\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002fa\u002fa1\u002fEulerangles.svg\u002f300px-\u003cbr\u003eEulerangles.svg.png) ](\u002fwiki\u002fFile:Eulerangles.svg) Classic Euler angles\u003cbr\u003egeometrical definition.\u003cbr\u003e\u003cbr\u003eFixed coordinate system (  x, y, z  )\u003cbr\u003e\u003cbr\u003eRotated coordinate system (  X, Y, Z  )\u003cbr\u003e\u003cbr\u003e[ Line of nodes ](\u002fwiki\u002fLine_of_nodes \"Line of nodes\") (  N  )\u003cbr\u003e\u003cbr\u003eThe **Euler angles** are three angles introduced by [ Leonhard Euler\u003cbr\u003e](\u002fwiki\u002fLeonhard_Euler \"Leonhard Euler\") to describe the [ orientation\u003cbr\u003e](\u002fwiki\u002fOrientation_\\(geometry\\) \"Orientation \\(geometry\\)\") of a [ rigid body\u003cbr\u003e](\u002fwiki\u002fRigid_body \"Rigid body\") with respect to a fixed [ coordinate system\u003cbr\u003e](\u002fwiki\u002fCoordinate_system \"Coordinate system\") .  [1]\u003cbr\u003e\u003cbr\u003eThey can also represent the orientation of a mobile [ frame of reference\u003cbr\u003e](\u002fwiki\u002fFrame_of_reference \"Frame of reference\") in physics or the orientation\u003cbr\u003eof a general [ basis ](\u002fwiki\u002fBasis_\\(linear_algebra\\) \"Basis \\(linear\u003cbr\u003ealgebra\\)\") in 3-dimensional [ linear algebra ](\u002fwiki\u002fLinear_algebra \"Linear\u003cbr\u003ealgebra\") .\u003cbr\u003e\u003cbr\u003eClassic Euler angles usually take the inclination angle in such a way that\u003cbr\u003ezero degrees represent the vertical orientation. Alternative forms were later\u003cbr\u003eintroduced by [ Peter Guthrie Tait ](\u002fwiki\u002fPeter_Guthrie_Tait \"Peter Guthrie\u003cbr\u003eTait\") and [ George H. Bryan ](\u002fwiki\u002fGeorge_H._Bryan \"George H. Bryan\")\u003cbr\u003eintended for use in aeronautics and engineering in which zero degrees\u003cbr\u003erepresent the horizontal position.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 6)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.680\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.461\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.400\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Chained rotations equivalence  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=1 \"Edit section: Chained\u003cbr\u003erotations equivalence\") ]\u003cbr\u003e\u003cbr\u003e[ ![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f8\u002f85\u002fEuler2a.gif\u002f170px-\u003cbr\u003eEuler2a.gif) ](\u002fwiki\u002fFile:Euler2a.gif)\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f4\u002f4a\u002fIntermediateframes.svg\u002f150px-\u003cbr\u003eIntermediateframes.svg.png) ](\u002fwiki\u002fFile:Intermediateframes.svg)\u003cbr\u003e\u003cbr\u003eAny target orientation can be reached, starting from a known reference\u003cbr\u003eorientation, using a specific sequence of intrinsic rotations, whose\u003cbr\u003emagnitudes are the Euler angles of the target orientation. This example uses\u003cbr\u003ethe _z-x\u2032-z\u2033_ sequence.\u003cbr\u003e\u003cbr\u003eSee also: [ chained rotations ](\u002fwiki\u002fChained_rotations \"Chained rotations\")\u003cbr\u003e\u003cbr\u003eEuler angles can be defined by elemental [ geometry ](\u002fwiki\u002fGeometry\u003cbr\u003e\"Geometry\") or by composition of rotations. The geometrical definition\u003cbr\u003edemonstrates that three composed _[ elemental rotations\u003cbr\u003e](\u002fwiki\u002fElemental_rotation \"Elemental rotation\") _ (rotations about the axes\u003cbr\u003eof a [ coordinate system ](\u002fwiki\u002fCoordinate_system \"Coordinate system\") ) are\u003cbr\u003ealways sufficient to reach any target frame.\u003cbr\u003e\u003cbr\u003eThe three elemental rotations may be  extrinsic  (rotations about the axes\u003cbr\u003e_xyz_ of the original coordinate system, which is assumed to remain\u003cbr\u003emotionless), or  intrinsic  (rotations about the axes of the rotating\u003cbr\u003ecoordinate system _XYZ_ , solidary with the moving body, which changes its\u003cbr\u003eorientation with respect to the extrinsic frame after each elemental\u003cbr\u003erotation).\u003cbr\u003e\u003cbr\u003eIn the sections below, an axis designation with a prime mark superscript\u003cbr\u003e(e.g., _z_ \u2033) denotes the new axis after an elemental rotation.\u003cbr\u003e\u003cbr\u003eEuler angles are typically denoted as [ _\u03b1_ ](\u002fwiki\u002fAlpha \"Alpha\") , [ _\u03b2_\u003cbr\u003e](\u002fwiki\u002fBeta \"Beta\") , [ _\u03b3_ ](\u002fwiki\u002fGamma \"Gamma\") , or [ _\u03c8_\u003cbr\u003e](\u002fwiki\u002fPsi_\\(Greek\\) \"Psi \\(Greek\\)\") , [ _\u03b8_ ](\u002fwiki\u002fTheta \"Theta\") , [ _\u03c6_\u003cbr\u003e](\u002fwiki\u002fPhi \"Phi\") . Different authors may use different sets of rotation axes\u003cbr\u003eto define Euler angles, or different names for the same angles. Therefore, any\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 7)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.803\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.707\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.800\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003ediscussion employing Euler angles should always be preceded by their\u003cbr\u003edefinition.\u003cbr\u003e\u003cbr\u003eWithout considering the possibility of using two different conventions for the\u003cbr\u003edefinition of the rotation axes (intrinsic or extrinsic), there exist twelve\u003cbr\u003epossible sequences of rotation axes, divided in two groups:\u003cbr\u003e\u003cbr\u003e  * **Proper Euler angles** ( _z_ \\- _x_ \\- _z_ , _x_ \\- _y_ \\- _x_ , _y_ \\- _z_ \\- _y_ , _z_ \\- _y_ \\- _z_ , _x_ \\- _z_\u003cbr\u003e\\- _x_ , _y_ \\- _x_ \\- _y_ )\u003cbr\u003e  * **Tait\u2013Bryan angles** ( _x_ \\- _y_ \\- _z_ , _y_ \\- _z_ \\- _x_ , _z_ \\- _x_ \\- _y_ , _x_ \\- _z_ \\- _y_ , _z_ \\- _y_\u003cbr\u003e\\- _x_ , _y_ \\- _x_ \\- _z_ )  .\u003cbr\u003e\u003cbr\u003eTait\u2013Bryan angles are also called **Cardan angles** ; **nautical angles** ;\u003cbr\u003e**[ heading ](\u002fwiki\u002fHeading_\\(navigation\\) \"Heading \\(navigation\\)\") ,\u003cbr\u003eelevation, and bank ** ; or **yaw, pitch, and roll** . Sometimes, both kinds\u003cbr\u003eof sequences are called \"Euler angles\". In that case, the sequences of the\u003cbr\u003efirst group are called _proper_ or _classic_ Euler angles.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 8)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.013\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Classic Euler angles  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=2 \"Edit section: Classic\u003cbr\u003eEuler angles\") ]\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f7\u002f72\u002fGimbaleuler.svg\u002f180px-\u003cbr\u003eGimbaleuler.svg.png) ](\u002fwiki\u002fFile:Gimbaleuler.svg)\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f3\u002f34\u002fGimbaleuler2.svg\u002f160px-\u003cbr\u003eGimbaleuler2.svg.png) ](\u002fwiki\u002fFile:Gimbaleuler2.svg)\u003cbr\u003e\u003cbr\u003e**Left:** A [ gimbal ](\u002fwiki\u002fGimbal \"Gimbal\") set, showing a _z_ \\- _x_ \\- _z_\u003cbr\u003erotation sequence. External frame shown in the base. Internal axes in red\u003cbr\u003ecolor. **Right:** A simple diagram showing similar Euler angles.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 9)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.559\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.218\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.250\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Geometrical definition  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=3 \"Edit section:\u003cbr\u003eGeometrical definition\") ]\u003cbr\u003e\u003cbr\u003eThe axes of the original frame are denoted as _x_ , _y_ , _z_ and the axes of\u003cbr\u003ethe rotated frame as _X_ , _Y_ , _Z_ . The **geometrical definition**\u003cbr\u003e(sometimes referred to as static) begins by defining the [ line of nodes\u003cbr\u003e](\u002fwiki\u002fLine_of_nodes \"Line of nodes\") (N) as the intersection of the planes\u003cbr\u003e_xy_ and _XY_ (it can also be defined as the common perpendicular to the axes\u003cbr\u003e_z_ and _Z_ and then written as the vector product _N_ = _z_ \u00d7 _Z_ ). Using\u003cbr\u003eit, the three **Euler angles** can be defined as follows:\u003cbr\u003e\u003cbr\u003e  * \u03b1  {\\displaystyle \\alpha }  ![{\\\\displaystyle \\\\alpha\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fb79333175c8b3f0840bfb4ec41b8072c83ea88d3) (or  \u03c6\u003cbr\u003e{\\displaystyle \\varphi }  ![{\\\\displaystyle \\\\varphi\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f33ee699558d09cf9d653f6351f9fda0b2f4aaa3e) ) is the signed\u003cbr\u003eangle between the _x_ axis and the _N_ axis ( _x_ -convention \u2013 it could also be defined between _y_ and _N_ , called\u003cbr\u003e_y_ -convention).\u003cbr\u003e  * \u03b2  {\\displaystyle \\beta }  ![{\\\\displaystyle \\\\beta\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f7ed48a5e36207156fb792fa79d29925d2f7901e8) (or  \u03b8\u003cbr\u003e{\\displaystyle \\theta }  ![{\\\\displaystyle \\\\theta\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f6e5ab2664b422d53eb0c7df3b87e1360d75ad9af) ) is the angle\u003cbr\u003ebetween the _z_ axis and the _Z_ axis.\u003cbr\u003e  * \u03b3  {\\displaystyle \\gamma }  ![{\\\\displaystyle \\\\gamma\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fa223c880b0ce3da8f64ee33c4f0010beee400b1a) (or  \u03c8\u003cbr\u003e{\\displaystyle \\psi }  ![{\\\\displaystyle \\\\psi\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a) ) is the signed\u003cbr\u003eangle between the _N_ axis and the _X_ axis ( _x_ -convention).\u003cbr\u003e\u003cbr\u003eEuler angles between two reference frames are defined only if both frames have\u003cbr\u003ethe same [ handedness ](\u002fwiki\u002fOrientation_\\(mathematics\\) \"Orientation\u003cbr\u003e\\(mathematics\\)\") .\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 10)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.698\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.496\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.750\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Conventions by intrinsic rotations  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=4 \"Edit section:\u003cbr\u003eConventions by intrinsic rotations\") ]\u003cbr\u003e\u003cbr\u003eIntrinsic rotations are elemental rotations that occur about the axes of a\u003cbr\u003ecoordinate system _XYZ_ attached to a moving body. Therefore, they change\u003cbr\u003etheir orientation after each elemental rotation. The _XYZ_ system rotates,\u003cbr\u003ewhile _xyz_ is fixed. Starting with _XYZ_ overlapping _xyz_ , a composition of\u003cbr\u003ethree intrinsic rotations can be used to reach any target orientation for\u003cbr\u003e_XYZ_ .\u003cbr\u003e\u003cbr\u003eEuler angles can be defined by intrinsic rotations. The rotated frame _XYZ_\u003cbr\u003emay be imagined to be initially aligned with _xyz_ , before undergoing the\u003cbr\u003ethree elemental rotations represented by Euler angles. Its successive\u003cbr\u003eorientations may be denoted as follows:\u003cbr\u003e\u003cbr\u003e  * _x_ \\- _y_ \\- _z_ or _x_ 0  \\- _y_ 0  \\- _z_ 0  (initial)\u003cbr\u003e  * _x_ \u2032- _y_ \u2032- _z_ \u2032 or _x_ 1  \\- _y_ 1  \\- _z_ 1  (after first rotation)\u003cbr\u003e  * _x_ \u2033- _y_ \u2033- _z_ \u2033 or _x_ 2  \\- _y_ 2  \\- _z_ 2  (after second rotation)\u003cbr\u003e  * _X_ \\- _Y_ \\- _Z_ or _x_ 3  \\- _y_ 3  \\- _z_ 3  (final)\u003cbr\u003e\u003cbr\u003eFor the above-listed sequence of rotations, the [ line of nodes\u003cbr\u003e](\u002fwiki\u002fLine_of_nodes \"Line of nodes\") _N_ can be simply defined as the\u003cbr\u003eorientation of _X_ after the first elemental rotation. Hence, _N_ can be\u003cbr\u003esimply denoted _x_ \u2032. Moreover, since the third elemental rotation occurs\u003cbr\u003eabout _Z_ , it does not change the orientation of _Z_ . Hence _Z_ coincides\u003cbr\u003ewith _z_ \u2033. This allows us to simplify the definition of the Euler angles as\u003cbr\u003efollows:\u003cbr\u003e\u003cbr\u003e  * _\u03b1_ (or _\u03c6_ ) represents a rotation around the _z_ axis,\u003cbr\u003e  * _\u03b2_ (or _\u03b8_ ) represents a rotation around the _x_ \u2032 axis,\u003cbr\u003e  * _\u03b3_ (or _\u03c8_ ) represents a rotation around the _z_ \u2033 axis.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 11)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.598\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.296\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.350\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Conventions by extrinsic rotations  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=5 \"Edit section:\u003cbr\u003eConventions by extrinsic rotations\") ]\u003cbr\u003e\u003cbr\u003eExtrinsic rotations are elemental rotations that occur about the axes of the\u003cbr\u003efixed coordinate system _xyz_ . The _XYZ_ system rotates, while _xyz_ is\u003cbr\u003efixed. Starting with _XYZ_ overlapping _xyz_ , a composition of three\u003cbr\u003eextrinsic rotations can be used to reach any target orientation for _XYZ_ .\u003cbr\u003eThe Euler or Tait\u2013Bryan angles ( _\u03b1_ , _\u03b2_ , _\u03b3_ ) are the amplitudes of these\u003cbr\u003eelemental rotations. For instance, the target orientation can be reached as\u003cbr\u003efollows (note the reversed order of Euler angle application):\u003cbr\u003e\u003cbr\u003e  * The _XYZ_ system rotates about the _z_ axis by _\u03b3_ . The _X_ axis is now at angle _\u03b3_ with respect to the _x_ axis.\u003cbr\u003e  * The _XYZ_ system rotates again, but this time about the _x_ axis by _\u03b2_ . The _Z_ axis is now at angle _\u03b2_ with\u003cbr\u003erespect to the _z_ axis.\u003cbr\u003e  * The _XYZ_ system rotates a third time, about the _z_ axis again, by angle _\u03b1_ .\u003cbr\u003e\u003cbr\u003eIn sum, the three elemental rotations occur about _z_ , _x_ and _z_ . Indeed,\u003cbr\u003ethis sequence is often denoted _z_ \\- _x_ \\- _z_ (or 3-1-3). Sets of rotation\u003cbr\u003eaxes associated with both proper Euler angles and Tait\u2013Bryan angles are\u003cbr\u003ecommonly named using this notation (see above for details).\u003cbr\u003e\u003cbr\u003eIf each step of the rotation acts on the rotating coordinate system XYZ, the\u003cbr\u003erotation is intrinsic ( _Z-X'-Z''_ ). _Intrinsic_ rotation can also be denoted\u003cbr\u003e3-1-3.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 12)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.659\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.417\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.300\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Signs, ranges and conventions  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=6 \"Edit section: Signs,\u003cbr\u003eranges and conventions\") ]\u003cbr\u003e\u003cbr\u003eAngles are commonly defined according to the [ right-hand rule ](\u002fwiki\u002fRight-\u003cbr\u003ehand_rule \"Right-hand rule\") . Namely, they have positive values when they\u003cbr\u003erepresent a rotation that appears clockwise when looking in the positive\u003cbr\u003edirection of the axis, and negative values when the rotation appears counter-\u003cbr\u003eclockwise. The opposite convention (left hand rule) is less frequently\u003cbr\u003eadopted.\u003cbr\u003e\u003cbr\u003eAbout the ranges (using [ interval notation\u003cbr\u003e](\u002fwiki\u002fInterval_\\(mathematics\\)\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 13)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.563\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.226\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.300\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eNotations_for_intervals \"Interval\u003cbr\u003e\\(mathematics\\)\") ):\u003cbr\u003e\u003cbr\u003e  * for _\u03b1_ and _\u03b3_ , the range is defined [ modulo ](\u002fwiki\u002fModular_arithmetic \"Modular arithmetic\") 2  \u03c0  [ radians\u003cbr\u003e](\u002fwiki\u002fRadian \"Radian\") . For instance, a valid range could be  [\u2212  \u03c0  ,  \u03c0  ]  .\u003cbr\u003e  * for _\u03b2_ , the range covers  \u03c0  radians (but can not be said to be modulo  \u03c0  ). For example, it could be  [0,  \u03c0  ]\u003cbr\u003eor  [\u2212  \u03c0  \u002f2,  \u03c0  \u002f2]  .\u003cbr\u003e\u003cbr\u003eThe angles _\u03b1_ , _\u03b2_ and _\u03b3_ are uniquely determined except for the singular\u003cbr\u003ecase that the _xy_ and the _XY_ planes are identical, i.e. when the _z_ axis\u003cbr\u003eand the _Z_ axis have the same or opposite directions. Indeed, if the _z_ axis\u003cbr\u003eand the _Z_ axis are the same, _\u03b2_ = 0 and only ( _\u03b1_ \\+ _\u03b3_ ) is uniquely\u003cbr\u003edefined (not the individual values), and, similarly, if the _z_ axis and the\u003cbr\u003e_Z_ axis are opposite, _\u03b2_ =  \u03c0  and only ( _\u03b1_ \u2212 _\u03b3_ ) is uniquely defined\u003cbr\u003e(not the individual values). These ambiguities are known as [ gimbal lock\u003cbr\u003e](\u002fwiki\u002fGimbal_lock \"Gimbal lock\") in applications.\u003cbr\u003e\u003cbr\u003eThere are six possibilities of choosing the rotation axes for proper Euler\u003cbr\u003eangles. In all of them, the first and third rotation axes are the same. The\u003cbr\u003esix possible sequences are:\u003cbr\u003e\u003cbr\u003e  1. _z_ 1  \\- _x_ \u2032- _z_ 2  \u2033 (intrinsic rotations) or _z_ 2  \\- _x_ \\- _z_ 1  (extrinsic rotations)\u003cbr\u003e  2. _x_ 1  \\- _y_ \u2032- _x_ 2  \u2033 (intrinsic rotations) or _x_ 2  \\- _y_ \\- _x_ 1  (extrinsic rotations)\u003cbr\u003e  3. _y_ 1  \\- _z_ \u2032- _y_ 2  \u2033 (intrinsic rotations) or _y_ 2  \\- _z_ \\- _y_ 1  (extrinsic rotations)\u003cbr\u003e  4. _z_ 1  \\- _y_ \u2032- _z_ 2  \u2033 (intrinsic rotations) or _z_ 2  \\- _y_ \\- _z_ 1  (extrinsic rotations)\u003cbr\u003e  5. _x_ 1  \\- _z_ \u2032- _x_ 2  \u2033 (intrinsic rotations) or _x_ 2  \\- _z_ \\- _x_ 1  (extrinsic rotations)\u003cbr\u003e  6. _y_ 1  \\- _x_ \u2032- _y_ 2  \u2033 (intrinsic rotations) or _y_ 2  \\- _x_ \\- _y_ 1  (extrinsic rotations)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 14)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.633\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.367\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.700\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Precession, nutation and intrinsic rotation  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=7 \"Edit section:\u003cbr\u003ePrecession, nutation and intrinsic rotation\") ]\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002fb\u002fbb\u002fPraezession.svg\u002f170px-\u003cbr\u003ePraezession.svg.png) ](\u002fwiki\u002fFile:Praezession.svg) Euler basic motions of the\u003cbr\u003eEarth. Intrinsic (green), Precession (blue) and Nutation (red)\u003cbr\u003e\u003cbr\u003e[ Precession ](\u002fwiki\u002fPrecession \"Precession\") , [ nutation ](\u002fwiki\u002fNutation\u003cbr\u003e\"Nutation\") , and [ intrinsic rotation ](\u002fwiki\u002fRotation \"Rotation\") (spin) are\u003cbr\u003edefined as the movements obtained by changing one of the Euler angles while\u003cbr\u003eleaving the other two constant. These motions are not expressed in terms of\u003cbr\u003ethe external frame, or in terms of the co-moving rotated body frame, but in a\u003cbr\u003emixture. They constitute a **mixed axes of rotation** system, where the first\u003cbr\u003eangle moves the line of nodes around the external axis _z_ , the second\u003cbr\u003erotates around the line of nodes _N_ and the third one is an intrinsic\u003cbr\u003erotation around _Z_ , an axis fixed in the body that moves.\u003cbr\u003e\u003cbr\u003eThe static definition implies that:\u003cbr\u003e\u003cbr\u003e  * _\u03b1_ (precession) represents a rotation around the _z_ axis,\u003cbr\u003e  * _\u03b2_ (nutation) represents a rotation around the _N_ or x\u2032 axis,\u003cbr\u003e  * _\u03b3_ (intrinsic rotation) represents a rotation around the _Z_ or z\u2033 axis.\u003cbr\u003e\u003cbr\u003eIf _\u03b2_ is zero, there is no rotation about _N_ . As a consequence, _Z_\u003cbr\u003ecoincides with _z_ , _\u03b1_ and _\u03b3_ represent rotations about the same axis ( _z_\u003cbr\u003e), and the final orientation can be obtained with a single rotation about _z_\u003cbr\u003e, by an angle equal to  _\u03b1_ \\+ _\u03b3_ .\u003cbr\u003e\u003cbr\u003eAs an example, consider a [ top ](\u002fwiki\u002fTop \"Top\") . The top spins around its\u003cbr\u003eown axis of symmetry; this corresponds to its intrinsic rotation. It also\u003cbr\u003erotates around its pivotal axis, with its center of mass orbiting the pivotal\u003cbr\u003eaxis; this rotation is a precession. Finally, the top can wobble up and down;\u003cbr\u003ethe inclination angle is the nutation angle. The same example can be seen with\u003cbr\u003ethe movements of the earth.\u003cbr\u003e\u003cbr\u003eThough all three movements can be represented by a rotation operator with\u003cbr\u003econstant coefficients in some frame, they cannot be represented by these\u003cbr\u003eoperators all at the same time. Given a reference frame, at most one of them\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 0, 15)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.014\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003ewill be coefficient-free. Only precession can be expressed in general as a\u003cbr\u003ematrix in the basis of the space without dependencies of the other angles.\u003cbr\u003e\u003cbr\u003eThese movements also behave as a gimbal set. If we  [ _[ who?\u003cbr\u003e](\u002fwiki\u002fWikipedia:Manual_of_Style\u002fWords_to_watch\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.135\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.100\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eUnsupported_attributions\u003cbr\u003e\"Wikipedia:Manual of Style\u002fWords to watch\") _ ]  suppose a set of frames, able\u003cbr\u003eto move each with respect to the former according to just one angle, like a\u003cbr\u003egimbal, there will exist an external fixed frame, one final frame and two\u003cbr\u003eframes in the middle, which are called \"intermediate frames\". The two in the\u003cbr\u003emiddle work as two gimbal rings that allow the last frame to reach any\u003cbr\u003eorientation in space.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.781\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.636\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.850\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Tait\u2013Bryan angles  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=8 \"Edit section:\u003cbr\u003eTait\u2013Bryan angles\") ]\u003cbr\u003e\u003cbr\u003eSee also: [ Aircraft principal axes ](\u002fwiki\u002fAircraft_principal_axes \"Aircraft\u003cbr\u003eprincipal axes\")\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f5\u002f53\u002fTaitbrianzyx.svg\u002f200px-\u003cbr\u003eTaitbrianzyx.svg.png) ](\u002fwiki\u002fFile:Taitbrianzyx.svg) Tait\u2013Bryan angles. _z_ \\-\u003cbr\u003e_y_ \u2032- _x_ \u2033 sequence (intrinsic rotations; _N_ coincides with _y'_ ). The\u003cbr\u003eangle rotation sequence is _\u03c8_ , _\u03b8_ , _\u03c6_ . Note that in this case  _\u03c8_ \u003e 90\u00b0\u003cbr\u003eand _\u03b8_ is a negative angle.\u003cbr\u003e\u003cbr\u003eThe second type of formalism is called **Tait\u2013Bryan angles** , after [ Peter\u003cbr\u003eGuthrie Tait ](\u002fwiki\u002fPeter_Guthrie_Tait \"Peter Guthrie Tait\") and [ George H.\u003cbr\u003eBryan ](\u002fwiki\u002fGeorge_H._Bryan \"George H. Bryan\") . It is the convention\u003cbr\u003enormally used for aerospace applications, so that zero degrees elevation\u003cbr\u003erepresents the horizontal attitude. Tait\u2013Bryan angles represent the\u003cbr\u003eorientation of the aircraft with respect to the world frame. When dealing with\u003cbr\u003eother vehicles, different [ axes conventions ](\u002fwiki\u002fAxes_conventions \"Axes\u003cbr\u003econventions\") are possible.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.741\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.556\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.650\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Definitions  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=9 \"Edit section:\u003cbr\u003eDefinitions\") ]\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002fe\u002fea\u002fTaitbrianangles.svg\u002f325px-\u003cbr\u003eTaitbrianangles.svg.png) ](\u002fwiki\u002fFile:Taitbrianangles.svg) Tait\u2013Bryan angles.\u003cbr\u003e_z_ \\- _x_ \u2032- _y_ \u2033 sequence (intrinsic rotations; _N_ coincides with _x_ \u2032)\u003cbr\u003e\u003cbr\u003eThe definitions and notations used for Tait\u2013Bryan angles are similar to those\u003cbr\u003edescribed above for proper Euler angles (  geometrical definition  ,\u003cbr\u003eintrinsic rotation definition  ,  extrinsic rotation definition  ). The only\u003cbr\u003edifference is that Tait\u2013Bryan angles represent rotations about three distinct\u003cbr\u003eaxes (e.g. _x_ \\- _y_ \\- _z_ , or _x_ \\- _y_ \u2032- _z_ \u2033), while proper Euler\u003cbr\u003eangles use the same axis for both the first and third elemental rotations\u003cbr\u003e(e.g., _z_ \\- _x_ \\- _z_ , or _z_ \\- _x_ \u2032- _z_ \u2033).\u003cbr\u003e\u003cbr\u003eThis implies a different definition for the [ line of nodes\u003cbr\u003e](\u002fwiki\u002fLine_of_nodes \"Line of nodes\") in the geometrical construction. In the\u003cbr\u003eproper Euler angles case it was defined as the intersection between two\u003cbr\u003ehomologous Cartesian planes (parallel when Euler angles are zero; e.g. _xy_\u003cbr\u003eand _XY_ ). In the Tait\u2013Bryan angles case, it is defined as the intersection\u003cbr\u003eof two non-homologous planes (perpendicular when Euler angles are zero; e.g.\u003cbr\u003e_xy_ and _YZ_ ).\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.840\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.755\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.900\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Conventions  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=10 \"Edit section:\u003cbr\u003eConventions\") ]\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f3\u002f30\u002fPlane_with_ENU_embedded_axes.svg\u002f250px-\u003cbr\u003ePlane_with_ENU_embedded_axes.svg.png)\u003cbr\u003e](\u002fwiki\u002fFile:Plane_with_ENU_embedded_axes.svg) Heading, elevation and bank\u003cbr\u003eangles ( _Z_ \\- _Y_ \u2032- _X_ \u2033) for an aircraft using onboard ENU axes both\u003cbr\u003eonboard and for the ground tracking station. The fixed reference frame _x_ \\-\u003cbr\u003e_y_ \\- _z_ represents such a tracking station. Onboard axes _Y_ and _Z_ are\u003cbr\u003enot shown. _X_ shown in green color. According to RHS rules the shown _y_\u003cbr\u003e-axis is negative.\u003cbr\u003e\u003cbr\u003eThe three elemental rotations may occur either about the axes of the original\u003cbr\u003ecoordinate system, which remains motionless (  extrinsic rotations  ), or\u003cbr\u003eabout the axes of the rotating coordinate system, which changes its\u003cbr\u003eorientation after each elemental rotation (  intrinsic rotations  ).\u003cbr\u003e\u003cbr\u003eThere are six possibilities of choosing the rotation axes for Tait\u2013Bryan\u003cbr\u003eangles. The six possible sequences are:\u003cbr\u003e\u003cbr\u003e  * _x_ \\- _y_ \u2032- _z_ \u2033 (intrinsic rotations) or _z_ \\- _y_ \\- _x_ (extrinsic rotations)\u003cbr\u003e  * _y_ \\- _z_ \u2032- _x_ \u2033 (intrinsic rotations) or _x_ \\- _z_ \\- _y_ (extrinsic rotations)\u003cbr\u003e  * _z_ \\- _x_ \u2032- _y_ \u2033 (intrinsic rotations) or _y_ \\- _x_ \\- _z_ (extrinsic rotations)\u003cbr\u003e  * _x_ \\- _z_ \u2032- _y_ \u2033 (intrinsic rotations) or _y_ \\- _z_ \\- _x_ (extrinsic rotations)\u003cbr\u003e  * _z_ \\- _y_ \u2032- _x_ \u2033 (intrinsic rotations) or _x_ \\- _y_ \\- _z_ (extrinsic rotations): the intrinsic rotations are\u003cbr\u003eknown as: yaw, pitch and roll\u003cbr\u003e  * _y_ \\- _x_ \u2032- _z_ \u2033 (intrinsic rotations) or _z_ \\- _x_ \\- _y_ (extrinsic rotations)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 4)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.581\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.237\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.500\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Signs and ranges  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=11 \"Edit section: Signs\u003cbr\u003eand ranges\") ]\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002fc\u002fc1\u002fYaw_Axis_Corrected.svg\u002f250px-\u003cbr\u003eYaw_Axis_Corrected.svg.png) ](\u002fwiki\u002fFile:Yaw_Axis_Corrected.svg) The [\u003cbr\u003eprincipal axes ](\u002fwiki\u002fAircraft_principal_axes \"Aircraft principal axes\") of\u003cbr\u003ean aircraft according to the air norm [ DIN\u003cbr\u003e](\u002fwiki\u002fDeutsches_Institut_f%C3%BCr_Normung \"Deutsches Institut f\u00fcr Normung\")\u003cbr\u003e9300\\. Notice that fixed and mobile frames must be coincident with angles\u003cbr\u003ezero. Therefore, this norm would also force a compatible [ axes convention\u003cbr\u003e](\u002fwiki\u002fAxes_conventions \"Axes conventions\") in the reference system\u003cbr\u003e\u003cbr\u003eTait\u2013Bryan convention is widely used in engineering with different purposes.\u003cbr\u003eThere are several [ axes conventions ](\u002fwiki\u002fAxes_conventions \"Axes\u003cbr\u003econventions\") in practice for choosing the mobile and fixed axes, and these\u003cbr\u003econventions determine the signs of the angles. Therefore, signs must be\u003cbr\u003estudied in each case carefully.\u003cbr\u003e\u003cbr\u003eThe range for the angles _\u03c8_ and _\u03c6_ covers 2  \u03c0  radians. For _\u03b8_ the range\u003cbr\u003ecovers  \u03c0  radians.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 5)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.831\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.738\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Alternative names  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=12 \"Edit section:\u003cbr\u003eAlternative names\") ]\u003cbr\u003e\u003cbr\u003eThese angles are normally taken as one in the external reference frame ( [\u003cbr\u003eheading ](\u002fwiki\u002fHeading_\\(navigation\\) \"Heading \\(navigation\\)\") , [ bearing\u003cbr\u003e](\u002fwiki\u002fBearing_\\(navigation\\) \"Bearing \\(navigation\\)\") ), one in the\u003cbr\u003eintrinsic moving frame ( [ bank ](\u002fwiki\u002fBanked_turn \"Banked turn\") ) and one\u003cbr\u003ein a middle frame, representing an [ elevation\u003cbr\u003e](\u002fwiki\u002fElevation_\\(ballistics\\) \"Elevation \\(ballistics\\)\") or inclination\u003cbr\u003ewith respect to the horizontal plane, which is equivalent to the line of nodes\u003cbr\u003efor this purpose.\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f7\u002f7d\u002fRoll_pitch_yaw_mnemonic.svg\u002f220px-\u003cbr\u003eRoll_pitch_yaw_mnemonic.svg.png) ](\u002fwiki\u002fFile:Roll_pitch_yaw_mnemonic.svg)\u003cbr\u003eMnemonics to remember angle names\u003cbr\u003e\u003cbr\u003eFor an aircraft, they can be obtained with three rotations around its [\u003cbr\u003eprincipal axes ](\u002fwiki\u002fAircraft_principal_axes \"Aircraft principal axes\") if\u003cbr\u003edone in the proper order. A [ yaw ](\u002fwiki\u002fYaw_\\(rotation\\) \"Yaw \\(rotation\\)\")\u003cbr\u003ewill obtain the bearing, a [ pitch ](\u002fwiki\u002fPitching_moment \"Pitching moment\")\u003cbr\u003ewill yield the elevation and a roll gives the bank angle. Therefore, in\u003cbr\u003eaerospace they are sometimes called **yaw, pitch, and roll** . Notice that\u003cbr\u003ethis will not work if the rotations are applied in any other order or if the\u003cbr\u003eairplane axes start in any position non-equivalent to the reference frame.\u003cbr\u003e\u003cbr\u003eTait\u2013Bryan angles, following _z_ \\- _y_ \u2032- _x_ \u2033 (intrinsic rotations)\u003cbr\u003econvention, are also known as **nautical angles** , because they can be used\u003cbr\u003eto describe the orientation of a ship or aircraft, or **Cardan angles** ,\u003cbr\u003eafter the Italian mathematician and physicist [ Gerolamo Cardano\u003cbr\u003e](\u002fwiki\u002fGerolamo_Cardano \"Gerolamo Cardano\") , who first described in detail\u003cbr\u003ethe [ Cardan suspension ](\u002fwiki\u002fCardan_suspension \"Cardan suspension\") and the\u003cbr\u003e[ Cardan joint ](\u002fwiki\u002fCardan_joint \"Cardan joint\") .\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 6)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.511\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.097\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.350\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Angles of a given frame  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=13 \"Edit section: Angles\u003cbr\u003eof a given frame\") ]\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002fe\u002fe5\u002fEulerProjections.svg\u002f200px-\u003cbr\u003eEulerProjections.svg.png) ](\u002fwiki\u002fFile:EulerProjections.svg) Projections of\u003cbr\u003e_Z_ vector  [\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f9\u002f9e\u002fEulerProjections2.svg\u002f200px-\u003cbr\u003eEulerProjections2.svg.png) ](\u002fwiki\u002fFile:EulerProjections2.svg) Projections of\u003cbr\u003e_Y_ vector\u003cbr\u003e\u003cbr\u003eA common problem is to find the Euler angles of a given frame. The fastest way\u003cbr\u003eto get them is to write the three given vectors as columns of a matrix and\u003cbr\u003ecompare it with the expression of the theoretical matrix (see later table of\u003cbr\u003ematrices). Hence the three Euler Angles can be calculated. Nevertheless, the\u003cbr\u003esame result can be reached avoiding matrix algebra and using only elemental\u003cbr\u003egeometry. Here we present the results for the two most commonly used\u003cbr\u003econventions: _ZXZ_ for proper Euler angles and _ZYX_ for Tait\u2013Bryan. Notice\u003cbr\u003ethat any other convention can be obtained just changing the name of the axes.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 7)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.042\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.200\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Proper Euler angles  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=14 \"Edit section: Proper\u003cbr\u003eEuler angles\") ]\u003cbr\u003e\u003cbr\u003eAssuming a frame with [ unit vectors ](\u002fwiki\u002fUnit_vector \"Unit vector\") ( _X_\u003cbr\u003e, _Y_ , _Z_ ) given by their coordinates as in the main diagram, it can be\u003cbr\u003eseen that:\u003cbr\u003e\u003cbr\u003e     cos  \u2061  (  \u03b2  )  =  Z  3  .  {\\displaystyle \\cos(\\beta )=Z_{3}.}  ![{\\\\displaystyle \\\\cos\\(\\\\beta\u003cbr\u003e\\)=Z_{3}.}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002ff4558a4a3b5029d45bd3c7906c99ee32b6c316e1)\u003cbr\u003e\u003cbr\u003eAnd, since\u003cbr\u003e\u003cbr\u003e     sin  2  \u2061  x  =  1  \u2212  cos  2  \u2061  x  ,  {\\displaystyle \\sin ^{2}x=1-\\cos ^{2}x,}  ![{\\\\displaystyle \\\\sin\u003cbr\u003e^{2}x=1-\\\\cos ^{2}x,}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f9f8a52252be03a493612bcb72093e090c83f0144)\u003cbr\u003e\u003cbr\u003efor  0  \u003c x  \u003c \u03c0  {\\displaystyle 0\u003cx\u003c\\pi }  ![{\\\\displaystyle 0\u003cx\u003c\\\\pi\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fa5072e331d80251147f44dc1bca9faa5d19c96a8)\u003cbr\u003ewe have\u003cbr\u003e\u003cbr\u003e     sin  \u2061  (  \u03b2  )  =  1  \u2212  Z  3  2  .  {\\displaystyle \\sin(\\beta )={\\sqrt {1-Z_{3}^{2}}}.}  ![{\\\\displaystyle\u003cbr\u003e\\\\sin\\(\\\\beta \\)={\\\\sqrt\u003cbr\u003e{1-Z_{3}^{2}}}.}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fe4a06ad8788186f6640692f41f8fc601f621c81e)\u003cbr\u003e\u003cbr\u003eAs  Z  2  {\\displaystyle Z_{2}}  ![{\\\\displaystyle\u003cbr\u003eZ_{2}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fc98d433ae289ecb2b88f895b407538b0e4183b28)\u003cbr\u003eis the double projection of a unitary vector,\u003cbr\u003e\u003cbr\u003e     cos  \u2061  (  \u03b1  )  \u22c5  sin  \u2061  (  \u03b2  )  =  \u2212  Z  2  ,  {\\displaystyle \\cos(\\alpha )\\cdot \\sin(\\beta )=-Z_{2},}\u003cbr\u003e![{\\\\displaystyle \\\\cos\\(\\\\alpha \\)\\\\cdot \\\\sin\\(\\\\beta\u003cbr\u003e\\)=-Z_{2},}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f6927cb465d111edf8884d941cf6a70b716c508b4)\u003cbr\u003e     cos  \u2061  (  \u03b1  )  =  \u2212  Z  2  \u002f  1  \u2212  Z  3  2  .  {\\displaystyle \\cos(\\alpha )=-Z_{2}\u002f{\\sqrt {1-Z_{3}^{2}}}.}\u003cbr\u003e![{\\\\displaystyle \\\\cos\\(\\\\alpha \\)=-Z_{2}\u002f{\\\\sqrt\u003cbr\u003e{1-Z_{3}^{2}}}.}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fdbae2fef5e628a6ce262622f803aa1846f2eb7ba)\u003cbr\u003e\u003cbr\u003eThere is a similar construction for  Y  3  {\\displaystyle Y_{3}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eY_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fb424bd11330a73f6ccde0cb76c3f7514e9fb3769)\u003cbr\u003e, projecting it first over the plane defined by the axis _z_ and the line of\u003cbr\u003enodes. As the angle between the planes is  \u03c0  \u002f  2  \u2212  \u03b2  {\\displaystyle \\pi\u003cbr\u003e\u002f2-\\beta }  ![{\\\\displaystyle \\\\pi \u002f2-\\\\beta\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fe02dcb73bbabd79156d2ef4a2a6aa6720a8e3cae)\u003cbr\u003eand  cos  \u2061  (  \u03c0  \u002f  2  \u2212  \u03b2  )  =  sin  \u2061  (  \u03b2  )  {\\displaystyle \\cos(\\pi\u003cbr\u003e\u002f2-\\beta )=\\sin(\\beta )}  ![{\\\\displaystyle \\\\cos\\(\\\\pi \u002f2-\\\\beta\u003cbr\u003e\\)=\\\\sin\\(\\\\beta\u003cbr\u003e\\)}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fb13f8ba044389ed41109e72b0daddd4d51db5297)\u003cbr\u003e, this leads to:\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 8)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.042\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.200\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e     sin  \u2061  (  \u03b2  )  \u22c5  cos  \u2061  (  \u03b3  )  =  Y  3  ,  {\\displaystyle \\sin(\\beta )\\cdot \\cos(\\gamma )=Y_{3},}\u003cbr\u003e![{\\\\displaystyle \\\\sin\\(\\\\beta \\)\\\\cdot \\\\cos\\(\\\\gamma\u003cbr\u003e\\)=Y_{3},}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f11b6d34b4844044398a70b0885029a810bbff0ab)\u003cbr\u003e     cos  \u2061  (  \u03b3  )  =  Y  3  \u002f  1  \u2212  Z  3  2  ,  {\\displaystyle \\cos(\\gamma )=Y_{3}\u002f{\\sqrt {1-Z_{3}^{2}}},}\u003cbr\u003e![{\\\\displaystyle \\\\cos\\(\\\\gamma \\)=Y_{3}\u002f{\\\\sqrt\u003cbr\u003e{1-Z_{3}^{2}}},}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f3ddb423f88112b643efc72e72404bafa5229e2d0)\u003cbr\u003e\u003cbr\u003eand finally, using the [ inverse cosine\u003cbr\u003e](\u002fwiki\u002fInverse_trigonometric_functions \"Inverse trigonometric functions\")\u003cbr\u003efunction,\u003cbr\u003e\u003cbr\u003e     \u03b1  =  arccos  \u2061  (  \u2212  Z  2  \u002f  1  \u2212  Z  3  2  )  ,  {\\displaystyle \\alpha =\\arccos \\left(-Z_{2}\u002f{\\sqrt\u003cbr\u003e{1-Z_{3}^{2}}}\\right),}  ![{\\\\displaystyle \\\\alpha =\\\\arccos \\\\left\\(-Z_{2}\u002f{\\\\sqrt {1-\u003cbr\u003eZ_{3}^{2}}}\\\\right\\),}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fce360cf255207dbbaf417d219531ddef53d20dad\u003cbr\u003e)\u003cbr\u003e     \u03b2  =  arccos  \u2061  (  Z  3  )  ,  {\\displaystyle \\beta =\\arccos \\left(Z_{3}\\right),}  ![{\\\\displaystyle \\\\beta\u003cbr\u003e=\\\\arccos \\\\left\\(Z_{3}\\\\right\\),}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002feadc9458dc9643149fe0fb9bbe7b\u003cbr\u003e7770b3fc6e79)\u003cbr\u003e     \u03b3  =  arccos  \u2061  (  Y  3  \u002f  1  \u2212  Z  3  2  )  .  {\\displaystyle \\gamma =\\arccos \\left(Y_{3}\u002f{\\sqrt\u003cbr\u003e{1-Z_{3}^{2}}}\\right).}  ![{\\\\displaystyle \\\\gamma =\\\\arccos \\\\left\\(Y_{3}\u002f{\\\\sqrt {1-\u003cbr\u003eZ_{3}^{2}}}\\\\right\\).}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fa7f21b118ff354cea66670ddf8aeb6ef6d3ad962\u003cbr\u003e)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 9)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.613\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.301\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.800\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Tait\u2013Bryan angles  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=15 \"Edit section:\u003cbr\u003eTait\u2013Bryan angles\") ]\u003cbr\u003e\u003cbr\u003e[ ![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fen\u002fthumb\u002f6\u002f63\u002fProjections_of_Tait-\u003cbr\u003eBryan_angles.svg\u002f220px-Projections_of_Tait-Bryan_angles.svg.png)\u003cbr\u003e](\u002fwiki\u002fFile:Projections_of_Tait-Bryan_angles.svg) Projections of _x_ -axis\u003cbr\u003eafter three Tait\u2013Bryan rotations. Notice that theta is a negative rotation\u003cbr\u003earound the axis _y_ \u2032.\u003cbr\u003e\u003cbr\u003eAssuming a frame with [ unit vectors ](\u002fwiki\u002fUnit_vector \"Unit vector\") ( _X_\u003cbr\u003e, _Y_ , _Z_ ) given by their coordinates as in this new diagram (notice that\u003cbr\u003ethe angle theta is negative), it can be seen that:\u003cbr\u003e\u003cbr\u003e     sin  \u2061  (  \u03b8  )  =  \u2212  X  3  {\\displaystyle \\sin(\\theta )=-X_{3}}  ![{\\\\displaystyle \\\\sin\\(\\\\theta\u003cbr\u003e\\)=-X_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f86eab6b93a2865529b69bbd706e70b7eb7304075)\u003cbr\u003e\u003cbr\u003eAs before,\u003cbr\u003e\u003cbr\u003e     cos  2  \u2061  x  =  1  \u2212  sin  2  \u2061  x  ,  {\\displaystyle \\cos ^{2}x=1-\\sin ^{2}x,}  ![{\\\\displaystyle \\\\cos\u003cbr\u003e^{2}x=1-\\\\sin ^{2}x,}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fa8d18eeb7f30a54294c80f7c70b4ff6def5e6bd2)\u003cbr\u003e\u003cbr\u003efor  \u2212  \u03c0  \u002f  2  \u003c x  \u003c \u03c0  \u002f  2  {\\displaystyle -\\pi \u002f2\u003cx\u003c\\pi \u002f2}\u003cbr\u003e![{\\\\displaystyle -\\\\pi \u002f2\u003cx\u003c\\\\pi\u003cbr\u003e\u002f2}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f244b2a56dbd0cdd7c5f1b8a3b8edbf35a65014de)\u003cbr\u003ewe have\u003cbr\u003e\u003cbr\u003e     cos  \u2061  (  \u03b8  )  =  1  \u2212  X  3  2  .  {\\displaystyle \\cos(\\theta )={\\sqrt {1-X_{3}^{2}}}.}  ![{\\\\displaystyle\u003cbr\u003e\\\\cos\\(\\\\theta \\)={\\\\sqrt\u003cbr\u003e{1-X_{3}^{2}}}.}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f5ea2724ee1591c065ffc4c730d1604258833d9a6)\u003cbr\u003e\u003cbr\u003ein a way analogous to the former one:\u003cbr\u003e\u003cbr\u003e     sin  \u2061  (  \u03c8  )  =  X  2  \u002f  1  \u2212  X  3  2  .  {\\displaystyle \\sin(\\psi )=X_{2}\u002f{\\sqrt {1-X_{3}^{2}}}.}\u003cbr\u003e![{\\\\displaystyle \\\\sin\\(\\\\psi \\)=X_{2}\u002f{\\\\sqrt\u003cbr\u003e{1-X_{3}^{2}}}.}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f8c32bd1fe57a4589f69f0686e6a2d6f71c68b592)\u003cbr\u003e     sin  \u2061  (  \u03d5  )  =  Y  3  \u002f  1  \u2212  X  3  2  .  {\\displaystyle \\sin(\\phi )=Y_{3}\u002f{\\sqrt {1-X_{3}^{2}}}.}\u003cbr\u003e![{\\\\displaystyle \\\\sin\\(\\\\phi \\)=Y_{3}\u002f{\\\\sqrt\u003cbr\u003e{1-X_{3}^{2}}}.}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f7ece673a48a719f004c7a781fc0437e79359dfa5)\u003cbr\u003e\u003cbr\u003eLooking for similar expressions to the former ones:\u003cbr\u003e\u003cbr\u003e     \u03c8  =  arcsin  \u2061  (  X  2  \u002f  1  \u2212  X  3  2  )  ,  {\\displaystyle \\psi =\\arcsin \\left(X_{2}\u002f{\\sqrt\u003cbr\u003e{1-X_{3}^{2}}}\\right),}  ![{\\\\displaystyle \\\\psi =\\\\arcsin \\\\left\\(X_{2}\u002f{\\\\sqrt {1-\u003cbr\u003eX_{3}^{2}}}\\\\right\\),}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f3c6bdef5ca26321cad2bd85844576d1f5d84d647\u003cbr\u003e)\u003cbr\u003e     \u03b8  =  arcsin  \u2061  (  \u2212  X  3  )  ,  {\\displaystyle \\theta =\\arcsin(-X_{3}),}  ![{\\\\displaystyle \\\\theta\u003cbr\u003e=\\\\arcsin\\(-X_{3}\\),}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f58a57cf48781e573e8c32d1f14305d474c3b1f50)\u003cbr\u003e     \u03d5  =  arcsin  \u2061  (  Y  3  \u002f  1  \u2212  X  3  2  )  .  {\\displaystyle \\phi =\\arcsin \\left(Y_{3}\u002f{\\sqrt\u003cbr\u003e{1-X_{3}^{2}}}\\right).}  ![{\\\\displaystyle \\\\phi =\\\\arcsin \\\\left\\(Y_{3}\u002f{\\\\sqrt {1-\u003cbr\u003eX_{3}^{2}}}\\\\right\\).}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fa987af5d5959b746e998409c5110715fbd992f29\u003cbr\u003e)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 10)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.534\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.144\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.400\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Last remarks  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=16 \"Edit section: Last\u003cbr\u003eremarks\") ]\u003cbr\u003e\u003cbr\u003eNote that the inverse sine and cosine functions yield two possible values for\u003cbr\u003ethe argument. In this geometrical description, only one of the solutions is\u003cbr\u003evalid. When Euler angles are defined as a sequence of rotations, all the\u003cbr\u003esolutions can be valid, but there will be only one inside the angle ranges.\u003cbr\u003eThis is because the sequence of rotations to reach the target frame is not\u003cbr\u003eunique if the ranges are not previously defined.  [2]\u003cbr\u003e\u003cbr\u003eFor computational purposes, it may be useful to represent the angles using  [\u003cbr\u003eatan2 ](\u002fwiki\u002fAtan2 \"Atan2\") ( _y_ , _x_ )  . For example, in the case of\u003cbr\u003eproper Euler angles:\u003cbr\u003e\u003cbr\u003e     \u03b1  =  atan2  \u2061  (  Z  1  ,  \u2212  Z  2  )  ,  {\\displaystyle \\alpha =\\operatorname {atan2} (Z_{1},-Z_{2}),}\u003cbr\u003e![{\\\\displaystyle \\\\alpha =\\\\operatorname {atan2}\u003cbr\u003e\\(Z_{1},-Z_{2}\\),}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f34e5aed0f1546710c4c2445217c3f4ad108533fe)\u003cbr\u003e     \u03b3  =  atan2  \u2061  (  X  3  ,  Y  3  )  .  {\\displaystyle \\gamma =\\operatorname {atan2} (X_{3},Y_{3}).}\u003cbr\u003e![{\\\\displaystyle \\\\gamma =\\\\operatorname {atan2}\u003cbr\u003e\\(X_{3},Y_{3}\\).}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f0fa87dfedec1c2c4c7f8b01d7c00f259df55b630)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 11)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.535\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.144\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.750\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Conversion to other orientation representations  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=17 \"Edit section:\u003cbr\u003eConversion to other orientation representations\") ]\u003cbr\u003e\u003cbr\u003eMain article: [ Rotation formalisms in three dimensions \u00a7 Conversion formulae\u003cbr\u003ebetween formalisms\u003cbr\u003e](\u002fwiki\u002fRotation_formalisms_in_three_dimensions\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 12)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.663\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.402\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.700\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eConversion_formulae_between_formalisms\u003cbr\u003e\"Rotation formalisms in three dimensions\")\u003cbr\u003e\u003cbr\u003eEuler angles are one way to represent orientations. There are others, and it\u003cbr\u003eis possible to change to and from other conventions. Three parameters are\u003cbr\u003ealways required to describe orientations in a [ 3-dimensional\u003cbr\u003e](\u002fwiki\u002fDimension \"Dimension\") [ Euclidean space ](\u002fwiki\u002fEuclidean_space\u003cbr\u003e\"Euclidean space\") . They can be given in several ways, Euler angles being one\u003cbr\u003eof them; see [ charts on SO(3) ](\u002fwiki\u002fCharts_on_SO\\(3\\) \"Charts on SO\\(3\\)\")\u003cbr\u003efor others.\u003cbr\u003e\u003cbr\u003eThe most used orientation representation are the [ rotation matrices\u003cbr\u003e](\u002fwiki\u002fRotation_matrix \"Rotation matrix\") , the [ axis-angle ](\u002fwiki\u002fAxis-\u003cbr\u003eangle \"Axis-angle\") and the [ quaternions ](\u002fwiki\u002fQuaternion \"Quaternion\") ,\u003cbr\u003ealso known as [ Euler\u2013Rodrigues parameters\u003cbr\u003e](\u002fwiki\u002fEuler%E2%80%93Rodrigues_parameters \"Euler\u2013Rodrigues parameters\") ,\u003cbr\u003ewhich provide [ another mechanism ](\u002fwiki\u002fQuaternions_and_spatial_rotation\u003cbr\u003e\"Quaternions and spatial rotation\") for representing 3D rotations. This is\u003cbr\u003eequivalent to the special unitary group description.\u003cbr\u003e\u003cbr\u003eExpressing rotations in 3D as unit quaternions instead of matrices has some\u003cbr\u003eadvantages:\u003cbr\u003e\u003cbr\u003e  * Concatenating rotations is computationally faster and numerically more stable.\u003cbr\u003e  * Extracting the angle and axis of rotation is simpler.\u003cbr\u003e  * Interpolation is more straightforward. See for example [ slerp ](\u002fwiki\u002fSlerp \"Slerp\") .\u003cbr\u003e  * Quaternions do not suffer from [ gimbal lock ](\u002fwiki\u002fGimbal_lock \"Gimbal lock\") as Euler angles do.\u003cbr\u003e\u003cbr\u003eRegardless, the rotation matrix calculation is the first step for obtaining\u003cbr\u003ethe other two representations.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 13)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.566\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.206\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.600\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Rotation matrix  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=18 \"Edit section:\u003cbr\u003eRotation matrix\") ]\u003cbr\u003e\u003cbr\u003eAny orientation can be achieved by composing three elemental rotations,\u003cbr\u003estarting from a known standard orientation. Equivalently, any [ rotation\u003cbr\u003ematrix ](\u002fwiki\u002fRotation_matrix \"Rotation matrix\") _R_ can be [ decomposed\u003cbr\u003e](\u002fwiki\u002fMatrix_decomposition \"Matrix decomposition\") as a product of three\u003cbr\u003eelemental rotation matrices. For instance:\u003cbr\u003e\u003cbr\u003e     R  =  X  (  \u03b1  )  Y  (  \u03b2  )  Z  (  \u03b3  )  {\\displaystyle R=X(\\alpha )Y(\\beta )Z(\\gamma )}  ![{\\\\displaystyle\u003cbr\u003eR=X\\(\\\\alpha \\)Y\\(\\\\beta \\)Z\\(\\\\gamma\u003cbr\u003e\\)}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fab48abbc214df3633ab0262c3ef043bbd497a38d)\u003cbr\u003e\u003cbr\u003eis a rotation matrix that may be used to represent a composition of  extrinsic\u003cbr\u003erotations  about axes _z_ , _y_ , _x_ , (in that order), or a composition of\u003cbr\u003eintrinsic rotations  about axes _x_ \\- _y_ \u2032- _z_ \u2033 (in that order). However,\u003cbr\u003eboth the definition of the elemental rotation matrices _X_ , _Y_ , _Z_ , and\u003cbr\u003etheir multiplication order depend on the choices taken by the user about the\u003cbr\u003edefinition of both rotation matrices and Euler angles (see, for instance, [\u003cbr\u003eAmbiguities in the definition of rotation matrices\u003cbr\u003e](\u002fwiki\u002fRotation_matrix\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 14)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.558\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.191\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.600\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eAmbiguities \"Rotation matrix\") ). Unfortunately,\u003cbr\u003edifferent sets of conventions are adopted by users in different contexts. The\u003cbr\u003efollowing table was built according to this set of conventions:\u003cbr\u003e\u003cbr\u003e  1. Each matrix is meant to operate by pre-multiplying [ column vectors ](\u002fwiki\u002fColumn_vector \"Column vector\") [  x  y\u003cbr\u003ez  ]  {\\textstyle {\\begin{bmatrix}x\\\\\\y\\\\\\z\\end{bmatrix}}}  ![{\\\\textstyle {\\\\begin{bmatrix}x\\\\\\\\y\\\\\\\\z\\\\end{bmatrix}}}]\u003cbr\u003e(https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f177f3d76237b10928319aef9808384464b2d9f16) (see [ Ambiguities in\u003cbr\u003ethe definition of rotation matrices ](\u002fwiki\u002fRotation_matrix\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 1, 15)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.643\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.361\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.600\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eAmbiguities \"Rotation matrix\") )\u003cbr\u003e  2. Each matrix is meant to represent an [ active rotation ](\u002fwiki\u002fActive_and_passive_transformation \"Active and\u003cbr\u003epassive transformation\") (the composing and composed matrices are supposed to act on the coordinates of vectors defined\u003cbr\u003ein the initial fixed reference frame and give as a result the coordinates of a rotated vector defined in the same\u003cbr\u003ereference frame).\u003cbr\u003e  3. Each matrix is meant to represent, primarily, a composition of [ intrinsic rotations ](\u002fwiki\u002fIntrinsic_rotations\u003cbr\u003e\"Intrinsic rotations\") (around the axes of the rotating reference frame) and, secondarily, the composition of three [\u003cbr\u003eextrinsic rotations ](\u002fwiki\u002fExtrinsic_rotations \"Extrinsic rotations\") (which corresponds to the constructive evaluation\u003cbr\u003eof the R matrix by the multiplication of three truly elemental matrices, in reverse order).\u003cbr\u003e  4. [ Right handed ](\u002fwiki\u002fRight_hand_rule \"Right hand rule\") reference frames are adopted, and the [ right hand rule\u003cbr\u003e](\u002fwiki\u002fRight_hand_rule \"Right hand rule\") is used to determine the sign of the angles _\u03b1_ , _\u03b2_ , _\u03b3_ .\u003cbr\u003e\u003cbr\u003eFor the sake of simplicity, the following table of matrix products uses the\u003cbr\u003efollowing nomenclature:\u003cbr\u003e\u003cbr\u003e  1. 1, 2, 3 represent the angles _\u03b1_ , _\u03b2_ and _\u03b3_ , i.e. the angles corresponding to the first, second and third\u003cbr\u003eelemental rotations respectively.\u003cbr\u003e  2. _X_ , _Y_ , _Z_ are the matrices representing the elemental rotations about the axes _x_ , _y_ , _z_ of the fixed\u003cbr\u003eframe (e.g., _X_ 1  represents a rotation about _x_ by an angle _\u03b1_ ).\u003cbr\u003e  3. _s_ and _c_ represent sine and cosine (e.g., _s_ 1  represents the sine of _\u03b1_ ).\u003cbr\u003e\u003cbr\u003e     Proper Euler angles  |  Tait\u2013Bryan angles\u003cbr\u003e---|---\u003cbr\u003eX  1  Z  2  X  3  =  [  c  2  \u2212  c  3  s  2  s  2  s  3  c  1  s  2  c  1  c\u003cbr\u003e2  c  3  \u2212  s  1  s  3  \u2212  c  3  s  1  \u2212  c  1  c  2  s  3  s  1  s  2  c  1\u003cbr\u003es  3  \\+  c  2  c  3  s  1  c  1  c  3  \u2212  c  2  s  1  s  3  ]  {\\displaystyle\u003cbr\u003eX_{1}Z_{2}X_{3}={\\begin{bmatrix}c_{2}&-c_{3}s_{2}&s_{2}s_{3}\\\\\\c_{1}s_{2}&c_{1}c_{2}c_{3}-s_{1}s_{3}&-c_{3}s_{1}-\u003cbr\u003ec_{1}c_{2}s_{3}\\\\\\s_{1}s_{2}&c_{1}s_{3}+c_{2}c_{3}s_{1}&c_{1}c_{3}-c_{2}s_{1}s_{3}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eX_{1}Z_{2}X_{3}={\\\\begin{bmatrix}c_{2}&-c_{3}s_{2}&s_{2}s_{3}\\\\\\\\c_{1}s_{2}&c_{1}c_{2}c_{3}-s_{1}s_{3}&-c_{3}s_{1}-\u003cbr\u003ec_{1}c_{2}s_{3}\\\\\\\\s_{1}s_{2}&c_{1}s_{3}+c_{2}c_{3}s_{1}&c_{1}c_{3}-\u003cbr\u003ec_{2}s_{1}s_{3}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f22ecc7d65613b53c38208ccdb9f3a05\u003cbr\u003e206222593)\u003cbr\u003e|  X  1  Z  2  Y  3  =  [  c  2  c  3  \u2212  s  2  c  2  s  3  s  1  s  3  \\+  c\u003cbr\u003e1  c  3  s  2  c  1  c  2  c  1  s  2  s  3  \u2212  c  3  s  1  c  3  s  1  s  2\u003cbr\u003e\u2212  c  1  s  3  c  2  s  1  c  1  c  3  \\+  s  1  s  2  s  3  ]  {\\displaystyle\u003cbr\u003eX_{1}Z_{2}Y_{3}={\\begin{bmatrix}c_{2}c_{3}&-s_{2}&c_{2}s_{3}\\\\\\s_{1}s_{3}+c_{1}c_{3}s_{2}&c_{1}c_{2}&c_{1}s_{2}s_{3}-\u003cbr\u003ec_{3}s_{1}\\\\\\c_{3}s_{1}s_{2}-c_{1}s_{3}&c_{2}s_{1}&c_{1}c_{3}+s_{1}s_{2}s_{3}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eX_{1}Z_{2}Y_{3}={\\\\begin{bmatrix}c_{2}c_{3}&-s_{2}&c_{2}s_{3}\\\\\\\\s_{1}s_{3}+c_{1}c_{3}s_{2}&c_{1}c_{2}&c_{1}s_{2}s_{3}-\u003cbr\u003ec_{3}s_{1}\\\\\\\\c_{3}s_{1}s_{2}-\u003cbr\u003ec_{1}s_{3}&c_{2}s_{1}&c_{1}c_{3}+s_{1}s_{2}s_{3}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsv\u003cbr\u003eg\u002f38d5c50b0be4c13b2b3a43ce32b37a14ab8c1f94)\u003cbr\u003eX  1  Y  2  X  3  =  [  c  2  s  2  s  3  c  3  s  2  s  1  s  2  c  1  c  3\u003cbr\u003e\u2212  c  2  s  1  s  3  \u2212  c  1  s  3  \u2212  c  2  c  3  s  1  \u2212  c  1  s  2  c  3\u003cbr\u003es  1  \\+  c  1  c  2  s  3  c  1  c  2  c  3  \u2212  s  1  s  3  ]  {\\displaystyle\u003cbr\u003eX_{1}Y_{2}X_{3}={\\begin{bmatrix}c_{2}&s_{2}s_{3}&c_{3}s_{2}\\\\\\s_{1}s_{2}&c_{1}c_{3}-c_{2}s_{1}s_{3}&-c_{1}s_{3}-\u003cbr\u003ec_{2}c_{3}s_{1}\\\\\\\\-c_{1}s_{2}&c_{3}s_{1}+c_{1}c_{2}s_{3}&c_{1}c_{2}c_{3}-s_{1}s_{3}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eX_{1}Y_{2}X_{3}={\\\\begin{bmatrix}c_{2}&s_{2}s_{3}&c_{3}s_{2}\\\\\\\\s_{1}s_{2}&c_{1}c_{3}-c_{2}s_{1}s_{3}&-c_{1}s_{3}-\u003cbr\u003ec_{2}c_{3}s_{1}\\\\\\\\-c_{1}s_{2}&c_{3}s_{1}+c_{1}c_{2}s_{3}&c_{1}c_{2}c_{3}-\u003cbr\u003es_{1}s_{3}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f47d2cef1c56a3058cf76c6717c72266c1588\u003cbr\u003edcf5)\u003cbr\u003e|  X  1  Y  2  Z  3  =  [  c  2  c  3  \u2212  c  2  s  3  s  2  c  1  s  3  \\+  c\u003cbr\u003e3  s  1  s  2  c  1  c  3  \u2212  s  1  s  2  s  3  \u2212  c  2  s  1  s  1  s  3  \u2212\u003cbr\u003ec  1  c  3  s  2  c  3  s  1  \\+  c  1  s  2  s  3  c  1  c  2  ]\u003cbr\u003e{\\displaystyle\u003cbr\u003eX_{1}Y_{2}Z_{3}={\\begin{bmatrix}c_{2}c_{3}&-c_{2}s_{3}&s_{2}\\\\\\c_{1}s_{3}+c_{3}s_{1}s_{2}&c_{1}c_{3}-s_{1}s_{2}s_{3}&-\u003cbr\u003ec_{2}s_{1}\\\\\\s_{1}s_{3}-c_{1}c_{3}s_{2}&c_{3}s_{1}+c_{1}s_{2}s_{3}&c_{1}c_{2}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eX_{1}Y_{2}Z_{3}={\\\\begin{bmatrix}c_{2}c_{3}&-c_{2}s_{3}&s_{2}\\\\\\\\c_{1}s_{3}+c_{3}s_{1}s_{2}&c_{1}c_{3}-s_{1}s_{2}s_{3}&-\u003cbr\u003ec_{2}s_{1}\\\\\\\\s_{1}s_{3}-\u003cbr\u003ec_{1}c_{3}s_{2}&c_{3}s_{1}+c_{1}s_{2}s_{3}&c_{1}c_{2}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frend\u003cbr\u003eer\u002fsvg\u002f88ca944aa8cbd89b7116b5171bd85a65472b5f9d)\u003cbr\u003eY  1  X  2  Y  3  =  [  c  1  c  3  \u2212  c  2  s  1  s  3  s  1  s  2  c  1  s\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e3  \\+  c  2  c  3  s  1  s  2  s  3  c  2  \u2212  c  3  s  2  \u2212  c  3  s  1  \u2212  c\u003cbr\u003e1  c  2  s  3  c  1  s  2  c  1  c  2  c  3  \u2212  s  1  s  3  ]  {\\displaystyle\u003cbr\u003eY_{1}X_{2}Y_{3}={\\begin{bmatrix}c_{1}c_{3}-c_{2}s_{1}s_{3}&s_{1}s_{2}&c_{1}s_{3}+c_{2}c_{3}s_{1}\\\\\\s_{2}s_{3}&c_{2}&-\u003cbr\u003ec_{3}s_{2}\\\\\\\\-c_{3}s_{1}-c_{1}c_{2}s_{3}&c_{1}s_{2}&c_{1}c_{2}c_{3}-s_{1}s_{3}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eY_{1}X_{2}Y_{3}={\\\\begin{bmatrix}c_{1}c_{3}-c_{2}s_{1}s_{3}&s_{1}s_{2}&c_{1}s_{3}+c_{2}c_{3}s_{1}\\\\\\\\s_{2}s_{3}&c_{2}&-\u003cbr\u003ec_{3}s_{2}\\\\\\\\-c_{3}s_{1}-c_{1}c_{2}s_{3}&c_{1}s_{2}&c_{1}c_{2}c_{3}-\u003cbr\u003es_{1}s_{3}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fc36e63d05a8166d8162ee9e29dd60fa4e404\u003cbr\u003e68de)\u003cbr\u003e|  Y  1  X  2  Z  3  =  [  c  1  c  3  \\+  s  1  s  2  s  3  c  3  s  1  s  2\u003cbr\u003e\u2212  c  1  s  3  c  2  s  1  c  2  s  3  c  2  c  3  \u2212  s  2  c  1  s  2  s  3\u003cbr\u003e\u2212  c  3  s  1  c  1  c  3  s  2  \\+  s  1  s  3  c  1  c  2  ]  {\\displaystyle\u003cbr\u003eY_{1}X_{2}Z_{3}={\\begin{bmatrix}c_{1}c_{3}+s_{1}s_{2}s_{3}&c_{3}s_{1}s_{2}-\u003cbr\u003ec_{1}s_{3}&c_{2}s_{1}\\\\\\c_{2}s_{3}&c_{2}c_{3}&-s_{2}\\\\\\c_{1}s_{2}s_{3}-\u003cbr\u003ec_{3}s_{1}&c_{1}c_{3}s_{2}+s_{1}s_{3}&c_{1}c_{2}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eY_{1}X_{2}Z_{3}={\\\\begin{bmatrix}c_{1}c_{3}+s_{1}s_{2}s_{3}&c_{3}s_{1}s_{2}-\u003cbr\u003ec_{1}s_{3}&c_{2}s_{1}\\\\\\\\c_{2}s_{3}&c_{2}c_{3}&-s_{2}\\\\\\\\c_{1}s_{2}s_{3}-\u003cbr\u003ec_{3}s_{1}&c_{1}c_{3}s_{2}+s_{1}s_{3}&c_{1}c_{2}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsv\u003cbr\u003eg\u002f315bca69e4cbda3218014b5a9b4878aa89231064)\u003cbr\u003eY  1  Z  2  Y  3  =  [  c  1  c  2  c  3  \u2212  s  1  s  3  \u2212  c  1  s  2  c  3\u003cbr\u003es  1  \\+  c  1  c  2  s  3  c  3  s  2  c  2  s  2  s  3  \u2212  c  1  s  3  \u2212  c\u003cbr\u003e2  c  3  s  1  s  1  s  2  c  1  c  3  \u2212  c  2  s  1  s  3  ]  {\\displaystyle\u003cbr\u003eY_{1}Z_{2}Y_{3}={\\begin{bmatrix}c_{1}c_{2}c_{3}-s_{1}s_{3}&-\u003cbr\u003ec_{1}s_{2}&c_{3}s_{1}+c_{1}c_{2}s_{3}\\\\\\c_{3}s_{2}&c_{2}&s_{2}s_{3}\\\\\\\\-c_{1}s_{3}-\u003cbr\u003ec_{2}c_{3}s_{1}&s_{1}s_{2}&c_{1}c_{3}-c_{2}s_{1}s_{3}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eY_{1}Z_{2}Y_{3}={\\\\begin{bmatrix}c_{1}c_{2}c_{3}-s_{1}s_{3}&-\u003cbr\u003ec_{1}s_{2}&c_{3}s_{1}+c_{1}c_{2}s_{3}\\\\\\\\c_{3}s_{2}&c_{2}&s_{2}s_{3}\\\\\\\\-c_{1}s_{3}-\u003cbr\u003ec_{2}c_{3}s_{1}&s_{1}s_{2}&c_{1}c_{3}-\u003cbr\u003ec_{2}s_{1}s_{3}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002ffd69086f396f6ef72eed8e95b333537\u003cbr\u003eb60b406c9)\u003cbr\u003e|  Y  1  Z  2  X  3  =  [  c  1  c  2  s  1  s  3  \u2212  c  1  c  3  s  2  c  3\u003cbr\u003es  1  \\+  c  1  s  2  s  3  s  2  c  2  c  3  \u2212  c  2  s  3  \u2212  c  2  s  1  c\u003cbr\u003e1  s  3  \\+  c  3  s  1  s  2  c  1  c  3  \u2212  s  1  s  2  s  3  ]\u003cbr\u003e{\\displaystyle\u003cbr\u003eY_{1}Z_{2}X_{3}={\\begin{bmatrix}c_{1}c_{2}&s_{1}s_{3}-c_{1}c_{3}s_{2}&c_{3}s_{1}+c_{1}s_{2}s_{3}\\\\\\s_{2}&c_{2}c_{3}&-\u003cbr\u003ec_{2}s_{3}\\\\\\\\-c_{2}s_{1}&c_{1}s_{3}+c_{3}s_{1}s_{2}&c_{1}c_{3}-s_{1}s_{2}s_{3}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eY_{1}Z_{2}X_{3}={\\\\begin{bmatrix}c_{1}c_{2}&s_{1}s_{3}-c_{1}c_{3}s_{2}&c_{3}s_{1}+c_{1}s_{2}s_{3}\\\\\\\\s_{2}&c_{2}c_{3}&-\u003cbr\u003ec_{2}s_{3}\\\\\\\\-c_{2}s_{1}&c_{1}s_{3}+c_{3}s_{1}s_{2}&c_{1}c_{3}-\u003cbr\u003es_{1}s_{2}s_{3}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fecef3eab0b5f54b66c7107f3ceeeb31\u003cbr\u003e9a2e0e756)\u003cbr\u003eZ  1  Y  2  Z  3  =  [  c  1  c  2  c  3  \u2212  s  1  s  3  \u2212  c  3  s  1  \u2212  c\u003cbr\u003e1  c  2  s  3  c  1  s  2  c  1  s  3  \\+  c  2  c  3  s  1  c  1  c  3  \u2212  c\u003cbr\u003e2  s  1  s  3  s  1  s  2  \u2212  c  3  s  2  s  2  s  3  c  2  ]  {\\displaystyle\u003cbr\u003eZ_{1}Y_{2}Z_{3}={\\begin{bmatrix}c_{1}c_{2}c_{3}-s_{1}s_{3}&-c_{3}s_{1}-\u003cbr\u003ec_{1}c_{2}s_{3}&c_{1}s_{2}\\\\\\c_{1}s_{3}+c_{2}c_{3}s_{1}&c_{1}c_{3}-c_{2}s_{1}s_{3}&s_{1}s_{2}\\\\\\\\-\u003cbr\u003ec_{3}s_{2}&s_{2}s_{3}&c_{2}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eZ_{1}Y_{2}Z_{3}={\\\\begin{bmatrix}c_{1}c_{2}c_{3}-s_{1}s_{3}&-c_{3}s_{1}-\u003cbr\u003ec_{1}c_{2}s_{3}&c_{1}s_{2}\\\\\\\\c_{1}s_{3}+c_{2}c_{3}s_{1}&c_{1}c_{3}-c_{2}s_{1}s_{3}&s_{1}s_{2}\\\\\\\\-\u003cbr\u003ec_{3}s_{2}&s_{2}s_{3}&c_{2}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f547e522037de6467d94\u003cbr\u003e8ecf3f7409975fe849d07)\u003cbr\u003e|  Z  1  Y  2  X  3  =  [  c  1  c  2  c  1  s  2  s  3  \u2212  c  3  s  1  s  1\u003cbr\u003es  3  \\+  c  1  c  3  s  2  c  2  s  1  c  1  c  3  \\+  s  1  s  2  s  3  c  3\u003cbr\u003es  1  s  2  \u2212  c  1  s  3  \u2212  s  2  c  2  s  3  c  2  c  3  ]  {\\displaystyle\u003cbr\u003eZ_{1}Y_{2}X_{3}={\\begin{bmatrix}c_{1}c_{2}&c_{1}s_{2}s_{3}-\u003cbr\u003ec_{3}s_{1}&s_{1}s_{3}+c_{1}c_{3}s_{2}\\\\\\c_{2}s_{1}&c_{1}c_{3}+s_{1}s_{2}s_{3}&c_{3}s_{1}s_{2}-c_{1}s_{3}\\\\\\\\-\u003cbr\u003es_{2}&c_{2}s_{3}&c_{2}c_{3}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eZ_{1}Y_{2}X_{3}={\\\\begin{bmatrix}c_{1}c_{2}&c_{1}s_{2}s_{3}-\u003cbr\u003ec_{3}s_{1}&s_{1}s_{3}+c_{1}c_{3}s_{2}\\\\\\\\c_{2}s_{1}&c_{1}c_{3}+s_{1}s_{2}s_{3}&c_{3}s_{1}s_{2}-c_{1}s_{3}\\\\\\\\-\u003cbr\u003es_{2}&c_{2}s_{3}&c_{2}c_{3}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f45583b01e584306f30f\u003cbr\u003e616307c8e53c349705b12)\u003cbr\u003eZ  1  X  2  Z  3  =  [  c  1  c  3  \u2212  c  2  s  1  s  3  \u2212  c  1  s  3  \u2212  c\u003cbr\u003e2  c  3  s  1  s  1  s  2  c  3  s  1  \\+  c  1  c  2  s  3  c  1  c  2  c  3\u003cbr\u003e\u2212  s  1  s  3  \u2212  c  1  s  2  s  2  s  3  c  3  s  2  c  2  ]  {\\displaystyle\u003cbr\u003eZ_{1}X_{2}Z_{3}={\\begin{bmatrix}c_{1}c_{3}-c_{2}s_{1}s_{3}&-c_{1}s_{3}-\u003cbr\u003ec_{2}c_{3}s_{1}&s_{1}s_{2}\\\\\\c_{3}s_{1}+c_{1}c_{2}s_{3}&c_{1}c_{2}c_{3}-s_{1}s_{3}&-\u003cbr\u003ec_{1}s_{2}\\\\\\s_{2}s_{3}&c_{3}s_{2}&c_{2}\\end{bmatrix}}}\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eZ_{1}X_{2}Z_{3}={\\\\begin{bmatrix}c_{1}c_{3}-c_{2}s_{1}s_{3}&-c_{1}s_{3}-\u003cbr\u003ec_{2}c_{3}s_{1}&s_{1}s_{2}\\\\\\\\c_{3}s_{1}+c_{1}c_{2}s_{3}&c_{1}c_{2}c_{3}-s_{1}s_{3}&-\u003cbr\u003ec_{1}s_{2}\\\\\\\\s_{2}s_{3}&c_{3}s_{2}&c_{2}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f1ece1\u003cbr\u003e22a99938c6d8209a08822ec978d9492a170)\u003cbr\u003e|  Z  1  X  2  Y  3  =  [  c  1  c  3  \u2212  s  1  s  2  s  3  \u2212  c  2  s  1  c\u003cbr\u003e1  s  3  \\+  c  3  s  1  s  2  c  3  s  1  \\+  c  1  s  2  s  3  c  1  c  2  s\u003cbr\u003e1  s  3  \u2212  c  1  c  3  s  2  \u2212  c  2  s  3  s  2  c  2  c  3  ]\u003cbr\u003e{\\displaystyle\u003cbr\u003eZ_{1}X_{2}Y_{3}={\\begin{bmatrix}c_{1}c_{3}-s_{1}s_{2}s_{3}&-\u003cbr\u003ec_{2}s_{1}&c_{1}s_{3}+c_{3}s_{1}s_{2}\\\\\\c_{3}s_{1}+c_{1}s_{2}s_{3}&c_{1}c_{2}&s_{1}s_{3}-c_{1}c_{3}s_{2}\\\\\\\\-\u003cbr\u003ec_{2}s_{3}&s_{2}&c_{2}c_{3}\\end{bmatrix}}}\u003cbr\u003e![{\\\\displaystyle\u003cbr\u003eZ_{1}X_{2}Y_{3}={\\\\begin{bmatrix}c_{1}c_{3}-s_{1}s_{2}s_{3}&-\u003cbr\u003ec_{2}s_{1}&c_{1}s_{3}+c_{3}s_{1}s_{2}\\\\\\\\c_{3}s_{1}+c_{1}s_{2}s_{3}&c_{1}c_{2}&s_{1}s_{3}-c_{1}c_{3}s_{2}\\\\\\\\-\u003cbr\u003ec_{2}s_{3}&s_{2}&c_{2}c_{3}\\\\end{bmatrix}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f3e7474f3e097e2f4bfe\u003cbr\u003e1e529fa321b5e0645275c)\u003cbr\u003e\u003cbr\u003eThese tabular results are available in numerous textbooks.  [3]  For each\u003cbr\u003ecolumn the last row constitutes the most commonly used convention.\u003cbr\u003e\u003cbr\u003eTo change the formulas for [ passive rotations\u003cbr\u003e](\u002fwiki\u002fActive_and_passive_transformation \"Active and passive transformation\")\u003cbr\u003e(or find reverse active rotation), transpose the matrices (then each matrix\u003cbr\u003etransforms the initial coordinates of a vector remaining fixed to the\u003cbr\u003ecoordinates of the same vector measured in the rotated reference system; same\u003cbr\u003erotation axis, same angles, but now the coordinate system rotates, rather than\u003cbr\u003ethe vector).\u003cbr\u003e\u003cbr\u003eThe following table contains formulas for angles _\u03b1_ , _\u03b2_ and _\u03b3_ from\u003cbr\u003eelements of a rotation matrix  R  {\\displaystyle R}  ![{\\\\displaystyle\u003cbr\u003eR}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f4b0bfb3769bf24d80e15374dc37b0441e2616e33)\u003cbr\u003e.  [4]\u003cbr\u003e\u003cbr\u003eProper Euler angles  |  Tait\u2013Bryan angles\u003cbr\u003e---|---\u003cbr\u003eX  1  Z  2  X  3  {\\displaystyle X_{1}Z_{2}X_{3}}  ![{\\\\displaystyle\u003cbr\u003eX_{1}Z_{2}X_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f2120abc322b20746d8370400094ae58e611a62b5)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  31  R  21  )  \u03b2  =  arccos  \u2061  (  R  11  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  R  13  \u2212  R  12  )  {\\displaystyle {\\begin{aligned}\\alpha\u003cbr\u003e&=\\arctan \\left({\\frac {R_{31}}{R_{21}}}\\right)\\\\\\\\\\beta &=\\arccos\u003cbr\u003e\\left(R_{11}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{13}}{-R_{12}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{31}}{R_{21}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arccos\u003cbr\u003e\\\\left\\(R_{11}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{13}}{-\u003cbr\u003eR_{12}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f2a60297970c8ab4a380e8594162e3\u003cbr\u003e06031402ef1)\u003cbr\u003e|  X  1  Z  2  Y  3  {\\displaystyle X_{1}Z_{2}Y_{3}}  ![{\\\\displaystyle\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eX_{1}Z_{2}Y_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f6132b5a07bc489a7819a834290adf64bf968dc5b)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  32  R  22  )  \u03b2  =  arcsin  \u2061  (  \u2212  R  12  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  R  13  R  11  )  {\\displaystyle {\\begin{aligned}\\alpha &=\\arctan\u003cbr\u003e\\left({\\frac {R_{32}}{R_{22}}}\\right)\\\\\\\\\\beta &=\\arcsin\u003cbr\u003e\\left(-R_{12}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{13}}{R_{11}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{32}}{R_{22}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arcsin\u003cbr\u003e\\\\left\\(-R_{12}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{13}}{R_{11}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f057359d6c67e71b3471c\u003cbr\u003e0992774191a437a0fce4)\u003cbr\u003eX  1  Y  2  X  3  {\\displaystyle X_{1}Y_{2}X_{3}}  ![{\\\\displaystyle\u003cbr\u003eX_{1}Y_{2}X_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fb5aa1024dd01c7c205d18ce0f284933fefa34478)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  21  \u2212  R  31  )  \u03b2  =  arccos  \u2061  (  R  11  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  R  12  R  13  )  {\\displaystyle {\\begin{aligned}\\alpha &=\\arctan\u003cbr\u003e\\left({\\frac {R_{21}}{-R_{31}}}\\right)\\\\\\\\\\beta &=\\arccos\u003cbr\u003e\\left(R_{11}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{12}}{R_{13}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{21}}{-R_{31}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arccos\u003cbr\u003e\\\\left\\(R_{11}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{12}}{R_{13}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fad683b2f2cb437e91a87\u003cbr\u003e004f7122b3b9345b6376)\u003cbr\u003e|  X  1  Y  2  Z  3  {\\displaystyle X_{1}Y_{2}Z_{3}}  ![{\\\\displaystyle\u003cbr\u003eX_{1}Y_{2}Z_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f9f81275ed116f46f2713fe429098e850f4e7023e)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  \u2212  R  23  R  33  )  \u03b2  =  arcsin  \u2061  (  R  13  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  \u2212  R  12  R  11  )  {\\displaystyle {\\begin{aligned}\\alpha\u003cbr\u003e&=\\arctan \\left({\\frac {-R_{23}}{R_{33}}}\\right)\\\\\\\\\\beta &=\\arcsin\u003cbr\u003e\\left(R_{13}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{-R_{12}}{R_{11}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{-R_{23}}{R_{33}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arcsin\u003cbr\u003e\\\\left\\(R_{13}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{-\u003cbr\u003eR_{12}}{R_{11}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f20c6d5b555b92f381f509\u003cbr\u003e3a6fe2c0bcfb78cec7a)\u003cbr\u003eY  1  X  2  Y  3  {\\displaystyle Y_{1}X_{2}Y_{3}}  ![{\\\\displaystyle\u003cbr\u003eY_{1}X_{2}Y_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f3d4dc89572b6e56ab27d0aa8a9291c0f0c343cc8)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  12  R  32  )  \u03b2  =  arccos  \u2061  (  R  22  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  R  21  \u2212  R  23  )  {\\displaystyle {\\begin{aligned}\\alpha\u003cbr\u003e&=\\arctan \\left({\\frac {R_{12}}{R_{32}}}\\right)\\\\\\\\\\beta &=\\arccos\u003cbr\u003e\\left(R_{22}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{21}}{-R_{23}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e{R_{12}}{R_{32}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arccos\u003cbr\u003e\\\\left\\(R_{22}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{21}}{-\u003cbr\u003eR_{23}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f79d0e766630793343a7bb9926d2b8\u003cbr\u003e96c8d95d888)\u003cbr\u003e|  Y  1  X  2  Z  3  {\\displaystyle Y_{1}X_{2}Z_{3}}  ![{\\\\displaystyle\u003cbr\u003eY_{1}X_{2}Z_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fcf11bab4d3cfb6ae7f335cdfe5c683397988e304)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  13  R  33  )  \u03b2  =  arcsin  \u2061  (  \u2212  R  23  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  R  21  R  22  )  {\\displaystyle {\\begin{aligned}\\alpha &=\\arctan\u003cbr\u003e\\left({\\frac {R_{13}}{R_{33}}}\\right)\\\\\\\\\\beta &=\\arcsin\u003cbr\u003e\\left(-R_{23}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{21}}{R_{22}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{13}}{R_{33}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arcsin\u003cbr\u003e\\\\left\\(-R_{23}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{21}}{R_{22}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f4aeff9f3d48728728959\u003cbr\u003e44dfa7631f6a5e1c0fa1)\u003cbr\u003eY  1  Z  2  Y  3  {\\displaystyle Y_{1}Z_{2}Y_{3}}  ![{\\\\displaystyle\u003cbr\u003eY_{1}Z_{2}Y_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f24c60ded9a485e2ea6398cd8e17a802bca2842a5)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  32  \u2212  R  12  )  \u03b2  =  arccos  \u2061  (  R  22  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  R  23  R  21  )  {\\displaystyle {\\begin{aligned}\\alpha &=\\arctan\u003cbr\u003e\\left({\\frac {R_{32}}{-R_{12}}}\\right)\\\\\\\\\\beta &=\\arccos\u003cbr\u003e\\left(R_{22}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{23}}{R_{21}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{32}}{-R_{12}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arccos\u003cbr\u003e\\\\left\\(R_{22}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{23}}{R_{21}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f5094c5d11a4ddea15c84\u003cbr\u003ebcebd4a475ad80387dc7)\u003cbr\u003e|  Y  1  Z  2  X  3  {\\displaystyle Y_{1}Z_{2}X_{3}}  ![{\\\\displaystyle\u003cbr\u003eY_{1}Z_{2}X_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002ffb6fe9061d2f5dbe129c897ad99c7b15495d38ed)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  \u2212  R  31  R  11  )  \u03b2  =  arcsin  \u2061  (  R  21  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  \u2212  R  23  R  22  )  {\\displaystyle {\\begin{aligned}\\alpha\u003cbr\u003e&=\\arctan \\left({\\frac {-R_{31}}{R_{11}}}\\right)\\\\\\\\\\beta &=\\arcsin\u003cbr\u003e\\left(R_{21}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{-R_{23}}{R_{22}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{-R_{31}}{R_{11}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arcsin\u003cbr\u003e\\\\left\\(R_{21}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{-\u003cbr\u003eR_{23}}{R_{22}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f49ced612c5d4fa1d21688\u003cbr\u003e28b2f5d090868e6bcd0)\u003cbr\u003eZ  1  Y  2  Z  3  {\\displaystyle Z_{1}Y_{2}Z_{3}}  ![{\\\\displaystyle\u003cbr\u003eZ_{1}Y_{2}Z_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f9a32fd1f8d2cbc88de64e7b9c5d74bb38bf0a7a4)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  23  R  13  )  \u03b2  =  arctan  \u2061  (  1  \u2212  R  33  2  R\u003cbr\u003e33  )  \u03b3  =  arctan  \u2061  (  R  32  \u2212  R  31  )  {\\displaystyle\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 4)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.025\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e{\\begin{aligned}\\alpha &=\\arctan \\left({\\frac\u003cbr\u003e{R_{23}}{R_{13}}}\\right)\\\\\\\\\\beta &=\\arctan \\left({\\frac {\\sqrt\u003cbr\u003e{1-R_{33}^{2}}}{R_{33}}}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{32}}{-R_{31}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{23}}{R_{13}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arctan \\\\left\\({\\\\frac {\\\\sqrt\u003cbr\u003e{1-R_{33}^{2}}}{R_{33}}}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{32}}{-\u003cbr\u003eR_{31}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f3064add5d6e4052484af05d266811\u003cbr\u003e9b3db2d05c1)\u003cbr\u003e|  Z  1  Y  2  X  3  {\\displaystyle Z_{1}Y_{2}X_{3}}  ![{\\\\displaystyle\u003cbr\u003eZ_{1}Y_{2}X_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f6b2027fdaa07545cb39440c1b7d0e1bee117b833)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  21  R  11  )  \u03b2  =  arcsin  \u2061  (  \u2212  R  31  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  R  32  R  33  )  {\\displaystyle {\\begin{aligned}\\alpha &=\\arctan\u003cbr\u003e\\left({\\frac {R_{21}}{R_{11}}}\\right)\\\\\\\\\\beta &=\\arcsin\u003cbr\u003e\\left(-R_{31}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{32}}{R_{33}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{21}}{R_{11}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arcsin\u003cbr\u003e\\\\left\\(-R_{31}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{32}}{R_{33}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f64f454cf0385512bc097\u003cbr\u003ecf0446253cbcc215a5ca)\u003cbr\u003eZ  1  X  2  Z  3  {\\displaystyle Z_{1}X_{2}Z_{3}}  ![{\\\\displaystyle\u003cbr\u003eZ_{1}X_{2}Z_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f44c9522bee2a62caf2365b820b7ecb41bef0f5a4)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  R  13  \u2212  R  23  )  \u03b2  =  arccos  \u2061  (  R  33  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  R  31  R  32  )  {\\displaystyle {\\begin{aligned}\\alpha &=\\arctan\u003cbr\u003e\\left({\\frac {R_{13}}{-R_{23}}}\\right)\\\\\\\\\\beta &=\\arccos\u003cbr\u003e\\left(R_{33}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{R_{31}}{R_{32}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{13}}{-R_{23}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arccos\u003cbr\u003e\\\\left\\(R_{33}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{R_{31}}{R_{32}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002feb267cdf68a705d1e990\u003cbr\u003e6b03641f6b858611b18d)\u003cbr\u003e|  Z  1  X  2  Y  3  {\\displaystyle Z_{1}X_{2}Y_{3}}  ![{\\\\displaystyle\u003cbr\u003eZ_{1}X_{2}Y_{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f594724baacd982fcdb1ef2b4e382100d4f5ab9d4)\u003cbr\u003e|  \u03b1  =  arctan  \u2061  (  \u2212  R  12  R  22  )  \u03b2  =  arcsin  \u2061  (  R  32  )  \u03b3  =\u003cbr\u003earctan  \u2061  (  \u2212  R  31  R  33  )  {\\displaystyle {\\begin{aligned}\\alpha\u003cbr\u003e&=\\arctan \\left({\\frac {-R_{12}}{R_{22}}}\\right)\\\\\\\\\\beta &=\\arcsin\u003cbr\u003e\\left(R_{32}\\right)\\\\\\\\\\gamma &=\\arctan \\left({\\frac\u003cbr\u003e{-R_{31}}{R_{33}}}\\right)\\end{aligned}}}  ![{\\\\displaystyle\u003cbr\u003e{\\\\begin{aligned}\\\\alpha &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e{-R_{12}}{R_{22}}}\\\\right\\)\\\\\\\\\\\\beta &=\\\\arcsin\u003cbr\u003e\\\\left\\(R_{32}\\\\right\\)\\\\\\\\\\\\gamma &=\\\\arctan \\\\left\\({\\\\frac\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 5)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -144.492\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e{-\u003cbr\u003eR_{31}}{R_{33}}}\\\\right\\)\\\\end{aligned}}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f8fa86565a0ac3759723a7\u003cbr\u003e57b43bdc904000bbee8)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 6)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.071\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.071\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.100\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Properties  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=19 \"Edit section:\u003cbr\u003eProperties\") ]\u003cbr\u003e\u003cbr\u003eSee also: [ Charts on SO(3) ](\u002fwiki\u002fCharts_on_SO\\(3\\) \"Charts on SO\\(3\\)\") and\u003cbr\u003e[ Quaternions and spatial rotation ](\u002fwiki\u002fQuaternions_and_spatial_rotation\u003cbr\u003e\"Quaternions and spatial rotation\")\u003cbr\u003e\u003cbr\u003eThe Euler angles form a [ chart ](\u002fwiki\u002fChart_\\(topology\\) \"Chart\u003cbr\u003e\\(topology\\)\") on all of [ SO(3) ](\u002fwiki\u002fSO\\(3\\) \"SO\\(3\\)\") , the [ special\u003cbr\u003eorthogonal group ](\u002fwiki\u002fSpecial_orthogonal_group \"Special orthogonal group\")\u003cbr\u003eof rotations in 3D space. The chart is smooth except for a polar coordinate\u003cbr\u003estyle singularity along  _\u03b2_ = 0  . See [ charts on SO(3)\u003cbr\u003e](\u002fwiki\u002fCharts_on_SO\\(3\\) \"Charts on SO\\(3\\)\") for a more complete treatment.\u003cbr\u003e\u003cbr\u003eThe space of rotations is called in general \"The [ Hypersphere of rotations\u003cbr\u003e](\u002fwiki\u002fQuaternions_and_spatial_rotation\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 7)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.021\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eQuaternion_rotation_operations\u003cbr\u003e\"Quaternions and spatial rotation\") \", though this is a misnomer: the group [\u003cbr\u003eSpin(3) ](\u002fwiki\u002fSpin_group \"Spin group\") is [ isometric\u003cbr\u003e](\u002fwiki\u002fIsometric_embedding \"Isometric embedding\") to the hypersphere _S_ 3  ,\u003cbr\u003ebut the rotation space SO(3) is instead isometric to the [ real projective\u003cbr\u003espace ](\u002fwiki\u002fReal_projective_space \"Real projective space\") **RP** 3  which\u003cbr\u003eis a 2-fold [ quotient space ](\u002fwiki\u002fQuotient_space_\\(topology\\) \"Quotient\u003cbr\u003espace \\(topology\\)\") of the hypersphere. This 2-to-1 ambiguity is the\u003cbr\u003emathematical origin of [ spin in physics ](\u002fwiki\u002fSpin_\\(physics\\) \"Spin\u003cbr\u003e\\(physics\\)\") .\u003cbr\u003e\u003cbr\u003eA similar three angle decomposition applies to [ SU(2) ](\u002fwiki\u002fSU\\(2\\)\u003cbr\u003e\"SU\\(2\\)\") , the [ special unitary group ](\u002fwiki\u002fSpecial_unitary_group\u003cbr\u003e\"Special unitary group\") of rotations in complex 2D space, with the difference\u003cbr\u003ethat _\u03b2_ ranges from 0 to 2  \u03c0  . These are also called Euler angles.\u003cbr\u003e\u003cbr\u003eThe [ Haar measure ](\u002fwiki\u002fHaar_measure \"Haar measure\") for SO(3) in Euler\u003cbr\u003eangles is given by the Hopf angle parametrisation of SO(3),  d  V  \u221d  sin  \u2061\u003cbr\u003e\u03b2  \u22c5  d  \u03b1  \u22c5  d  \u03b2  \u22c5  d  \u03b3  {\\displaystyle {\\textrm {d}}V\\propto \\sin \\beta\u003cbr\u003e\\cdot {\\textrm {d}}\\alpha \\cdot {\\textrm {d}}\\beta \\cdot {\\textrm {d}}\\gamma }\u003cbr\u003e![{\\\\displaystyle {\\\\textrm {d}}V\\\\propto \\\\sin \\\\beta \\\\cdot {\\\\textrm\u003cbr\u003e{d}}\\\\alpha \\\\cdot {\\\\textrm {d}}\\\\beta \\\\cdot {\\\\textrm {d}}\\\\gamma\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f602d68d90afe60bb8d1e9716d65660e9a3ee572d)\u003cbr\u003e,  [5]  where  (  \u03b2  ,  \u03b1  )  {\\displaystyle (\\beta ,\\alpha )}\u003cbr\u003e![{\\\\displaystyle \\(\\\\beta ,\\\\alpha\u003cbr\u003e\\)}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fd79a12da16d412fda0e803ce946e1c3167238d49)\u003cbr\u003eparametrise  S  2  {\\displaystyle S^{2}}  ![{\\\\displaystyle\u003cbr\u003eS^{2}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f3b6401d5d0155afb1406770d1eb80badce4e08ce)\u003cbr\u003e, the space of rotation axes.\u003cbr\u003e\u003cbr\u003eFor example, to generate uniformly randomized orientations, let _\u03b1_ and _\u03b3_ be\u003cbr\u003euniform from 0 to 2  \u03c0  , let _z_ be uniform from \u22121 to 1, and let  _\u03b2_ =\u003cbr\u003earccos( _z_ )  .\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 8)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.021\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Geometric algebra  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=20 \"Edit section:\u003cbr\u003eGeometric algebra\") ]\u003cbr\u003e\u003cbr\u003eOther properties of Euler angles and rotations in general can be found from\u003cbr\u003ethe [ geometric algebra ](\u002fwiki\u002fGeometric_algebra \"Geometric algebra\") , a\u003cbr\u003ehigher level abstraction, in which the quaternions are an even subalgebra. The\u003cbr\u003eprincipal tool in geometric algebra is the rotor  R  =  [  cos  \u2061  (  \u03b8  \u002f  2\u003cbr\u003e)  \u2212  I  u  sin  \u2061  (  \u03b8  \u002f  2  )  ]  {\\displaystyle \\mathbf {R} =[\\cos(\\theta\u003cbr\u003e\u002f2)-Iu\\sin(\\theta \u002f2)]}  ![{\\\\displaystyle \\\\mathbf {R} =\\[\\\\cos\\(\\\\theta\u003cbr\u003e\u002f2\\)-Iu\\\\sin\\(\\\\theta\u003cbr\u003e\u002f2\\)\\]}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002fccaf9643d65a54a5bd1b4d962d07f605c9c67648)\u003cbr\u003ewhere  \u03b8  =  {\\displaystyle \\theta =}  ![{\\\\displaystyle \\\\theta\u003cbr\u003e=}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f9cdf817a63d001b9c002aacbbc5fecb60bc86527)\u003cbr\u003e[ angle of rotation ](\u002fwiki\u002fAngle_of_rotation \"Angle of rotation\") ,  u\u003cbr\u003e{\\displaystyle \\mathbf {u} }  ![{\\\\displaystyle \\\\mathbf {u}\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f261e20fe101de02a771021d9d4466c0ad3e352d7)\u003cbr\u003eis the rotation axis (unitary vector) and  I  {\\displaystyle \\mathbf {I} }\u003cbr\u003e![{\\\\displaystyle \\\\mathbf {I}\u003cbr\u003e}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002f8a458c8aeb096ce732abf346ae8edf3e4f53a126)\u003cbr\u003eis the pseudoscalar (trivector in  R  3  {\\displaystyle \\mathbb {R} ^{3}}\u003cbr\u003e![{\\\\displaystyle \\\\mathbb {R}\u003cbr\u003e^{3}}](https:\u002f\u002fwikimedia.org\u002fapi\u002frest_v1\u002fmedia\u002fmath\u002frender\u002fsvg\u002ff936ddf584f8f3dd2a0ed08917001b7a404c10b5)\u003cbr\u003e)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 9)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.021\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Higher dimensions  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=21 \"Edit section: Higher\u003cbr\u003edimensions\") ]\u003cbr\u003e\u003cbr\u003eIt is possible to define parameters analogous to the Euler angles in\u003cbr\u003edimensions higher than three.  [6]  [ _[ unreliable source?\u003cbr\u003e](\u002fwiki\u002fWikipedia:Reliable_sources \"Wikipedia:Reliable sources\") _ ]  In four\u003cbr\u003edimensions and above, the concept of \"rotation about an axis\" loses meaning\u003cbr\u003eand instead becomes \"rotation in a plane.\" The number of Euler angles needed\u003cbr\u003eto represent the group  SO( _n_ )  is  _n_ ( _n_ \u2212 1)\u002f2  , equal to the number\u003cbr\u003eof planes containing two distinct coordinate axes in _n_ -dimensional\u003cbr\u003eEuclidean space.\u003cbr\u003e\u003cbr\u003eIn [ SO(4) ](\u002fwiki\u002fSO\\(4\\) \"SO\\(4\\)\") a rotation matrix [ is defined by two\u003cbr\u003eunit quaternions ](\u002fwiki\u002fRotation_\\(mathematics\\)\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 10)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.023\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eIn_four_dimensions \"Rotation\u003cbr\u003e\\(mathematics\\)\") , and therefore has six degrees of freedom, three from each\u003cbr\u003equaternion.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 11)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.021\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Applications  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=22 \"Edit section:\u003cbr\u003eApplications\") ]\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 12)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.588\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.261\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.400\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Vehicles and moving frames  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=23 \"Edit section:\u003cbr\u003eVehicles and moving frames\") ]\u003cbr\u003e\u003cbr\u003eMain article: [ rigid body ](\u002fwiki\u002fRigid_body \"Rigid body\")\u003cbr\u003e\u003cbr\u003eSee also: [ axes conventions ](\u002fwiki\u002fAxes_conventions \"Axes conventions\")\u003cbr\u003e\u003cbr\u003eTheir main advantage over other orientation descriptions is that they are\u003cbr\u003edirectly measurable from a gimbal mounted in a vehicle. As gyroscopes keep\u003cbr\u003etheir rotation axis constant, angles measured in a gyro frame are equivalent\u003cbr\u003eto angles measured in the lab frame. Therefore, gyros are used to know the\u003cbr\u003eactual orientation of moving spacecraft, and Euler angles are directly\u003cbr\u003emeasurable. Intrinsic rotation angle cannot be read from a single gimbal, so\u003cbr\u003ethere has to be more than one gimbal in a spacecraft. Normally there are at\u003cbr\u003eleast three for redundancy. There is also a relation to the well-known [\u003cbr\u003egimbal lock ](\u002fwiki\u002fGimbal_lock \"Gimbal lock\") problem of [ mechanical\u003cbr\u003eengineering ](\u002fwiki\u002fMechanical_engineering \"Mechanical engineering\") .  [7]\u003cbr\u003e\u003cbr\u003eWhen studying rigid bodies in general, one calls the _xyz_ system _space\u003cbr\u003ecoordinates_ , and the _XYZ_ system _body coordinates_ . The space coordinates\u003cbr\u003eare treated as unmoving, while the body coordinates are considered embedded in\u003cbr\u003ethe moving body. Calculations involving [ acceleration ](\u002fwiki\u002fAcceleration\u003cbr\u003e\"Acceleration\") , [ angular acceleration ](\u002fwiki\u002fAngular_acceleration \"Angular\u003cbr\u003eacceleration\") , [ angular velocity ](\u002fwiki\u002fAngular_velocity \"Angular\u003cbr\u003evelocity\") , [ angular momentum ](\u002fwiki\u002fAngular_momentum \"Angular momentum\") ,\u003cbr\u003eand [ kinetic energy ](\u002fwiki\u002fKinetic_energy \"Kinetic energy\") are often\u003cbr\u003eeasiest in body coordinates, because then the moment of inertia tensor does\u003cbr\u003enot change in time. If one also diagonalizes the rigid body's moment of\u003cbr\u003einertia tensor (with nine components, six of which are independent), then one\u003cbr\u003ehas a set of coordinates (called the principal axes) in which the moment of\u003cbr\u003einertia tensor has only three components.\u003cbr\u003e\u003cbr\u003eThe angular velocity of a rigid body takes a [ simple form\u003cbr\u003e](\u002fwiki\u002fAngular_velocity\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 13)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.021\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003eComponents_from_Euler_angles \"Angular velocity\")\u003cbr\u003eusing Euler angles in the moving frame. Also the [ Euler's rigid body\u003cbr\u003eequations ](\u002fwiki\u002fEuler%27s_equations_\\(rigid_body_dynamics\\) \"Euler's\u003cbr\u003eequations \\(rigid body dynamics\\)\") are simpler because the inertia tensor is\u003cbr\u003econstant in that frame.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 14)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.021\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Crystallographic texture  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=24 \"Edit section:\u003cbr\u003eCrystallographic texture\") ]\u003cbr\u003e\u003cbr\u003e[ ![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f0\u002f0d\u002fMAUD-MTEX-TiAl-\u003cbr\u003ehasylab-2003-Liss.png\u002f220px-MAUD-MTEX-TiAl-hasylab-2003-Liss.png)\u003cbr\u003e](\u002fwiki\u002fFile:MAUD-MTEX-TiAl-hasylab-2003-Liss.png) Pole figures displaying\u003cbr\u003ecrystallographic texture of gamma-TiAl in an alpha2-gamma alloy, as measured\u003cbr\u003eby high energy X-rays.  [8]\u003cbr\u003e\u003cbr\u003eIn materials science, crystallographic [ texture\u003cbr\u003e](\u002fwiki\u002fTexture_\\(crystalline\\) \"Texture \\(crystalline\\)\") (or preferred\u003cbr\u003eorientation) can be described using Euler angles. In texture analysis, the\u003cbr\u003eEuler angles provide a mathematical depiction of the orientation of individual\u003cbr\u003ecrystallites within a polycrystalline material, allowing for the quantitative\u003cbr\u003edescription of the macroscopic material.  [9]  The most common definition of\u003cbr\u003ethe angles is due to Bunge and corresponds to the _ZXZ_ convention. It is\u003cbr\u003eimportant to note, however, that the application generally involves axis\u003cbr\u003etransformations of tensor quantities, i.e. passive rotations. Thus the matrix\u003cbr\u003ethat corresponds to the Bunge Euler angles is the transpose of that shown in\u003cbr\u003ethe table above.  [10]\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (0, 3, 3, 2, 15)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.021\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e  Others  [  [ edit\u003cbr\u003e](\u002fw\u002findex.php?title=Euler_angles&action=edit&section=25 \"Edit section:\u003cbr\u003eOthers\") ]\u003cbr\u003e\u003cbr\u003e[\u003cbr\u003e![](\u002f\u002fupload.wikimedia.org\u002fwikipedia\u002fcommons\u002fthumb\u002f8\u002f8a\u002fAutomation_of_foundry_with_robot.jpg\u002f220px-\u003cbr\u003eAutomation_of_foundry_with_robot.jpg)\u003cbr\u003e](\u002fwiki\u002fFile:Automation_of_foundry_with_robot.jpg) Industrial robot operating\u003cbr\u003ein a foundry\u003cbr\u003e\u003cbr\u003eEuler angles, normally in the Tait\u2013Bryan convention, are also used in [\u003cbr\u003erobotics ](\u002fwiki\u002fIndustrial_robot \"Industrial robot\") for speaking about the\u003cbr\u003edegrees of freedom of a [ wrist ](\u002fwiki\u002fRobotic_arm \"Robotic arm\") . They are\u003cbr\u003ealso used in [ electronic stability control\u003cbr\u003e](\u002fwiki\u002fElectronic_stability_control \"Electronic stability control\") in a\u003cbr\u003esimilar way.\u003cbr\u003e\u003cbr\u003eGun fire control systems require corrections to gun-order angles (bearing and\u003cbr\u003eelevation) to compensate for deck tilt (pitch and roll). In traditional\u003cbr\u003esystems, a stabilizing gyroscope with a vertical spin axis corrects for deck\u003cbr\u003etilt, and stabilizes the optical sights and radar antenna. However, gun\u003cbr\u003ebarrels point in a direction different from the line of sight to the target,\u003cbr\u003eto anticipate target movement and fall of the projectile due to gravity, among\u003cbr\u003eother factors. Gun mounts roll and pitch with the deck plane, but also require\u003cbr\u003estabilization. Gun orders include angles computed from the vertical gyro data,\u003cbr\u003eand those computations involve Euler angles.\u003cbr\u003e\u003cbr\u003eEuler angles are also used extensively in the quantum mechanics of angular\u003cbr\u003emomentum. In quantum mechanics, explicit descriptions of the representations\u003cbr\u003eof SO(3) are very important for calculations, and almost all the work has been\u003cbr\u003edone using Euler angles. In the early history of quantum mechanics, when\u003cbr\u003ephysicists and chemists had a sharply negative reaction towards abstract group\u003cbr\u003etheoretic methods (called the _Gruppenpest_ ), reliance on Euler angles was\u003cbr\u003ealso essential for basic theoretical work.\u003cbr\u003e\u003cbr\u003eMany mobile computing devices contain [ accelerometers ](\u002fwiki\u002fAccelerometer\u003cbr\u003e\"Accelerometer\") which can determine these devices' Euler angles with respect\u003cbr\u003eto the earth's gravitational attraction. These are used in applications such\u003cbr\u003eas games, [ bubble level ](\u002fwiki\u002fBubble_level \"Bubble level\") simulations, and\u003cbr\u003e[ kaleidoscopes ](\u002fwiki\u002fKaleidoscope \"Kaleidoscope\") .  [ _[ citation needed\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 0)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.872\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.784\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.900\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e###  Navigation\u003cbr\u003e  * [ index ](genindex.html \"General Index\")\u003cbr\u003e  * [ modules ](py-modindex.html \"Python Module Index\") |\u003cbr\u003e  * [ previous ](tf_python.html \"tf \\(Python\\)\") |\u003cbr\u003e  * [ tf 0.1.0 documentation ](index.html) \u00bb\u003cbr\u003e#  transformations  \u00c2\u00b6\u003cbr\u003eHomogeneous Transformation Matrices and Quaternions.\u003cbr\u003eA library for calculating 4x4 matrices for translating, rotating, reflecting,\u003cbr\u003escaling, shearing, projecting, orthogonalizing, and superimposing arrays of 3D\u003cbr\u003ehomogeneous coordinates as well as for converting between rotation matrices,\u003cbr\u003eEuler angles, and quaternions. Also includes an Arcball control object and\u003cbr\u003efunctions to decompose transformation matrices.\u003cbr\u003eAuthors:  |  [ Christoph Gohlke ](http:\u002f\u002fwww.lfd.uci.edu\u002f~gohlke\u002f) ,\u003cbr\u003eLaboratory for Fluorescence Dynamics, University of California, Irvine\u003cbr\u003e---|---\u003cbr\u003eVersion:  |  20090418\u003cbr\u003e\u003cbr\u003e##  Requirements  \u00c2\u00b6\u003cbr\u003e  * [ Python 2.6 ](http:\u002f\u002fwww.python.org)\u003cbr\u003e  * [ Numpy 1.3 ](http:\u002f\u002fnumpy.scipy.org)\u003cbr\u003e  * [ transformations.c 20090418 ](http:\u002f\u002fwww.lfd.uci.edu\u002f~gohlke\u002f) (optional implementation of some functions in C)\u003cbr\u003e##  Notes  \u00c2\u00b6\u003cbr\u003eMatrices (M) can be inverted using numpy.linalg.inv(M), concatenated using\u003cbr\u003enumpy.dot(M0, M1), or used to transform homogeneous coordinates (v) using\u003cbr\u003enumpy.dot(M, v) for shape (4, *) \u201cpoint of arrays\u201d, respectively numpy.dot(v,\u003cbr\u003eM.T) for shape (*, 4) \u201carray of points\u201d.\u003cbr\u003eCalculations are carried out with numpy.float64 precision.\u003cbr\u003eThis Python implementation is not optimized for speed.\u003cbr\u003eVector, point, quaternion, and matrix function arguments are expected to be\u003cbr\u003e\u201carray like\u201d, i.e. tuple, list, or numpy arrays.\u003cbr\u003eReturn types are numpy arrays unless specified otherwise.\u003cbr\u003eAngles are in radians unless specified otherwise.\u003cbr\u003eQuaternions ix+jy+kz+w are represented as [x, y, z, w].\u003cbr\u003eUse the transpose of transformation matrices for OpenGL glMultMatrixd().\u003cbr\u003eA triple of Euler angles can be applied\u002finterpreted in 24 ways, which can be\u003cbr\u003especified using a 4 character string or encoded 4-tuple:\u003cbr\u003e\u003e _Axes 4-string_ : e.g. \u2018sxyz\u2019 or \u2018ryxy\u2019\u003cbr\u003e\u003e\u003cbr\u003e\u003e   * first character : rotations are applied to \u2018s\u2019tatic or \u2018r\u2019otating frame\u003cbr\u003e\u003e   * remaining characters : successive rotation axis \u2018x\u2019, \u2018y\u2019, or \u2018z\u2019\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 1)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.813\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.667\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.750\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e\u003e\u003cbr\u003e\u003e\u003cbr\u003e\u003e _Axes 4-tuple_ : e.g. (0, 0, 0, 0) or (1, 1, 1, 1)\u003cbr\u003e\u003e\u003cbr\u003e\u003e   * inner axis: code of axis (\u2018x\u2019:0, \u2018y\u2019:1, \u2018z\u2019:2) of rightmost matrix.\u003cbr\u003e\u003e   * parity : even (0) if inner axis \u2018x\u2019 is followed by \u2018y\u2019, \u2018y\u2019 is followed\u003cbr\u003e\u003e by \u2018z\u2019, or \u2018z\u2019 is followed by \u2018x\u2019. Otherwise odd (1).\u003cbr\u003e\u003e   * repetition : first and last axis are same (1) or different (0).\u003cbr\u003e\u003e   * frame : rotations are applied to static (0) or rotating (1) frame.\u003cbr\u003e\u003e\u003cbr\u003e##  References  \u00c2\u00b6\u003cbr\u003e  1. Matrices and transformations. Ronald Goldman. In \u201cGraphics Gems I\u201d, pp 472-475. Morgan Kaufmann, 1990.\u003cbr\u003e  2. More matrices and transformations: shear and pseudo-perspective. Ronald Goldman. In \u201cGraphics Gems II\u201d, pp 320-323.\u003cbr\u003eMorgan Kaufmann, 1991.\u003cbr\u003e  3. Decomposing a matrix into simple transformations. Spencer Thomas. In \u201cGraphics Gems II\u201d, pp 320-323. Morgan\u003cbr\u003eKaufmann, 1991.\u003cbr\u003e  4. Recovering the data from the transformation matrix. Ronald Goldman. In \u201cGraphics Gems II\u201d, pp 324-331. Morgan\u003cbr\u003eKaufmann, 1991.\u003cbr\u003e  5. Euler angle conversion. Ken Shoemake. In \u201cGraphics Gems IV\u201d, pp 222-229. Morgan Kaufmann, 1994.\u003cbr\u003e  6. Arcball rotation control. Ken Shoemake. In \u201cGraphics Gems IV\u201d, pp 175-192. Morgan Kaufmann, 1994.\u003cbr\u003e  7. Representing attitude: Euler angles, unit quaternions, and rotation vectors. James Diebel. 2006.\u003cbr\u003e  8. A discussion of the solution for the best rotation to relate two sets of vectors. W Kabsch. Acta Cryst. 1978. A34,\u003cbr\u003e827-828.\u003cbr\u003e  9. Closed-form solution of absolute orientation using unit quaternions. BKP Horn. J Opt Soc Am A. 1987. 4(4), 629-642.\u003cbr\u003e  10. Quaternions. Ken Shoemake. [ http:\u002f\u002fwww.sfu.ca\u002f~jwa3\u002fcmpt461\u002ffiles\u002fquatut.pdf\u003cbr\u003e](http:\u002f\u002fwww.sfu.ca\u002f~jwa3\u002fcmpt461\u002ffiles\u002fquatut.pdf)\u003cbr\u003e  11. From quaternion to matrix and back. JMP van Waveren. 2005. [ http:\u002f\u002fwww.intel.com\u002fcd\u002fids\u002fdeveloper\u002fasmo-\u003cbr\u003ena\u002feng\u002f293748.htm ](http:\u002f\u002fwww.intel.com\u002fcd\u002fids\u002fdeveloper\u002fasmo-na\u002feng\u002f293748.htm)\u003cbr\u003e  12. Uniform random rotations. Ken Shoemake. In \u201cGraphics Gems III\u201d, pp 124-132. Morgan Kaufmann, 1992.\u003cbr\u003e##  Examples  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e alpha, beta, gamma = 0.123, -1.234, 2.345\u003cbr\u003e    \u003e\u003e\u003e origin, xaxis, yaxis, zaxis = (0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)\u003cbr\u003e    \u003e\u003e\u003e I = identity_matrix()\u003cbr\u003e    \u003e\u003e\u003e Rx = rotation_matrix(alpha, xaxis)\u003cbr\u003e    \u003e\u003e\u003e Ry = rotation_matrix(beta, yaxis)\u003cbr\u003e    \u003e\u003e\u003e Rz = rotation_matrix(gamma, zaxis)\u003cbr\u003e    \u003e\u003e\u003e R = concatenate_matrices(Rx, Ry, Rz)\u003cbr\u003e    \u003e\u003e\u003e euler = euler_from_matrix(R, 'rxyz')\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose([alpha, beta, gamma], euler)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e Re = euler_matrix(alpha, beta, gamma, 'rxyz')\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(R, Re)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e al, be, ga = euler_from_matrix(Re, 'rxyz')\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 2)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.561\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.163\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.300\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(Re, euler_matrix(al, be, ga, 'rxyz'))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e qx = quaternion_about_axis(alpha, xaxis)\u003cbr\u003e    \u003e\u003e\u003e qy = quaternion_about_axis(beta, yaxis)\u003cbr\u003e    \u003e\u003e\u003e qz = quaternion_about_axis(gamma, zaxis)\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_multiply(qx, qy)\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_multiply(q, qz)\u003cbr\u003e    \u003e\u003e\u003e Rq = quaternion_matrix(q)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(R, Rq)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e S = scale_matrix(1.23, origin)\u003cbr\u003e    \u003e\u003e\u003e T = translation_matrix((1, 2, 3))\u003cbr\u003e    \u003e\u003e\u003e Z = shear_matrix(beta, xaxis, origin, zaxis)\u003cbr\u003e    \u003e\u003e\u003e R = random_rotation_matrix(numpy.random.rand(3))\u003cbr\u003e    \u003e\u003e\u003e M = concatenate_matrices(T, R, Z, S)\u003cbr\u003e    \u003e\u003e\u003e scale, shear, angles, trans, persp = decompose_matrix(M)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(scale, 1.23)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(trans, (1, 2, 3))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(shear, (0, math.tan(beta), 0))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(R, euler_matrix(axes='sxyz', *angles))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e M1 = compose_matrix(scale, shear, angles, trans, persp)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(M, M1)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e_class_ ` tf.transformations. ` ` Arcball ` (  _initial=None_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eVirtual Trackball Control.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e ball = Arcball()\u003cbr\u003e    \u003e\u003e\u003e ball = Arcball(initial=numpy.identity(4))\u003cbr\u003e    \u003e\u003e\u003e ball.place([320, 320], 320)\u003cbr\u003e    \u003e\u003e\u003e ball.down([500, 250])\u003cbr\u003e    \u003e\u003e\u003e ball.drag([475, 275])\u003cbr\u003e    \u003e\u003e\u003e R = ball.matrix()\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(numpy.sum(R), 3.90583455)\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 3)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.069\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e ball = Arcball(initial=[0, 0, 0, 1])\u003cbr\u003e    \u003e\u003e\u003e ball.place([320, 320], 320)\u003cbr\u003e    \u003e\u003e\u003e ball.setaxes([1,1,0], [-1, 1, 0])\u003cbr\u003e    \u003e\u003e\u003e ball.setconstrain(True)\u003cbr\u003e    \u003e\u003e\u003e ball.down([400, 200])\u003cbr\u003e    \u003e\u003e\u003e ball.drag([200, 400])\u003cbr\u003e    \u003e\u003e\u003e R = ball.matrix()\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(numpy.sum(R), 0.2055924)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e ball.next()\u003cbr\u003e\u003cbr\u003e` down ` (  _point_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eSet initial cursor window coordinates and pick constrain-axis.\u003cbr\u003e` drag ` (  _point_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eUpdate current cursor window coordinates.\u003cbr\u003e` getconstrain ` (  )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn state of constrain to axis mode.\u003cbr\u003e` matrix ` (  )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn homogeneous rotation matrix.\u003cbr\u003e` next ` (  _acceleration=0.0_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eContinue rotation in direction of last drag.\u003cbr\u003e` place ` (  _center_ , _radius_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003ePlace Arcball, e.g. when window size changes.\u003cbr\u003ecenter  :  sequence[2]\u003cbr\u003e     Window coordinates of trackball center.\u003cbr\u003eradius  :  float\u003cbr\u003e     Radius of trackball in window coordinates.\u003cbr\u003e` setaxes ` (  _*axes_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eSet axes to constrain rotations.\u003cbr\u003e` setconstrain ` (  _constrain_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eSet state of constrain to axis mode.\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 4)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.069\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e` tf.transformations. ` ` arcball_constrain_to_axis ` (  _point_ , _axis_ )\u003cbr\u003e\u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn sphere point perpendicular to axis.\u003cbr\u003e` tf.transformations. ` ` arcball_map_to_sphere ` (  _point_ , _center_ ,\u003cbr\u003e_radius_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn unit sphere coordinates from window coordinates.\u003cbr\u003e` tf.transformations. ` ` arcball_nearest_axis ` (  _point_ , _axes_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn axis, which arc is nearest to point.\u003cbr\u003e` tf.transformations. ` ` clip_matrix ` (  _left_ , _right_ , _bottom_ , _top_\u003cbr\u003e, _near_ , _far_ , _perspective=False_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn matrix to obtain normalized device coordinates from frustrum.\u003cbr\u003eThe frustrum bounds are axis-aligned along x (left, right), y (bottom, top)\u003cbr\u003eand z (near, far).\u003cbr\u003eNormalized device coordinates are in range [-1, 1] if coordinates are inside\u003cbr\u003ethe frustrum.\u003cbr\u003eIf perspective is True the frustrum is a truncated pyramid with the\u003cbr\u003eperspective point at origin and direction along z axis, otherwise an\u003cbr\u003eorthographic canonical view volume (a box).\u003cbr\u003eHomogeneous coordinates transformed by the perspective clip matrix need to be\u003cbr\u003edehomogenized (devided by w coordinate).\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e frustrum = numpy.random.rand(6)\u003cbr\u003e    \u003e\u003e\u003e frustrum[1] += frustrum[0]\u003cbr\u003e    \u003e\u003e\u003e frustrum[3] += frustrum[2]\u003cbr\u003e    \u003e\u003e\u003e frustrum[5] += frustrum[4]\u003cbr\u003e    \u003e\u003e\u003e M = clip_matrix(*frustrum, perspective=False)\u003cbr\u003e    \u003e\u003e\u003e numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0])\u003cbr\u003e    array([-1., -1., -1.,  1.])\u003cbr\u003e    \u003e\u003e\u003e numpy.dot(M, [frustrum[1], frustrum[3], frustrum[5], 1.0])\u003cbr\u003e    array([ 1.,  1.,  1.,  1.])\u003cbr\u003e    \u003e\u003e\u003e M = clip_matrix(*frustrum, perspective=True)\u003cbr\u003e    \u003e\u003e\u003e v = numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0])\u003cbr\u003e    \u003e\u003e\u003e v \u002f v[3]\u003cbr\u003e    array([-1., -1., -1.,  1.])\u003cbr\u003e    \u003e\u003e\u003e v = numpy.dot(M, [frustrum[1], frustrum[3], frustrum[4], 1.0])\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 5)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.631\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.303\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.450\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e    \u003e\u003e\u003e v \u002f v[3]\u003cbr\u003e    array([ 1.,  1., -1.,  1.])\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` compose_matrix ` (  _scale=None_ , _shear=None_ ,\u003cbr\u003e_angles=None_ , _translate=None_ , _perspective=None_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn transformation matrix from sequence of transformations.\u003cbr\u003eThis is the inverse of the decompose_matrix function.\u003cbr\u003eSequence of transformations:\u003cbr\u003e     scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler\u003cbr\u003eangles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition\u003cbr\u003eof matrix\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e scale = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e shear = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e angles = (numpy.random.random(3) - 0.5) * (2*math.pi)\u003cbr\u003e    \u003e\u003e\u003e trans = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e persp = numpy.random.random(4) - 0.5\u003cbr\u003e    \u003e\u003e\u003e M0 = compose_matrix(scale, shear, angles, trans, persp)\u003cbr\u003e    \u003e\u003e\u003e result = decompose_matrix(M0)\u003cbr\u003e    \u003e\u003e\u003e M1 = compose_matrix(*result)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(M0, M1)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` concatenate_matrices ` (  _*matrices_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn concatenation of series of transformation matrices.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e M = numpy.random.rand(16).reshape((4, 4)) - 0.5\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(M, concatenate_matrices(M))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T))\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` decompose_matrix ` (  _matrix_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn sequence of transformations from transformation matrix.\u003cbr\u003ematrix  :  array_like\u003cbr\u003e     Non-degenerative homogeneous transformation matrix\u003cbr\u003eReturn tuple of:\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 6)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.753\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.547\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.550\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e     scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler\u003cbr\u003eangles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition\u003cbr\u003eof matrix\u003cbr\u003eRaise ValueError if matrix is of wrong type or degenerative.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e T0 = translation_matrix((1, 2, 3))\u003cbr\u003e    \u003e\u003e\u003e scale, shear, angles, trans, persp = decompose_matrix(T0)\u003cbr\u003e    \u003e\u003e\u003e T1 = translation_matrix(trans)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(T0, T1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e S = scale_matrix(0.123)\u003cbr\u003e    \u003e\u003e\u003e scale, shear, angles, trans, persp = decompose_matrix(S)\u003cbr\u003e    \u003e\u003e\u003e scale[0]\u003cbr\u003e    0.123\u003cbr\u003e    \u003e\u003e\u003e R0 = euler_matrix(1, 2, 3)\u003cbr\u003e    \u003e\u003e\u003e scale, shear, angles, trans, persp = decompose_matrix(R0)\u003cbr\u003e    \u003e\u003e\u003e R1 = euler_matrix(*angles)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(R0, R1)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` euler_from_matrix ` (  _matrix_ , _axes='sxyz'_ )\u003cbr\u003e\u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn Euler angles from rotation matrix for specified axis sequence.\u003cbr\u003eaxes : One of 24 axis sequences as string or encoded tuple\u003cbr\u003eNote that many Euler angle triplets can describe one matrix.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e R0 = euler_matrix(1, 2, 3, 'syxz')\u003cbr\u003e    \u003e\u003e\u003e al, be, ga = euler_from_matrix(R0, 'syxz')\u003cbr\u003e    \u003e\u003e\u003e R1 = euler_matrix(al, be, ga, 'syxz')\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(R0, R1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e angles = (4.0*math.pi) * (numpy.random.random(3) - 0.5)\u003cbr\u003e    \u003e\u003e\u003e for axes in _AXES2TUPLE.keys():\u003cbr\u003e    ...    R0 = euler_matrix(axes=axes, *angles)\u003cbr\u003e    ...    R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes))\u003cbr\u003e    ...    if not numpy.allclose(R0, R1): print axes, \"failed\"\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` euler_from_quaternion ` (  _quaternion_ ,\u003cbr\u003e_axes='sxyz'_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 7)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.841\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.723\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.800\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e\u003cbr\u003eReturn Euler angles from quaternion for specified axis sequence.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e angles = euler_from_quaternion([0.06146124, 0, 0, 0.99810947])\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(angles, [0.123, 0, 0])\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` euler_matrix ` (  _ai_ , _aj_ , _ak_ , _axes='sxyz'_\u003cbr\u003e)  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn homogeneous rotation matrix from Euler angles and axis sequence.\u003cbr\u003eai, aj, ak : Euler\u2019s roll, pitch and yaw angles axes : One of 24 axis\u003cbr\u003esequences as string or encoded tuple\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e R = euler_matrix(1, 2, 3, 'syxz')\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(numpy.sum(R[0]), -1.34786452)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e R = euler_matrix(1, 2, 3, (0, 1, 0, 1))\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(numpy.sum(R[0]), -0.383436184)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e ai, aj, ak = (4.0*math.pi) * (numpy.random.random(3) - 0.5)\u003cbr\u003e    \u003e\u003e\u003e for axes in _AXES2TUPLE.keys():\u003cbr\u003e    ...    R = euler_matrix(ai, aj, ak, axes)\u003cbr\u003e    \u003e\u003e\u003e for axes in _TUPLE2AXES.keys():\u003cbr\u003e    ...    R = euler_matrix(ai, aj, ak, axes)\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` identity_matrix ` (  )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn 4x4 identity\u002funit matrix.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e I = identity_matrix()\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(I, numpy.dot(I, I))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e numpy.sum(I), numpy.trace(I)\u003cbr\u003e    (4.0, 4.0)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(I, numpy.identity(4, dtype=numpy.float64))\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 8)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.022\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.100\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` inverse_matrix ` (  _matrix_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn inverse of square transformation matrix.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e M0 = random_rotation_matrix()\u003cbr\u003e    \u003e\u003e\u003e M1 = inverse_matrix(M0.T)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(M1, numpy.linalg.inv(M0.T))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e for size in range(1, 7):\u003cbr\u003e    ...     M0 = numpy.random.rand(size, size)\u003cbr\u003e    ...     M1 = inverse_matrix(M0)\u003cbr\u003e    ...     if not numpy.allclose(M1, numpy.linalg.inv(M0)): print size\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` is_same_transform ` (  _matrix0_ , _matrix1_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn True if two matrices perform same transformation.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(numpy.identity(4), numpy.identity(4))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(numpy.identity(4), random_rotation_matrix())\u003cbr\u003e    False\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` orthogonalization_matrix ` (  _lengths_ , _angles_ )\u003cbr\u003e\u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn orthogonalization matrix for crystallographic cell coordinates.\u003cbr\u003eAngles are expected in degrees.\u003cbr\u003eThe de-orthogonalization matrix is the inverse.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e O = orthogonalization_matrix((10., 10., 10.), (90., 90., 90.))\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7])\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(numpy.sum(O), 43.063229)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 9)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.000\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e -0.069\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.050\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e` tf.transformations. ` ` projection_from_matrix ` (  _matrix_ ,\u003cbr\u003e_pseudo=False_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn projection plane and perspective point from projection matrix.\u003cbr\u003eReturn values are same as arguments for projection_matrix function: point,\u003cbr\u003enormal, direction, perspective, and pseudo.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e point = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e normal = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e direct = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e persp = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e P0 = projection_matrix(point, normal)\u003cbr\u003e    \u003e\u003e\u003e result = projection_from_matrix(P0)\u003cbr\u003e    \u003e\u003e\u003e P1 = projection_matrix(*result)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(P0, P1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e P0 = projection_matrix(point, normal, direct)\u003cbr\u003e    \u003e\u003e\u003e result = projection_from_matrix(P0)\u003cbr\u003e    \u003e\u003e\u003e P1 = projection_matrix(*result)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(P0, P1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e P0 = projection_matrix(point, normal, perspective=persp, pseudo=False)\u003cbr\u003e    \u003e\u003e\u003e result = projection_from_matrix(P0, pseudo=False)\u003cbr\u003e    \u003e\u003e\u003e P1 = projection_matrix(*result)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(P0, P1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e P0 = projection_matrix(point, normal, perspective=persp, pseudo=True)\u003cbr\u003e    \u003e\u003e\u003e result = projection_from_matrix(P0, pseudo=True)\u003cbr\u003e    \u003e\u003e\u003e P1 = projection_matrix(*result)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(P0, P1)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` projection_matrix ` (  _point_ , _normal_ ,\u003cbr\u003e_direction=None_ , _perspective=None_ , _pseudo=False_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn matrix to project onto plane defined by point and normal.\u003cbr\u003eUsing either perspective point, projection direction, or none of both.\u003cbr\u003eIf pseudo is True, perspective projections will preserve relative depth such\u003cbr\u003ethat Perspective = dot(Orthogonal, PseudoPerspective).\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 10)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.683\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.406\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.650\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e P = projection_matrix((0, 0, 0), (1, 0, 0))\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:])\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e point = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e normal = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e direct = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e persp = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e P0 = projection_matrix(point, normal)\u003cbr\u003e    \u003e\u003e\u003e P1 = projection_matrix(point, normal, direction=direct)\u003cbr\u003e    \u003e\u003e\u003e P2 = projection_matrix(point, normal, perspective=persp)\u003cbr\u003e    \u003e\u003e\u003e P3 = projection_matrix(point, normal, perspective=persp, pseudo=True)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(P2, numpy.dot(P0, P3))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e P = projection_matrix((3, 0, 0), (1, 1, 0), (1, 0, 0))\u003cbr\u003e    \u003e\u003e\u003e v0 = (numpy.random.rand(4, 5) - 0.5) * 20.0\u003cbr\u003e    \u003e\u003e\u003e v0[3] = 1.0\u003cbr\u003e    \u003e\u003e\u003e v1 = numpy.dot(P, v0)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(v1[1], v0[1])\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(v1[0], 3.0-v1[1])\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` quaternion_about_axis ` (  _angle_ , _axis_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn quaternion for rotation about axis.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_about_axis(0.123, (1, 0, 0))\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(q, [0.06146124, 0, 0, 0.99810947])\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` quaternion_conjugate ` (  _quaternion_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn conjugate of quaternion.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e q0 = random_quaternion()\u003cbr\u003e    \u003e\u003e\u003e q1 = quaternion_conjugate(q0)\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 11)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.907\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.855\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.950\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e    \u003e\u003e\u003e q1[3] == q0[3] and all(q1[:3] == -q0[:3])\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` quaternion_from_euler ` (  _ai_ , _aj_ , _ak_ ,\u003cbr\u003e_axes='sxyz'_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn quaternion from Euler angles and axis sequence.\u003cbr\u003eai, aj, ak : Euler\u2019s roll, pitch and yaw angles axes : One of 24 axis\u003cbr\u003esequences as string or encoded tuple\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_from_euler(1, 2, 3, 'ryxz')\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(q, [0.310622, -0.718287, 0.444435, 0.435953])\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` quaternion_from_matrix ` (  _matrix_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn quaternion from rotation matrix.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e R = rotation_matrix(0.123, (1, 2, 3))\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_from_matrix(R)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(q, [0.0164262, 0.0328524, 0.0492786, 0.9981095])\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` quaternion_inverse ` (  _quaternion_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn inverse of quaternion.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e q0 = random_quaternion()\u003cbr\u003e    \u003e\u003e\u003e q1 = quaternion_inverse(q0)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(quaternion_multiply(q0, q1), [0, 0, 0, 1])\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` quaternion_matrix ` (  _quaternion_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn homogeneous rotation matrix from quaternion.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 12)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.656\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.352\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.700\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e    \u003e\u003e\u003e R = quaternion_matrix([0.06146124, 0, 0, 0.99810947])\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(R, rotation_matrix(0.123, (1, 0, 0)))\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` quaternion_multiply ` (  _quaternion1_ ,\u003cbr\u003e_quaternion0_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn multiplication of two quaternions.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_multiply([1, -2, 3, 4], [-5, 6, 7, 8])\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(q, [-44, -14, 48, 28])\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` quaternion_slerp ` (  _quat0_ , _quat1_ , _fraction_\u003cbr\u003e, _spin=0_ , _shortestpath=True_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn spherical linear interpolation between two quaternions.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e q0 = random_quaternion()\u003cbr\u003e    \u003e\u003e\u003e q1 = random_quaternion()\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_slerp(q0, q1, 0.0)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(q, q0)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_slerp(q0, q1, 1.0, 1)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(q, q1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e q = quaternion_slerp(q0, q1, 0.5)\u003cbr\u003e    \u003e\u003e\u003e angle = math.acos(numpy.dot(q0, q))\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(2.0, math.acos(numpy.dot(q0, q1)) \u002f angle) or         numpy.allclose(2.0,\u003cbr\u003emath.acos(-numpy.dot(q0, q1)) \u002f angle)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` random_quaternion ` (  _rand=None_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn uniform random unit quaternion.\u003cbr\u003erand: array like or None\u003cbr\u003e     Three independent random variables that are uniformly distributed between 0 and 1.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 13)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.071\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.071\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.200\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e    \u003e\u003e\u003e q = random_quaternion()\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(1.0, vector_norm(q))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e q = random_quaternion(numpy.random.random(3))\u003cbr\u003e    \u003e\u003e\u003e q.shape\u003cbr\u003e    (4,)\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` random_rotation_matrix ` (  _rand=None_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn uniform random rotation matrix.\u003cbr\u003ernd: array like\u003cbr\u003e     Three independent random variables that are uniformly distributed between 0 and 1 for each returned quaternion.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e R = random_rotation_matrix()\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(numpy.dot(R.T, R), numpy.identity(4))\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` random_vector ` (  _size_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn array of random doubles in the half-open interval [0.0, 1.0).\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e v = random_vector(10000)\u003cbr\u003e    \u003e\u003e\u003e numpy.all(v \u003e= 0.0) and numpy.all(v \u003c 1.0)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e v0 = random_vector(10)\u003cbr\u003e    \u003e\u003e\u003e v1 = random_vector(10)\u003cbr\u003e    \u003e\u003e\u003e numpy.any(v0 == v1)\u003cbr\u003e    False\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` reflection_from_matrix ` (  _matrix_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn mirror plane point and normal vector from reflection matrix.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e v0 = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e v1 = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e M0 = reflection_matrix(v0, v1)\u003cbr\u003e    \u003e\u003e\u003e point, normal = reflection_from_matrix(M0)\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 14)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.538\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.117\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.250\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e    \u003e\u003e\u003e M1 = reflection_matrix(point, normal)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(M0, M1)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` reflection_matrix ` (  _point_ , _normal_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn matrix to mirror at plane defined by point and normal vector.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e v0 = numpy.random.random(4) - 0.5\u003cbr\u003e    \u003e\u003e\u003e v0[3] = 1.0\u003cbr\u003e    \u003e\u003e\u003e v1 = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e R = reflection_matrix(v0, v1)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(2., numpy.trace(R))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(v0, numpy.dot(R, v0))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e v2 = v0.copy()\u003cbr\u003e    \u003e\u003e\u003e v2[:3] += v1\u003cbr\u003e    \u003e\u003e\u003e v3 = v0.copy()\u003cbr\u003e    \u003e\u003e\u003e v2[:3] -= v1\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(v2, numpy.dot(R, v3))\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` rotation_from_matrix ` (  _matrix_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn rotation angle and axis from rotation matrix.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e angle = (random.random() - 0.5) * (2*math.pi)\u003cbr\u003e    \u003e\u003e\u003e direc = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e point = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e R0 = rotation_matrix(angle, direc, point)\u003cbr\u003e    \u003e\u003e\u003e angle, direc, point = rotation_from_matrix(R0)\u003cbr\u003e    \u003e\u003e\u003e R1 = rotation_matrix(angle, direc, point)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(R0, R1)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` rotation_matrix ` (  _angle_ , _direction_ ,\u003cbr\u003e_point=None_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e","\u003cb\u003ePath:\u003c\u002fb\u003e (6, 2, 1, 0, 15)\u003cbr\u003e\u003cb\u003ePath Relevance:\u003c\u002fb\u003e 0.547\u003cbr\u003e\u003cb\u003eCalibrated Relevance:\u003c\u002fb\u003e 0.136\u003cbr\u003e\u003cb\u003eLocal Relevance:\u003c\u002fb\u003e 0.500\u003cbr\u003e\u003cb\u003eChild Relevance:\u003c\u002fb\u003e \u003cbr\u003e\u003cbr\u003e\u003cb\u003eDescription:\u003c\u002fb\u003e\u003cbr\u003e\u003cbr\u003eReturn matrix to rotate about axis defined by point and direction.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e angle = (random.random() - 0.5) * (2*math.pi)\u003cbr\u003e    \u003e\u003e\u003e direc = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e point = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e R0 = rotation_matrix(angle, direc, point)\u003cbr\u003e    \u003e\u003e\u003e R1 = rotation_matrix(angle-2*math.pi, direc, point)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(R0, R1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e R0 = rotation_matrix(angle, direc, point)\u003cbr\u003e    \u003e\u003e\u003e R1 = rotation_matrix(-angle, -direc, point)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(R0, R1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e I = numpy.identity(4, numpy.float64)\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(I, rotation_matrix(math.pi*2, direc))\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e numpy.allclose(2., numpy.trace(rotation_matrix(math.pi\u002f2,\u003cbr\u003e    ...                                                direc, point)))\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e` tf.transformations. ` ` scale_from_matrix ` (  _matrix_ )  \u00c2\u00b6\u003cbr\u003e\u003cbr\u003eReturn scaling factor, origin and direction from scaling matrix.\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    \u003e\u003e\u003e factor = random.random() * 10 - 5\u003cbr\u003e    \u003e\u003e\u003e origin = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e direct = numpy.random.random(3) - 0.5\u003cbr\u003e    \u003e\u003e\u003e S0 = scale_matrix(factor, origin)\u003cbr\u003e    \u003e\u003e\u003e factor, origin, direction = scale_from_matrix(S0)\u003cbr\u003e    \u003e\u003e\u003e S1 = scale_matrix(factor, origin, direction)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(S0, S1)\u003cbr\u003e    True\u003cbr\u003e    \u003e\u003e\u003e S0 = scale_matrix(factor, origin, direct)\u003cbr\u003e    \u003e\u003e\u003e factor, origin, direction = scale_from_matrix(S0)\u003cbr\u003e    \u003e\u003e\u003e S1 = scale_matrix(factor, origin, direction)\u003cbr\u003e    \u003e\u003e\u003e is_same_transform(S0, S1)\u003cbr\u003e    True\u003cbr\u003e\u003cbr\u003e\u003cb\u003eReasoning:\u003c\u002fb\u003e\u003cbr\u003e"],"marker":{"color":[1.0,0.8467786908149719,0.7068872451782227,0.0,0.7768915891647339,0.6836297512054443,0.0,0.8026372194290161,0.6138119101524353,0.0,0.0,0.01956196501851082,0.0,0.8341217041015625,0.5003459453582764,0.499977171421051,0.5696703195571899,0.5234936475753784,0.8918459415435791,0.7769949436187744,0.684929609298706,0.9375,0.0,0.0,0.8696914911270142,0.0,0.0,0.7245577573776245,0.6780988574028015,0.8640471696853638,0.8175327181816101,0.0,0.0,0.0,0.0,0.0,0.7990320920944214,0.0,0.0,0.0,0.0,0.5203160643577576,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.8496989607810974,0.8265237808227539,0.8728345632553101,0.571881890296936,0.0,0.556579053401947,0.8908852338790894,0.0,0.8249599933624268,0.8481767177581787,0.8388781547546387,0.5697492361068726,0.0,0.9000023603439331,0.6884641051292419,0.0,0.0,0.03277401253581047,0.0,0.0,0.6402239799499512,0.6803170442581177,0.8033614158630371,0.0,0.5591890811920166,0.6981215476989746,0.5980380773544312,0.658711314201355,0.5629057288169861,0.6334236264228821,0.0,0.0,0.780571460723877,0.7405015230178833,0.8401376008987427,0.5810385346412659,0.8314226865768433,0.51120525598526,0.0,0.0,0.6132473349571228,0.534485936164856,0.5347234010696411,0.6634035706520081,0.5656939744949341,0.5579572319984436,0.6428327560424805,0.025016549974679947,0.025011630728840828,0.025013143196702003,0.02501324564218521,0.025012196972966194,0.0,0.07141817361116409,0.0,0.0,0.0,0.0,0.0,0.5881297588348389,0.0,0.0,0.0,0.871537446975708,0.8131948709487915,0.5613684058189392,0.0,0.0,0.630957841873169,0.7530001401901245,0.8409537076950073,0.0,0.0,0.6827640533447266,0.9073651432991028,0.6555582880973816,0.07057046890258789,0.5381760001182556,0.5474845767021179],"colorbar":{"thickness":15,"title":{"text":"Relevance"}},"colorscale":[[0.0,"rgb(255,255,229)"],[0.125,"rgb(247,252,185)"],[0.25,"rgb(217,240,163)"],[0.375,"rgb(173,221,142)"],[0.5,"rgb(120,198,121)"],[0.625,"rgb(65,171,93)"],[0.75,"rgb(35,132,67)"],[0.875,"rgb(0,104,55)"],[1.0,"rgb(0,69,41)"]],"line":{"color":["darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","#FFD700","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","#FFD700","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","#FFD700","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","#FFD700","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","darkgrey","#FFD700","darkgrey","darkgrey","darkgrey","#FFD700","darkgrey","darkgrey","darkgrey","darkgrey"],"width":[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]},"showscale":true,"size":15,"symbol":["circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","circle","diamond","circle","circle","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond","diamond"]},"mode":"markers+text","text":["R","0","1","2","3","4","5","6","7","8","0","1","2","3","0","1","2","3","4","5","6","7","0","1","2","3","0","1","2","3","4","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","0","1","2","3","4","5","0","1","2","0","1","2","3","0","0","1","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15"],"textfont":{"color":"white","family":"sans serif","size":8},"textposition":"middle center","x":[0,-727.2727272727273,-545.4545454545455,-363.6363636363636,-181.8181818181818,0.0,181.8181818181818,363.6363636363636,545.4545454545455,727.2727272727273,-727.2727272727273,-630.3030303030303,-533.3333333333334,-436.3636363636363,-339.3939393939394,-242.42424242424244,-145.4545454545454,-48.48484848484847,48.48484848484847,145.4545454545454,242.42424242424235,339.3939393939393,436.36363636363643,533.3333333333334,630.3030303030303,727.2727272727273,-727.2727272727273,-684.4919786096257,-641.711229946524,-598.9304812834224,-556.1497326203208,-513.3689839572191,-470.58823529411757,-427.80748663101605,-385.0267379679144,-342.24598930481284,-299.4652406417112,-256.68449197860957,-213.903743315508,-171.12299465240645,-128.34224598930484,-85.56149732620322,-42.78074866310161,0.0,42.78074866310161,85.56149732620322,128.34224598930484,171.12299465240645,213.90374331550805,256.6844919786097,299.46524064171126,342.2459893048129,385.02673796791436,427.807486631016,470.58823529411757,513.3689839572191,556.1497326203208,598.9304812834224,641.711229946524,684.4919786096257,727.2727272727273,-727.2727272727273,-484.8484848484849,-242.42424242424244,0.0,242.42424242424235,484.8484848484849,727.2727272727273,-727.2727272727273,-704.1847041847042,-681.0966810966811,-658.008658008658,-634.9206349206349,-611.8326118326119,-588.7445887445888,-565.6565656565657,-542.5685425685425,-519.4805194805194,-496.3924963924964,-473.30447330447333,-450.2164502164502,-427.1284271284271,-404.04040404040404,-380.95238095238096,-357.8643578643579,-334.7763347763348,-311.6883116883117,-288.6002886002886,-265.5122655122655,-242.42424242424244,-219.33621933621936,-196.24819624819628,-173.16017316017317,-150.0721500721501,-126.98412698412702,-103.89610389610392,-80.80808080808085,-57.72005772005775,-34.63203463203467,-11.544011544011584,11.544011544011502,34.63203463203467,57.720057720057675,80.80808080808085,103.89610389610385,126.98412698412702,150.07215007215,173.16017316017317,196.2481962481962,219.33621933621936,242.42424242424235,265.5122655122655,288.60028860028854,311.6883116883117,334.7763347763347,357.8643578643579,380.9523809523809,404.04040404040404,427.12842712842706,450.2164502164502,473.3044733044732,496.3924963924964,519.4805194805194,542.5685425685425,565.6565656565656,588.7445887445888,611.8326118326117,634.9206349206349,658.0086580086579,681.0966810966811,704.1847041847041,727.2727272727273],"y":[0,-100,-100,-100,-100,-100,-100,-100,-100,-100,-200,-200,-200,-200,-200,-200,-200,-200,-200,-200,-200,-200,-200,-200,-200,-200,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-300,-400,-400,-400,-400,-400,-400,-400,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500,-500],"type":"scatter"}],                        {"height":800,"hoverlabel":{"align":"left","font":{"size":12}},"hovermode":"closest","margin":{"b":5,"l":5,"r":700,"t":80},"paper_bgcolor":"white","plot_bgcolor":"white","showlegend":false,"title":{"font":{"size":12},"pad":{"b":0,"t":0},"text":"\u003cb\u003ePrediction Tree\u003c\u002fb\u003e for \u003cb\u003eQuery\u003c\u002fb\u003e: Simple takeoff then do yaw rotation    Arming and takeoff work fine but i don't know how to do yaw rotation:    class controller:      def __init__(self):\u003cbr\u003erospy.Subscriber('mavros\u002fstate', State, self.state_cb)                    self.state = State()          def state_cb(self, msg):          self.state = msg            def move(self,x,y,z):\u003cbr\u003epub_posisi = rospy.Publisher(\"\u002fmavros\u002fsetpoin...","x":0.05,"xanchor":"left","y":0.97,"yanchor":"top"},"width":1600,"xaxis":{"showgrid":false,"showticklabels":false,"zeroline":false},"yaxis":{"showgrid":false,"showticklabels":false,"zeroline":false},"template":{"data":{"histogram2dcontour":[{"type":"histogram2dcontour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"choropleth":[{"type":"choropleth","colorbar":{"outlinewidth":0,"ticks":""}}],"histogram2d":[{"type":"histogram2d","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmap":[{"type":"heatmap","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contourcarpet":[{"type":"contourcarpet","colorbar":{"outlinewidth":0,"ticks":""}}],"contour":[{"type":"contour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"surface":[{"type":"surface","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"mesh3d":[{"type":"mesh3d","colorbar":{"outlinewidth":0,"ticks":""}}],"scatter":[{"fillpattern":{"fillmode":"overlay","size":10,"solidity":0.2},"type":"scatter"}],"parcoords":[{"type":"parcoords","line":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolargl":[{"type":"scatterpolargl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"bar":[{"error_x":{"color":"#2a3f5f"},"error_y":{"color":"#2a3f5f"},"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"scattergeo":[{"type":"scattergeo","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolar":[{"type":"scatterpolar","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"scattergl":[{"type":"scattergl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatter3d":[{"type":"scatter3d","line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermap":[{"type":"scattermap","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermapbox":[{"type":"scattermapbox","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterternary":[{"type":"scatterternary","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattercarpet":[{"type":"scattercarpet","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"carpet":[{"aaxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"baxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"type":"carpet"}],"table":[{"cells":{"fill":{"color":"#EBF0F8"},"line":{"color":"white"}},"header":{"fill":{"color":"#C8D4E3"},"line":{"color":"white"}},"type":"table"}],"barpolar":[{"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"pie":[{"automargin":true,"type":"pie"}]},"layout":{"autotypenumbers":"strict","colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#2a3f5f"},"hovermode":"closest","hoverlabel":{"align":"left"},"paper_bgcolor":"white","plot_bgcolor":"#E5ECF6","polar":{"bgcolor":"#E5ECF6","angularaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"radialaxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"ternary":{"bgcolor":"#E5ECF6","aaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"baxis":{"gridcolor":"white","linecolor":"white","ticks":""},"caxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"sequential":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"sequentialminus":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]]},"xaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"yaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"scene":{"xaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"yaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"zaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2}},"shapedefaults":{"line":{"color":"#2a3f5f"}},"annotationdefaults":{"arrowcolor":"#2a3f5f","arrowhead":0,"arrowwidth":1},"geo":{"bgcolor":"white","landcolor":"#E5ECF6","subunitcolor":"white","showland":true,"showlakes":true,"lakecolor":"white"},"title":{"x":0.05},"mapbox":{"style":"light"}}}},                        {"responsive": true}                    )                };            </script>        </div>
</body>
</html>